(function (React,reactRedux,ReactDOM) {
  'use strict';

  var React__default = 'default' in React ? React['default'] : React;
  ReactDOM = ReactDOM && ReactDOM.hasOwnProperty('default') ? ReactDOM['default'] : ReactDOM;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function Vline(props) {
    var x = props.x,
        opacity = props.opacity,
        length = props.length,
        color = props.color;
    return React__default.createElement("line", {
      x1: x,
      y1: 0,
      x2: x,
      y2: length,
      strokeOpacity: opacity,
      stroke: color,
      strokeWidth: "1",
      pointerEvents: "none"
    });
  }
  function Hline(props) {
    var y = props.y,
        opacity = props.opacity,
        length = props.length,
        color = props.color;
    return React__default.createElement("line", {
      x1: 0,
      y1: y,
      x2: length,
      y2: y,
      strokeOpacity: opacity,
      stroke: color,
      strokeWidth: "1",
      pointerEvents: "none"
    });
  }

  var _MODE_TAG;
  var COLORS = {
    BLUE: '#27dded',
    RED: '#e13d1c',
    GREEN: '#14bb5b',
    CREAM: '#ece5d4'
  };
  var MODE = {
    DOCUMENT: 0,
    PATH: 1,
    DRAW: 2,
    ARC: 3
  };
  var MODE_TAG = (_MODE_TAG = {}, _defineProperty(_MODE_TAG, MODE.DOCUMENT, 'Document'), _defineProperty(_MODE_TAG, MODE.PATH, 'Path'), _defineProperty(_MODE_TAG, MODE.DRAW, 'Draw'), _defineProperty(_MODE_TAG, MODE.ARC, 'Arc'), _MODE_TAG);
  var POINT_TYPES = {
    STRAIGHT: 0,
    ARC: 1
  };

  function guid() {
    function s4() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }

    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
  }

  function action(type) {
    return function () {
      return {
        type: type
      };
    };
  }
  /* WORKSPACE */


  var setDrawMode = function setDrawMode() {
    return {
      type: 'TOGGLE_MODE',
      mode: MODE.DRAW
    };
  };
  var setDocumentMode = function setDocumentMode() {
    return {
      type: 'TOGGLE_MODE',
      mode: MODE.DOCUMENT
    };
  };
  var toggleMode = function toggleMode(mode) {
    return {
      type: 'TOGGLE_MODE',
      mode: mode
    };
  };
  var toggleProofView = action('TOGGLE_PROOF_VIEW');
  var toggleHelp = action('TOGGLE_HELP');
  var deselectAllPoints = action('DESELECT_ALL_POINTS');
  /* DRAWING */

  var drawArc = function drawArc() {
    return {
      type: 'DRAW_ARC'
    };
  };
  /* POINT */

  function addPoint(point) {
    return {
      id: guid(),
      type: 'ADD_POINT',
      point: point
    };
  }
  function selectPoint(e, index$$1) {
    e.stopPropagation();
    return {
      type: e.shiftKey ? 'ADD_SELECT_POINT' : 'SELECT_POINT',
      index: index$$1
    };
  }
  var selectAll = action('SELECT_ALL');
  var nextPoint = action('NEXT_POINT');
  var deleteSelectedPoints = action('DELETE_SELECTED_POINTS');
  function nudge(vector, isSuper) {
    return {
      type: 'NUDGE',
      vector: vector
    };
  }
  function updatePoint(id, data) {
    return {
      type: 'UPDATE_POINT',
      id: id,
      data: data
    };
  }
  function sendInstructions(instructions) {
    return {
      type: 'SEND_INSTRUCTIONS',
      instructions: instructions
    };
  }
  /* TABLET */

  function adjust(key, value) {
    return function () {
      return {
        type: 'ADJUST_RUNE_VALUE',
        key: key,
        value: value
      };
    };
  }

  var updateTablet = function updateTablet(tablet) {
    return {
      type: 'UPDATE_RUNE',
      tablet: tablet
    };
  };
  var increaseX = adjust('x', 1);
  var increaseY = adjust('y', 1);
  var decreaseX = adjust('x', -1);
  var decreaseY = adjust('y', -1);
  var increaseGridUnit = adjust('gridUnit', 1);
  var decreaseGridUnit = adjust('gridUnit', -1);
  /* PATH PANEL */

  var deletePath = function deletePath(id) {
    return {
      type: 'DELETE_PATH',
      id: id
    };
  };
  var selectPath = function selectPath(id) {
    return {
      type: 'SELECT_PATH',
      id: id
    };
  };
  var togglePathClosed = function togglePathClosed(id) {
    return {
      type: 'TOGGLE_PATH_CLOSED',
      id: id
    };
  };
  var addSubPath = function addSubPath(id) {
    return {
      type: 'ADD_SUB_PATH',
      id: id
    };
  };
  var addPath = function addPath() {
    return {
      type: 'ADD_PATH'
    };
  };
  var togglePathFill = function togglePathFill(id) {
    return {
      type: 'TOGGLE_PATH_FILL',
      id: id
    };
  };

  var actionCreators = /*#__PURE__*/Object.freeze({
    setDrawMode: setDrawMode,
    setDocumentMode: setDocumentMode,
    toggleMode: toggleMode,
    toggleProofView: toggleProofView,
    toggleHelp: toggleHelp,
    deselectAllPoints: deselectAllPoints,
    drawArc: drawArc,
    addPoint: addPoint,
    selectPoint: selectPoint,
    selectAll: selectAll,
    nextPoint: nextPoint,
    deleteSelectedPoints: deleteSelectedPoints,
    nudge: nudge,
    updatePoint: updatePoint,
    sendInstructions: sendInstructions,
    updateTablet: updateTablet,
    increaseX: increaseX,
    increaseY: increaseY,
    decreaseX: decreaseX,
    decreaseY: decreaseY,
    increaseGridUnit: increaseGridUnit,
    decreaseGridUnit: decreaseGridUnit,
    deletePath: deletePath,
    selectPath: selectPath,
    togglePathClosed: togglePathClosed,
    addSubPath: addSubPath,
    addPath: addPath,
    togglePathFill: togglePathFill
  });

  var Point =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Point, _Component);

    function Point(props) {
      var _this;

      _classCallCheck(this, Point);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Point).call(this, props));
      _this.state = {
        selected: props.selected
      };
      return _this;
    }

    _createClass(Point, [{
      key: "render",
      value: function render() {
        var props = this.props;
        return React__default.createElement("circle", {
          cx: "".concat(props.x * 100, "%"),
          cy: "".concat(props.y * 100, "%"),
          r: 8,
          fill: 'white',
          stroke: props.selected ? COLORS.RED : COLORS.BLUE,
          strokeWidth: 2,
          onMouseDown: function onMouseDown(e) {
            return props.onMouseDown && props.onMouseDown(e);
          },
          onClick: function onClick(e) {
            return props.onClick && props.onClick(e);
          }
        });
      }
    }]);

    return Point;
  }(React.Component);

  var Group = (function (props) {
    return React__default.createElement("g", null, props.children);
  });

  function symbolObservablePonyfill(root) {
  	var result;
  	var Symbol = root.Symbol;

  	if (typeof Symbol === 'function') {
  		if (Symbol.observable) {
  			result = Symbol.observable;
  		} else {
  			result = Symbol('observable');
  			Symbol.observable = result;
  		}
  	} else {
  		result = '@@observable';
  	}

  	return result;
  }

  /* global window */

  var root;

  if (typeof self !== 'undefined') {
    root = self;
  } else if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof module !== 'undefined') {
    root = module;
  } else {
    root = Function('return this')();
  }

  var result = symbolObservablePonyfill(root);

  /**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */
  var ActionTypes = {
    INIT: '@@redux/INIT' + Math.random().toString(36).substring(7).split('').join('.'),
    REPLACE: '@@redux/REPLACE' + Math.random().toString(36).substring(7).split('').join('.')
  };

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */
  function isPlainObject(obj) {
    if ((typeof obj === 'undefined' ? 'undefined' : _typeof$1(obj)) !== 'object' || obj === null) return false;

    var proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(obj) === proto;
  }

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error('Expected the enhancer to be a function.');
      }

      return enhancer(createStore)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }

    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */
    function getState() {
      if (isDispatching) {
        throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
      }

      return currentState;
    }

    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */
    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected the listener to be a function.');
      }

      if (isDispatching) {
        throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      var isSubscribed = true;

      ensureCanMutateNextListeners();
      nextListeners.push(listener);

      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        if (isDispatching) {
          throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
        }

        isSubscribed = false;

        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
      };
    }

    /**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing “what changed”. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */
    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }

      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }

      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;
      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }

    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error('Expected the nextReducer to be a function.');
      }

      currentReducer = nextReducer;
      dispatch({ type: ActionTypes.REPLACE });
    }

    /**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */
    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe(observer) {
          if ((typeof observer === 'undefined' ? 'undefined' : _typeof$1(observer)) !== 'object' || observer === null) {
            throw new TypeError('Expected the observer to be an object.');
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return { unsubscribe: unsubscribe };
        }
      }, _ref[result] = function () {
        return this;
      }, _ref;
    }

    // When a store is created, an "INIT" action is dispatched so that every
    // reducer returns their initial state. This effectively populates
    // the initial state tree.
    dispatch({ type: ActionTypes.INIT });

    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[result] = observable, _ref2;
  }

  /**
   * Prints a warning in the console if it exists.
   *
   * @param {String} message The warning message.
   * @returns {void}
   */
  function warning(message) {
    /* eslint-disable no-console */
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    /* eslint-enable no-console */
    try {
      // This error was thrown as a convenience so that if you enable
      // "break on all exceptions" in your console,
      // it would pause the execution at this line.
      throw new Error(message);
    } catch (e) {} // eslint-disable-line no-empty
  }

  function getUndefinedStateErrorMessage(key, action) {
    var actionType = action && action.type;
    var actionDescription = actionType && 'action "' + String(actionType) + '"' || 'an action';

    return 'Given ' + actionDescription + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
  }

  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    var reducerKeys = Object.keys(reducers);
    var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

    if (reducerKeys.length === 0) {
      return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
    }

    if (!isPlainObject(inputState)) {
      return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
    }

    var unexpectedKeys = Object.keys(inputState).filter(function (key) {
      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
    });

    unexpectedKeys.forEach(function (key) {
      unexpectedKeyCache[key] = true;
    });

    if (action && action.type === ActionTypes.REPLACE) return;

    if (unexpectedKeys.length > 0) {
      return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
    }
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, { type: ActionTypes.INIT });

      if (typeof initialState === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
      }

      var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
      if (typeof reducer(undefined, { type: type }) === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
      }
    });
  }

  /**
   * Turns an object whose values are different reducer functions, into a single
   * reducer function. It will call every child reducer, and gather their results
   * into a single state object, whose keys correspond to the keys of the passed
   * reducer functions.
   *
   * @param {Object} reducers An object whose values correspond to different
   * reducer functions that need to be combined into one. One handy way to obtain
   * it is to use ES6 `import * as reducers` syntax. The reducers may never return
   * undefined for any action. Instead, they should return their initial state
   * if the state passed to them was undefined, and the current state for any
   * unrecognized action.
   *
   * @returns {Function} A reducer function that invokes every reducer inside the
   * passed object, and builds a state object with the same shape.
   */
  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};
    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      if (process.env.NODE_ENV !== 'production') {
        if (typeof reducers[key] === 'undefined') {
          warning('No reducer provided for key "' + key + '"');
        }
      }

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }
    var finalReducerKeys = Object.keys(finalReducers);

    var unexpectedKeyCache = void 0;
    if (process.env.NODE_ENV !== 'production') {
      unexpectedKeyCache = {};
    }

    var shapeAssertionError = void 0;
    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination() {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var action = arguments[1];

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      if (process.env.NODE_ENV !== 'production') {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
        if (warningMessage) {
          warning(warningMessage);
        }
      }

      var hasChanged = false;
      var nextState = {};
      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);
        if (typeof nextStateForKey === 'undefined') {
          var errorMessage = getUndefinedStateErrorMessage(_key, action);
          throw new Error(errorMessage);
        }
        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      return hasChanged ? nextState : state;
    };
  }

  /**
   * Composes single-argument functions from right to left. The rightmost
   * function can take multiple arguments as it provides the signature for
   * the resulting composite function.
   *
   * @param {...Function} funcs The functions to compose.
   * @returns {Function} A function obtained by composing the argument functions
   * from right to left. For example, compose(f, g, h) is identical to doing
   * (...args) => f(g(h(...args))).
   */

  function compose() {
    for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }

    if (funcs.length === 1) {
      return funcs[0];
    }

    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(undefined, arguments));
      };
    });
  }

  /**
   * Creates a store enhancer that applies middleware to the dispatch method
   * of the Redux store. This is handy for a variety of tasks, such as expressing
   * asynchronous actions in a concise manner, or logging every action payload.
   *
   * See `redux-thunk` package as an example of the Redux middleware.
   *
   * Because middleware is potentially asynchronous, this should be the first
   * store enhancer in the composition chain.
   *
   * Note that each middleware will be given the `dispatch` and `getState` functions
   * as named arguments.
   *
   * @param {...Function} middlewares The middleware chain to be applied.
   * @returns {Function} A store enhancer applying the middleware.
   */
  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    return function (createStore) {
      return function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var store = createStore.apply(undefined, args);
        var _dispatch = function dispatch() {
          throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
        };

        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch() {
            return _dispatch.apply(undefined, arguments);
          }
        };
        var chain = middlewares.map(function (middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose.apply(undefined, chain)(store.dispatch);

        return _extends$1({}, store, {
          dispatch: _dispatch
        });
      };
    };
  }

  /*
   * This is a dummy function to check if the function name has been altered by minification.
   * If the function has been minified and NODE_ENV !== 'production', warn the user.
   */
  function isCrushed() {}

  if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
    warning("You are currently using minified code outside of NODE_ENV === 'production'. " + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
  }

  function runeReducer () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments.length > 1 ? arguments[1] : undefined;
    return ({
      UPDATE_RUNE: function UPDATE_RUNE() {
        return _objectSpread({}, state, {
          all: _objectSpread({}, state.all)
        });
      },
      ADJUST_RUNE_VALUE: function ADJUST_RUNE_VALUE() {
        var rune = Object.assign({}, state.all[state.current]);
        rune[action.key] = Math.max(1, rune[action.key] + action.value);
        return _objectSpread({}, state, {
          all: _objectSpread({}, state.all, _defineProperty({}, rune._id, rune))
        });
      }
    }[action.type] || function () {
      return state;
    })();
  }

  function generateName(length) {
    var words = ['Blue', 'Red', 'Lotus', 'Sleeping', 'Burn', 'Steel', 'Gentle', 'Fire', 'Dark', 'Night', 'Heat', 'Blade', 'Mist', 'Desert', 'Burnt', 'Amber', 'Neon', 'Laser', 'Hope', 'Sword', 'Black', 'Light', 'Moon', 'Sun', 'Blue', 'Aching', 'Tired', 'Angry', 'Sad', 'Fierce', 'Glowing', 'Heart', 'Swift', 'Sleep', 'Hard', 'Water', 'River', 'Lake', 'Sea', 'Mountain', 'Cold', 'Warm', 'Love', 'Dagger', 'Rust', 'Rock', 'White', 'Cool', 'Crying', 'Fate', 'Whisper', 'Cutting', 'Stream', 'Winter', 'Summer', 'Autumn', 'Spring', 'Comfort', 'Tree', 'Bird', 'Tiger', 'Plain', 'Cave', 'Tear', 'Eye', 'Hand', 'Blood', 'Changing', 'Key', 'Lost', 'Buried', 'Sunken', 'Bright', 'Slow', 'Clear', 'Steam', 'Machine', 'Shine', 'Attack', 'Brute', 'Force', 'Glow', 'Eve', 'Charge', 'Last', 'First', 'Snake', 'Rush', 'Ember', 'Move', 'Woman', 'Man', 'Child', 'Rainbow', 'Earth', 'Space', 'Reality', 'Paradigm', 'Ghost', 'Happy', 'Hate', 'Fog', 'Leaf', 'Trunk', 'Fighting', 'Fight', 'Soft', 'Lily', 'Dull', 'Skull', 'Bone', 'Cloud', 'Drip', 'Crown', 'Axe', 'Hammer', 'Star', 'Halo', 'Bar', 'Truth', 'Lie', 'Wing', 'Wind', 'Soul', 'Storm', 'Lightning', 'Thunder', 'Bear', 'Frog', 'Island', 'Note', 'Letter', 'Coded', 'Rough', 'Perfect', 'Imperfect', 'Harmony', 'Distressed', 'Broken', 'Midight', 'City', 'Jewel', 'Ruby', 'Emerald', 'Diamond', 'Saphire', 'Sphinx', 'Fox', 'Flower', 'Sonic', 'Turbo', 'Century', 'Global', 'Human', 'Life', 'Fuzzy', 'Unique', 'Dream', 'Worship', 'Strength', 'Future', 'Five', 'Edge', 'Rider', 'Runner', 'Strong', 'Flame', 'Wolf', 'Stone', 'Dreadnaught', 'Conquer', 'Blaze', 'Inferno', 'Peace', 'Tundra', 'Silent', 'Chaos', 'Chaotic', 'Serene', 'Sublime', 'Still', 'Rising', 'Fall', 'Dove', 'Protection'];
    var name = [];

    for (var i = 0; i < length; i++) {
      var randomI = Math.floor(Math.random() * words.length - 1);
      name.push(words[randomI]);
    }

    return name.join(' ').replace(/ (.)/, function (l) {
      return l.toLowerCase();
    });
  }

  function RuneFactory(data) {
    return {
      _id: data && data._id || guid(),
      name: data && data.name || generateName(3),
      active: data && data.active || false,
      gridUnit: 40,
      gridRatio: 1,
      x: 7,
      y: 10
    };
  }

  function PathFactory(data) {
    return _objectSpread({
      _id: guid(),
      isClosed: false,
      isActive: false,
      fill: 'none',
      stroke: 'red',
      children: []
    }, data);
  }

  function PointFactory(data) {
    return _objectSpread({
      _id: guid()
    }, data);
  }

  var initialPathState = function () {
    return {
      all: [],
      current: null
    };
  }();

  function pathReducer () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialPathState;
    var action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case 'TOGGLE_PATH_CLOSED':
        var id = action.id || state.current;
        var newPaths = state.all.map(function (p) {
          if (p._id === id) {
            return _objectSpread({}, p, {
              isClosed: !p.isClosed
            });
          } else {
            return p;
          }
        });
        return _objectSpread({}, state, {
          all: newPaths
        });
        break;

      case 'TOGGLE_PATH_FILL':
        {
          var _newPaths = state.all.map(function (p) {
            if (p._id === state.current) {
              return _objectSpread({}, p, {
                fill: p.fill === 'none' && 'black' || 'none'
              });
            } else {
              return p;
            }
          });

          return _objectSpread({}, state, {
            all: _newPaths
          });
        }
        break;

      case 'ADD_PATH':
        // if ( state.points.all.some(p => p.path === state.current ) {
        // }
        var path = Path({
          rune: action.runeId
        });
        return _objectSpread({}, state, {
          current: path._id,
          selected: [],
          all: [].concat(_toConsumableArray(state.all), [path])
        });
        break;

      default:
        return state;
        break;
    }
  }

  var initialState = {
    all: [],
    selected: [],
    lastSelected: null
  };
  function pointReducer () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments.length > 1 ? arguments[1] : undefined;
    var points = state.all,
        selected = state.selected,
        lastSelected = state.lastSelected;

    switch (action.type) {
      case 'RESIZE_POINTS':
        {
          return _objectSpread({}, state, {
            all: points.map(function (p) {
              return _objectSpread({}, p, {
                x: p.x *= action.xRatio,
                y: p.y *= action.yRatio
              });
            })
          });
        }
        break;

      case 'NEXT_POINT':
        return _objectSpread({}, state, {
          selected: selected.length === 1 ? [Math.min(state.all.length - 1, selected[0] + 1)] : selected
        });
        break;

      case 'NUDGE_POINTS':
        {
          var newPoints = points.map(function (p, i) {
            if (selected.indexOf(i) > -1) {
              return _objectSpread({}, p, {
                x: Math.min(1, Math.max(0, p.x + action.vector[0])),
                y: Math.min(1, Math.max(0, p.y + action.vector[1]))
              });
            } else {
              return p;
            }
          });
          return _objectSpread({}, state, {
            all: newPoints
          });
        }
        break;

      case 'SELECT_ALL':
        return _objectSpread({}, state, {
          selected: state.all.map(function (p, i) {
            return i;
          })
        });
        break;

      case 'SELECT_POINT':
        {
          var _index = selected.indexOf(action.index);

          return _objectSpread({
            lastSelected: action.index
          }, state, _defineProperty({
            selected: _index > -1 && selected.length === 1 ? [] : [action.index]
          }, "lastSelected", _index === -1 ? action.index : null));
        }
        break;

      case 'ADD_SELECT_POINT':
        {
          // TODO: This is manipulating state
          var _index2 = selected.indexOf(action.index);

          if (_index2 > -1) {
            selected.splice(_index2, 1);
          } else {
            selected.push(action.index);
            lastSelected = action.index;
          }

          return _objectSpread({}, state, {
            selected: selected,
            lastSelected: lastSelected
          });
        }
        break;

      case 'DESELECT_ALL_POINTS':
        return _objectSpread({}, state, {
          selected: [],
          lastSelected: null
        });
        break;

      case 'DELETE_SELECTED_POINTS':
        return _objectSpread({}, state, {
          selected: [],
          all: points.filter(function (p, i) {
            return selected.indexOf(i) === -1;
          })
        });
        break;

      case 'DRAW_ARC':
        return _objectSpread({}, state, {
          all: points.map(function (p, i) {
            if (selected.indexOf(i) > -1) p.type = POINT_TYPES.ARC;
            return p;
          })
        });
        break;

      case 'UPDATE_POINT':
        console.log(action);
        return _objectSpread({}, state, {
          all: points.map(function (p, i) {
            if (p._id === action.id) {
              p.x = action.data.x;
              p.y = action.data.y;
            }

            return p;
          })
        });

      case 'ADD_POINT':
        var index = lastSelected || points.length;
        var point = PointFactory(action.point);
        return _objectSpread({}, state, {
          all: [].concat(_toConsumableArray(points), [point]),
          selected: [index]
        });
        break;

      default:
        return state;
        break;
    }
  }

  var app = function app() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments.length > 1 ? arguments[1] : undefined;
    return ({
      TOGGLE_MODE: function TOGGLE_MODE() {
        return _objectSpread({}, state, {
          mode: action.mode
        });
      },
      TOGGLE_PROOF_VIEW: function TOGGLE_PROOF_VIEW() {
        return _objectSpread({}, state, {
          proofView: !state.proofView
        });
      }
    }[action.type] || function () {
      return state;
    })();
  };

  var rootReducer = combineReducers({
    app: app,
    runes: runeReducer,
    points: pointReducer,
    paths: pathReducer
  });

  var pointResize = (function (store) {
    return function (next) {
      return function (action) {
        next(action);

        if (action.type === 'ADJUST_TABLET_VALUE') {// let state = store.getState();
          // let oldTablet = state.tablet.all[state.tablet.current];
          // let newTablet = { ...oldTablet, [action.key] : oldTablet[action.key] + action.value };
          // let xRatio = ( newTablet.gridUnit * newTablet.x ) / ( oldTablet.gridUnit * oldTablet.x );
          // let yRatio = ( newTablet.gridUnit * newTablet.y ) / ( oldTablet.gridUnit * oldTablet.y );
          // console.log(xRatio, yRatio);
          // store.dispatch({ type: 'RESIZE_POINTS', xRatio, yRatio});
        }
      };
    };
  });

  var instructionParser = (function (store) {
    return function (next) {
      return function (action) {
        if (action.type === 'SEND_INSTRUCTIONS') {
          var instructions = action.instructions; // let state = store.getState();
          // let oldTablet = state.tablet.all[state.tablet.current];
          // let newTablet = { ...oldTablet, [action.key] : oldTablet[action.key] + action.value };
          // let xRatio = ( newTablet.gridUnit * newTablet.x ) / ( oldTablet.gridUnit * oldTablet.x );
          // let yRatio = ( newTablet.gridUnit * newTablet.y ) / ( oldTablet.gridUnit * oldTablet.y );
          // console.log(xRatio, yRatio);
          // store.dispatch({ type: 'RESIZE_POINTS', xRatio, yRatio});

          return;
        }

        next(action);
      };
    };
  });

  var initialAppState = {
    proofView: false,
    mode: MODE.DOCUMENT,
    snap: true
  };
  var rune = RuneFactory();
  var path = PathFactory({
    rune: rune._id
  });
  var initialState$1 = {
    runes: {
      all: _defineProperty({}, rune._id, rune),
      current: rune._id
    },
    paths: {
      all: [path],
      current: path._id
    },
    app: initialAppState
  };
  /* Remember: store is pure data */

  var store = createStore(rootReducer, initialState$1, applyMiddleware(pointResize, instructionParser));
  console.log('Initial store', store.getState());

  var Data = {
    getRunes: function getRunes(state) {
      return this.getAll('runes', state);
    },
    getAll: function getAll(key) {
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : store.getState();
      return Object.values(state[key].all);
    },
    getRune: function getRune(state) {
      return this.getCurrent('runes', state);
    },
    getPath: function getPath(state) {
      return this.getCurrent('paths', state);
    },
    getCurrent: function getCurrent(model) {
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : store.getState();
      return state[model].all[state[model].current];
    }
  };

  var WorkspaceUtil = {
    get isDrawingMode() {
      return store.getState().app.mode === MODE.DRAW;
    },

    get isArcMode() {
      return store.getState().app.node === MODE.ARC;
    },

    get isDocumentMode() {
      return store.getState().app.node === MODE.DOCUMENT;
    }

  };
  var Position = {
    get runeSize() {
      return {
        width: this.runeWidth,
        height: this.runeHeight
      };
    },

    getRune: function getRune() {
      var state = store.getState();
      return state.runes.all[state.runes.current];
    },

    get runeWidth() {
      var rune = this.getRune();
      return rune.gridUnit * rune.x;
    },

    get runeHeight() {
      var rune = this.getRune();
      return rune.gridUnit * rune.y;
    },

    getAbsolute: function getAbsolute(coord) {
      return {
        x: coord.x * this.runeWidth,
        y: coord.y * this.runeHeight
      };
    }
  };

  var Arc =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Arc, _Component);

    function Arc(props) {
      var _this;

      _classCallCheck(this, Arc);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Arc).call(this, props));
      _this.state = {
        radius: 100,
        length: Math.PI / 4,
        startPoint: {
          x: 0.5,
          y: 0.5
        },
        endPoint: {
          x: 1,
          y: 1
        },
        center: {
          x: 0.75,
          y: 0.75
        }
      };
      return _this;
    }

    _createClass(Arc, [{
      key: "_onMouseDown",
      value: function _onMouseDown(e) {
        console.log('Mouse down', e);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$state$center = this.state.center,
            x = _this$state$center.x,
            y = _this$state$center.y;
        var radius = this.state.radius; // const { x: mX = 0, y: mY = 0 } = this.props.mousePosition;

        var startPoint = Position.getAbsolute(this.state.startPoint);
        var endPoint = Position.getAbsolute(this.state.endPoint);
        var drawString = "M ".concat(startPoint.x, " ").concat(startPoint.y, " a ").concat(radius, " ").concat(radius, " 0 0 0 ").concat(radius, " ").concat(radius);
        return React__default.createElement(Group, null, React__default.createElement(Point, _extends({
          x: 0.5,
          y: 0.5
        }, {
          onMouseDown: function onMouseDown(e) {
            return _this2._onMouseDown(e);
          }
        })), React__default.createElement("path", {
          fill: "none",
          stroke: "red",
          d: drawString,
          pointerEvents: "none"
        }));
      }
    }]);

    return Arc;
  }(React.Component);

  var Switch =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Switch, _Component);

    function Switch(props) {
      var _this;

      _classCallCheck(this, Switch);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Switch).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_toggle", function () {
        if (_this.props.onToggle) {
          _this.props.onToggle();
        }

        _this.setState({
          toggle: !_this.state.toggle
        });
      });

      _this.state = {
        toggle: props.toggle || false
      };
      return _this;
    }

    _createClass(Switch, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(newProps) {
        this.setState({
          toggle: newProps.toggle
        });
      }
    }, {
      key: "render",
      value: function render() {
        var classes = "switch ".concat(this.state.toggle ? 'on' : 'off');
        return React__default.createElement("div", {
          className: classes,
          onClick: this._toggle
        }, this.props.children || this.props.symbol);
      }
    }]);

    return Switch;
  }(React.Component);

  function GridLines(props) {
    var _props$rune = props.rune,
        gridUnit = _props$rune.gridUnit,
        tX = _props$rune.x,
        tY = _props$rune.y,
        height = props.height,
        width = props.width;
    var lines = [];

    for (var i = 0; i <= Math.max(tX, tY); i++) {
      for (var j = 0; j < 5; j++) {
        if (i < tX) lines.push(React__default.createElement(Vline, {
          key: lines.length,
          x: i * gridUnit + j * gridUnit / 5,
          opacity: 0.2,
          color: COLORS.BLUE,
          length: height
        }));
        if (i < tY) lines.push(React__default.createElement(Hline, {
          key: lines.length,
          y: i * gridUnit + j * gridUnit / 5,
          opacity: 0.2,
          color: COLORS.BLUE,
          length: width
        }));
      }

      if (i <= tY) lines.push(React__default.createElement(Hline, {
        key: lines.length,
        y: i * gridUnit,
        color: COLORS.BLUE,
        length: width
      }));
      if (i <= tX) lines.push(React__default.createElement(Vline, {
        key: lines.length,
        x: i * gridUnit,
        color: COLORS.BLUE,
        length: height
      }));
    }

    lines.push(React__default.createElement(Hline, {
      key: lines.length,
      y: height / 2,
      color: COLORS.RED,
      length: width
    }), React__default.createElement(Vline, {
      key: lines.length + 1,
      x: width / 2,
      color: COLORS.RED,
      length: height
    }));
    return React__default.createElement(Group, null, lines);
  }
  function GridNodes(props) {
    var handlers = props.handlers,
        rune = props.rune,
        currentPath = props.currentPath;
    var tX = rune.x,
        tY = rune.y,
        gridUnit = rune.gridUnit;
    var nodes = [];

    for (var x = 0; x <= tX; x++) {
      var _loop = function _loop(y) {
        var point = {
          x: x / tX,
          y: y / tY,
          path: props.currentPath,
          rune: props.rune,
          type: WorkspaceUtil.isArcMode ? POINT_TYPES.ARC : POINT_TYPES.STRAIGHT
        };
        var k = x * (tY + 1) + y;
        nodes.push(React__default.createElement(GridNode, {
          grid: [x, y],
          key: k,
          addPoint: function addPoint$$1(e) {
            return props.addPoint(e, point);
          },
          location: [gridUnit * x + 2 - gridUnit / 2, gridUnit * y + 2 - gridUnit / 2],
          size: gridUnit - 4
        }));
      };

      for (var y = 0; y <= tY; y++) {
        _loop(y);
      }
    }

    return React__default.createElement(Group, null, nodes);
  }

  function GridNode(props) {
    var location = props.location,
        addPoint$$1 = props.addPoint,
        size = props.size;
    return React__default.createElement("rect", {
      className: "grid-node",
      x: location[0],
      y: location[1],
      width: size,
      height: size,
      fill: COLORS.BLUE,
      onClick: addPoint$$1,
      fillOpacity: 0.2
    });
  }

  function mapStateToProps(state, ownProps) {
    return _objectSpread({}, ownProps);
  }

  reactRedux.connect(mapStateToProps, actionCreators)(GridNodes);

  var _pointStrings;
  var pointStrings = (_pointStrings = {}, _defineProperty(_pointStrings, POINT_TYPES.STRAIGHT, function (mX, mY) {
    return "L ".concat(mX, " ").concat(mY);
  }), _defineProperty(_pointStrings, POINT_TYPES.ARC, function (mX, mY) {
    return "A 50 50 0 0 1 ".concat(mX, " ").concat(mY);
  }), _pointStrings);

  function Helpers(props) {
    var markerPosition = props.markerPosition,
        point = props.point,
        width = props.width,
        height = props.height,
        gridUnit = props.rune.gridUnit;
    var mX = markerPosition && markerPosition.x || 0;
    var mY = markerPosition && markerPosition.y || 0; // mX = (Math.round(mX * width / gridUnit) * gridUnit );
    // mY = (Math.round(mY * height / gridUnit) * gridUnit );

    mX = Math.round(mX / gridUnit) * gridUnit;
    mY = Math.round(mY / gridUnit) * gridUnit;
    var pX = point.x * width;
    var pY = point.y * height;
    var str = '';

    if (props.markerPosition) {
      if (WorkspaceUtil.isDrawingMode) {
        str = "M ".concat(pX, " ").concat(pY, " ").concat(pointStrings[point.type](mX, mY));
      } else if (WorkspaceUtil.isArcMode) {
        str = "M ".concat(pX, " ").concat(pY, " a ", 100, " ", 100, " ").concat(pointStrings[point.type](mX, mY));
      }
    }

    var stroke = 'red';
    return React__default.createElement("svg", null, React__default.createElement("path", {
      strokeWidth: 1,
      stroke: stroke,
      fill: "none",
      pointerEvents: "none",
      d: str
    }));
  } // UI


  var Overlay =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Overlay, _Component);

    function Overlay(props) {
      var _this;

      _classCallCheck(this, Overlay);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Overlay).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onMouseMove", function (e, data) {
        var unitSize = _this.props.rune.unitSize;
        var _e$nativeEvent = e.nativeEvent,
            x = _e$nativeEvent.offsetX,
            y = _e$nativeEvent.offsetY;
        var _Position$runeSize = Position.runeSize,
            width = _Position$runeSize.width,
            height = _Position$runeSize.height;
        x = Math.abs(Math.round(x / 10) * 10);
        y = Math.abs(Math.round(y / 10) * 10);

        _this.setState({
          markerPosition: {
            x: x,
            y: y,
            nX: x / width,
            nY: y / height
          }
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onMouseLeave", function (e) {
        _this.setState({
          markerPosition: null
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_clickHandler", function (e) {
        console.log(_this.props);
        var currentPath = _this.props.currentPath;
        var _Position$runeSize2 = Position.runeSize,
            width = _Position$runeSize2.width,
            height = _Position$runeSize2.height;
        console.log(currentPath);

        _this.props.addPoint({
          x: _this.state.markerPosition.x / width,
          y: _this.state.markerPosition.y / height,
          pathId: currentPath._id,
          selected: true
        });
      });

      _this.state = {
        markerPosition: {
          x: 0,
          y: 0
        }
      };
      return _this;
    }

    _createClass(Overlay, [{
      key: "render",
      value: function render() {
        var props = this.props;
        var height = props.height,
            width = props.width,
            points = props.points,
            selectedPoints = props.selectedPoints,
            mode = props.mode;
        var markerPosition = this.state.markerPosition;
        var x, y;

        if (markerPosition) {
          x = markerPosition.x;
          y = markerPosition.y;
        }

        return React__default.createElement("svg", {
          id: "overlay",
          height: height,
          width: width,
          onMouseMove: this._onMouseMove,
          onMouseLeave: this._onMouseLeave,
          onClick: this._clickHandler
        }, markerPosition && React__default.createElement("rect", {
          x: x - 5,
          y: y - 5,
          width: 10,
          height: 10,
          fill: "none",
          stroke: "red"
        }), points.map(function (p, i) {
          return React__default.createElement(Point, _extends({
            index: i,
            selected: selectedPoints.indexOf(i) > -1,
            onClick: function onClick(e) {
              return props.selectPoint(e, i);
            },
            key: i
          }, p));
        }), selectedPoints.length && React__default.createElement(Helpers, _extends({}, props, {
          mode: mode,
          markerPosition: this.state.markerPosition,
          point: points[selectedPoints[0]] || {
            x: 0,
            y: 0
          }
        })));
      }
    }]);

    return Overlay;
  }(React.Component);

  function mapStateToProps$1(state, ownProps) {
    var points = state.points.all.filter(function (p) {
      return p.rune === ownProps.id;
    });
    var hist = {};
    points.forEach(function (p) {
      p.path in hist ? hist[p.path].push(p) : hist[p.path] = [p];
    });
    var paths = [];

    for (var path in hist) {
      paths.push(hist[path]);
    }

    var currentPath = Data.getCurrent('paths');
    return _objectSpread({}, ownProps, {
      mode: state.app.mode,
      pathPoints: paths,
      paths: state.paths.all,
      points: points,
      currentPath: currentPath,
      selectedPoints: state.points.selected
    });
  }

  var Overlay$1 = reactRedux.connect(mapStateToProps$1, actionCreators)(Overlay);

  var _POINT_TYPE_STRING;
  var POINT_TYPE_STRING = (_POINT_TYPE_STRING = {}, _defineProperty(_POINT_TYPE_STRING, POINT_TYPES.STRAIGHT, function (mX, mY) {
    return "L ".concat(mX, " ").concat(mY);
  }), _defineProperty(_POINT_TYPE_STRING, POINT_TYPES.ARC, function (mX, mY) {
    return "A 50 50 0 0 1 ".concat(mX, " ").concat(mY);
  }), _POINT_TYPE_STRING);

  function BGLayer(props) {
    var height = props.height,
        width = props.width;
    return React__default.createElement("svg", {
      id: "background",
      height: height,
      width: width
    }, React__default.createElement(GridLines, props));
  }

  function RenderLayer(props) {
    var height = props.height,
        width = props.width,
        paths = props.paths,
        pathPoints = props.pathPoints;
    var stroke;

    function _mouseEnter() {
      console.log('Path hover');
      stroke = 3;
    }

    return React__default.createElement("svg", {
      id: "render",
      height: height,
      width: width
    }, paths.map(function (path, i) {
      var str = path.points.map(function (p, i) {
        return "".concat(i ? 'L' : 'M', " ").concat(p.x * width, " ").concat(p.y * height).concat(path.isClosed ? ' Z' : '');
      });
      return React__default.createElement("path", {
        key: i,
        d: str,
        stroke: stroke || path.stroke,
        strokeWidth: stroke || 1,
        fill: path.fill,
        onMouseEnter: _mouseEnter
      });
    }));
  }

  function Rune(props) {
    var points = props.points,
        rune = props.rune,
        pathPoints = props.pathPoints,
        paths = props.paths,
        selectedPoints = props.selectedPoints,
        proofView = props.proofView,
        currentPath = props.currentPath,
        mode = props.mode;
    var height = rune.y * rune.gridUnit;
    var width = rune.x * rune.gridUnit;
    var size = {
      width: width,
      height: height
    };
    return React__default.createElement("div", {
      className: "rune",
      style: {
        width: width,
        height: height,
        padding: "".concat(height / rune.y / 2, "px ").concat(width / rune.x / 2, "px")
      }
    }, React__default.createElement("p", {
      className: "rune-label"
    }, rune.name, ' ', React__default.createElement("span", {
      className: "rune-size"
    }, "(", rune.x, "x", rune.y, ")")), !proofView && React__default.createElement(BGLayer, _extends({}, size, {
      rune: rune
    })), React__default.createElement(RenderLayer, _extends({}, size, {
      paths: paths
    })), !proofView && React__default.createElement(Overlay$1, _extends({}, size, {
      rune: rune,
      currentPath: currentPath
    })));
  }

  function mapStateToProps$2(state, ownProps) {
    // const points = state.point.all.filter(p => p.rune === ownProps.rune._id);
    // const hist = {};
    // points.forEach(p => {
    // p.path in hist ? hist[p.path].push(p) : (hist[p.path] = [p]);
    // });
    // const paths = [];
    // for (let path in hist) paths.push(hist[path]);
    var paths = Data.getAll('paths').filter(function (p) {
      return p.rune === ownProps.rune._id;
    });
    paths.forEach(function (path) {
      path.points = state.points.all.filter(function (p) {
        return p.path === path._id;
      });
    });
    return _objectSpread({}, ownProps, {
      mode: state.app.mode,
      paths: paths,
      currentPath: state.paths.current,
      selectedPoints: state.points.selected,
      proofView: state.app.proofView
    });
  }

  var Rune$1 = reactRedux.connect(mapStateToProps$2, actionCreators)(Rune);

  var StackIcon = (function () {
    return React__default.createElement("svg", {
      viewBox: "0,0,200,200",
      width: "200",
      height: "200",
      xmlns: "http://www.w3.org/2000/svg"
    }, React__default.createElement("g", {
      strokeMiterlimit: "10"
    }, React__default.createElement("path", {
      d: "M0 40h200V0H0zM0 120h200V80H0zM0 200h200v-40H0z"
    })));
  });

  var PanelContainer =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(PanelContainer, _React$Component);

    function PanelContainer(props) {
      var _this;

      _classCallCheck(this, PanelContainer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PanelContainer).call(this, props));
      _this.state = {
        collapsed: false
      };
      return _this;
    }

    _createClass(PanelContainer, [{
      key: "_toggleCollapsed",
      value: function _toggleCollapsed() {
        this.setState({
          collapsed: !this.state.collapsed
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            title = _this$props.title,
            children = _this$props.children;
        var className = this.state.collapsed ? 'collapsed' : '';
        return React__default.createElement("div", {
          className: "panel"
        }, React__default.createElement("div", {
          className: "handle",
          onClick: function onClick() {
            return _this2._toggleCollapsed();
          }
        }, title, React__default.createElement(Switch, {
          onToggle: function onToggle() {
            return _this2._toggleCollapsed();
          },
          toggle: this.state.collapsed
        }, React__default.createElement(StackIcon, null))), !this.state.collapsed ? React__default.createElement("div", {
          className: "panel-content"
        }, children) : null);
      }
    }]);

    return PanelContainer;
  }(React__default.Component);

  var Path$1 =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Path, _Component);

    function Path(props) {
      var _this;

      _classCallCheck(this, Path);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleKeyPress", function (e) {
        console.log(e.keyCode);

        if (e.keyCode) {}
      });

      var path = props.path;

      _this.props.addPoint({
        x: 0,
        y: 0,
        path: path._id,
        type: POINT_TYPES.STRAIGHT
      });

      _this.state = {};
      return _this;
    }

    _createClass(Path, [{
      key: "render",
      value: function render() {
        return React__default.createElement("div", {
          className: "editable path",
          onKeyPress: this._handleKeyPress,
          contentEditable: true
        }, "P");
      }
    }]);

    return Path;
  }(React.Component);

  var Point$1 =
  /*#__PURE__*/
  function (_Component2) {
    _inherits(Point, _Component2);

    function Point() {
      var _getPrototypeOf2;

      var _this2;

      _classCallCheck(this, Point);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Point)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "state", {});

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_handleKeyPress", function (e) {
        var _this2$props = _this2.props,
            path = _this2$props.path,
            point = _this2$props.point;

        if (e.nativeEvent.keyCode === 13) {
          _this2.props.addPoint({
            x: 0,
            y: 0,
            path: path._id,
            type: POINT_TYPES.STRAIGHT
          }); // var evt = new KeyboardEvent('keydown', {'keyCode':65gt, 'which':65};
          // document.dispatchEvent (evt);


          e.preventDefault();
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_handleInput", function (e) {
        var val = e.target.innerHTML;
        var xy = val.split(',');

        _this2.props.updatePoint(_this2.props.point._id, {
          x: xy[0],
          y: xy[1]
        });
      });

      return _this2;
    }

    _createClass(Point, [{
      key: "render",
      value: function render() {
        var _this$props$point = this.props.point,
            x = _this$props$point.x,
            y = _this$props$point.y;
        return React__default.createElement("div", {
          className: "editable point",
          onKeyPress: this._handleKeyPress,
          onInput: this._handleInput,
          suppressContentEditableWarning: true,
          contentEditable: true
        }, x, ",", y);
      }
    }]);

    return Point;
  }(React.Component);

  var PathConnected = reactRedux.connect(null, actionCreators)(Path$1);
  var PointConnected = reactRedux.connect(null, actionCreators)(Point$1);

  var PathEditor =
  /*#__PURE__*/
  function (_Component3) {
    _inherits(PathEditor, _Component3);

    function PathEditor(props) {
      var _this3;

      _classCallCheck(this, PathEditor);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PathEditor).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), "_onUpdate", function (e) {// this.props.sendInstructions(e.target.value);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), "_handleKeyPress", function (e) {
        if (e.nativeEvent.keyCode === 13) {// this.pointRefs[
        }
      });

      _this3.pointRefs = props.points.map(function (p) {
        return React__default.createRef();
      });
      _this3.state = {};
      return _this3;
    }

    _createClass(PathEditor, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(newProps) {
        this.pointRefs = newProps.points.map(function (p) {
          return React__default.createRef();
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        var _this$props = this.props,
            paths = _this$props.paths,
            points = _this$props.points;
        console.log(this.props);
        return React__default.createElement("div", {
          className: "paths"
        }, paths.map(function (p) {
          return [React__default.createElement(PathConnected, {
            path: p,
            key: p._id
          })].concat(_toConsumableArray(points.filter(function (point) {
            return point.path === p._id;
          }).map(function (point, i) {
            return React__default.createElement(PointConnected, {
              ref: _this4.pointRefs[i],
              point: point,
              path: p
            });
          })));
        }));
      }
    }]);

    return PathEditor;
  }(React.Component);

  function mapStateToProps$3(state, ownProps) {
    return {
      paths: state.paths.all,
      points: state.points.all
    };
  }

  var InstructionsPanel = reactRedux.connect(mapStateToProps$3, actionCreators)(PathEditor);

  var panels = [// Tablet: TabletPanel,
  // Path: PathPanel,
  {
    title: 'Instructions',
    panel: InstructionsPanel
  }];

  var Workspace = function Workspace(props) {
    return React__default.createElement("div", {
      id: "rune-workspace"
    }, React__default.createElement("div", {
      id: "rune-status"
    }, React__default.createElement("span", {
      className: "tag"
    }, MODE_TAG[props.app.mode], " mode")), ": ", React__default.createElement("div", {
      id: "rune-tools"
    }), React__default.createElement("div", {
      id: "runes",
      onClick: props.deselectAllPoints
    }, props.runes.map(function (r, i) {
      return React__default.createElement(Rune$1, {
        rune: r,
        key: i
      });
    })), React__default.createElement("div", {
      id: "rune-panels"
    }, panels.map(function (panel, i) {
      return React__default.createElement(PanelContainer, {
        title: panel.title,
        key: i
      }, React__default.createElement(panel.panel, null));
    })));
  };

  function mapStateToProps$4(state) {
    var runes = Data.getRunes(state);
    var app = state.app;
    return {
      runes: runes,
      app: app
    };
  } // <div id="rune-panels">
  //     {Object.keys(panels).map((k, i) => {
  //         let Panel = panels[k];
  //         return (
  //             <PanelContainer title={k} key={i}>
  //                 <Panel />
  //             </PanelContainer>
  //         );
  //     })}
  // </div>


  var App = reactRedux.connect(mapStateToProps$4, actionCreators)(Workspace);

  var _modeActions;
  var MODIFIERS = ['shiftKey', 'ctrlKey', 'metaKey'];
  var protectedElements = ['INPUT', 'TEXTAREA'];
  var keyCodes = {
    8: 'delete',
    13: 'enter',
    27: 'esc',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    65: 'a',
    66: 'b',
    67: 'c',
    68: 'd',
    69: 'e',
    70: 'f',
    71: 'h',
    75: 'k',
    76: 'l',
    77: 'm',
    78: 'n',
    79: 'o',
    80: 'p',
    86: 'v',
    187: '+',
    189: '-',
    219: '[',
    221: ']'
  };
  var nudgeVectors = {
    up: [0, -0.1],
    down: [0, 0.1],
    left: [-0.1, 0],
    right: [0.1, 0],
    'shiftKey+up': [0, -1],
    'shiftKey+down': [0, 1],
    'shiftKey+left': [-1, 0],
    'shiftKey+right': [1, 0]
  };
  var keys = {};
  var nudgeActions = {};
  Object.keys(nudgeVectors).forEach(function (k) {
    nudgeActions[k] = function () {
      var state = store.getState();
      var rune = state.runes.all[state.runes.current];
      var x = rune.x,
          y = rune.y;
      var v = nudgeVectors[k];
      return {
        type: 'NUDGE_POINTS',
        vector: [v[0] * (1 / x), v[1] * (1 / y)]
      };
    };
  });
  var globalActions = {
    v: toggleProofView,
    h: toggleHelp,
    esc: setDocumentMode
  };
  var modeActions = (_modeActions = {}, _defineProperty(_modeActions, MODE.DRAW, _objectSpread({
    a: drawArc,
    p: addPath
  }, nudgeActions)), _defineProperty(_modeActions, MODE.DOCUMENT, _objectSpread({
    d: setDrawMode,
    delete: deleteSelectedPoints,
    c: togglePathClosed,
    n: nextPoint,
    f: togglePathFill,
    right: increaseX,
    left: decreaseX,
    'ctrlKey+a': selectAll,
    down: increaseY,
    up: decreaseY,
    'ctrlKey++': increaseGridUnit,
    'ctrlKey+-': decreaseGridUnit
  }, keys)), _defineProperty(_modeActions, MODE.ARC, {// f: actions.flipArc,
    // c: actions.toggleCenterLock,
  }), _modeActions);
  document.addEventListener('keydown', function (e) {
    if (e.target.classList.contains('editable')) return;
    console.log('Key code', e.keyCode);
    var mode = store.getState().app.mode;

    if (!e.metaKey) {// e.preventDefault();
    }

    var hasModifier = MODIFIERS.filter(function (m) {
      return e[m];
    }).join('+');
    var ref = "".concat(hasModifier && hasModifier + '+').concat(keyCodes[e.keyCode] || e.keyCode);

    if (!protectedElements.includes(e.target.tagName)) {
      var action;

      if (globalActions[ref]) {
        action = globalActions[ref]();
      } else if (modeActions[mode][ref]) {
        action = modeActions[mode][ref]();
      }

      if (action) {
        e.preventDefault();
        store.dispatch(action);
      }
    }
  });

  var render = function render() {
    ReactDOM.render(React__default.createElement(reactRedux.Provider, {
      store: store
    }, React__default.createElement(App, null)), document.getElementById('app'));
  };

  render();
  store.subscribe(render);

}(RuneModules.React,RuneModules.ReactRedux,RuneModules.ReactDOM));
