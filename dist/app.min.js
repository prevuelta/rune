(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/draggable');

},{"./lib/draggable":2}],2:[function(require,module,exports){
'use strict';

var React = require('react');
var emptyFunction = function(){};
var assign = require('object-assign');
var classNames = require('classnames');

//
// Helpers. See Element definition below this section.
//

function createUIEvent(draggable) {
  // State changes are often (but not always!) async. We want the latest value.
  var state = draggable._pendingState || draggable.state;
  return {
    node: draggable.getDOMNode(),
    position: {
      top: state.clientY,
      left: state.clientX
    }
  };
}

function canDragY(draggable) {
  return draggable.props.axis === 'both' ||
      draggable.props.axis === 'y';
}

function canDragX(draggable) {
  return draggable.props.axis === 'both' ||
      draggable.props.axis === 'x';
}

function isFunction(func) {
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array, callback) {
  for (var i = 0, length = array.length; i < length; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}

function matchesSelector(el, selector) {
  var method = findInArray([
    'matches',
    'webkitMatchesSelector',
    'mozMatchesSelector',
    'msMatchesSelector',
    'oMatchesSelector'
  ], function(method){
    return isFunction(el[method]);
  });

  return el[method].call(el, selector);
}

/**
 * simple abstraction for dragging events names
 * */
var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    end: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    end: 'mouseup'
  }
};

// Default to mouse events
var dragEventFor = eventsFor['mouse'];

/**
 * get {clientX, clientY} positions of control
 * */
function getControlPosition(e) {
  var position = (e.touches && e.touches[0]) || e;
  return {
    clientX: position.clientX,
    clientY: position.clientY
  };
}

function addEvent(el, event, handler) {
  if (!el) { return; }
  if (el.attachEvent) {
    el.attachEvent('on' + event, handler);
  } else if (el.addEventListener) {
    el.addEventListener(event, handler, true);
  } else {
    el['on' + event] = handler;
  }
}

function removeEvent(el, event, handler) {
  if (!el) { return; }
  if (el.detachEvent) {
    el.detachEvent('on' + event, handler);
  } else if (el.removeEventListener) {
    el.removeEventListener(event, handler, true);
  } else {
    el['on' + event] = null;
  }
}

function outerHeight(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height += int(computedStyle.borderTopWidth);
  height += int(computedStyle.borderBottomWidth);
  return height;
}

function outerWidth(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width += int(computedStyle.borderLeftWidth);
  width += int(computedStyle.borderRightWidth);
  return width;
}
function innerHeight(node) {
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height -= int(computedStyle.paddingTop);
  height -= int(computedStyle.paddingBottom);
  return height;
}

function innerWidth(node) {
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width -= int(computedStyle.paddingLeft);
  width -= int(computedStyle.paddingRight);
  return width;
}

function isNum(num) {
  return typeof num === 'number' && !isNaN(num);
}

function int(a) {
  return parseInt(a, 10);
}

function getBoundPosition(draggable, clientX, clientY) {
  var bounds = JSON.parse(JSON.stringify(draggable.props.bounds));
  var node = draggable.getDOMNode();
  var parent = node.parentNode;

  if (bounds === 'parent') {
    var nodeStyle = window.getComputedStyle(node);
    var parentStyle = window.getComputedStyle(parent);
    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
    bounds = {
      left: -node.offsetLeft + int(parentStyle.paddingLeft) +
            int(nodeStyle.borderLeftWidth) + int(nodeStyle.marginLeft),
      top: -node.offsetTop + int(parentStyle.paddingTop) +
            int(nodeStyle.borderTopWidth) + int(nodeStyle.marginTop),
      right: innerWidth(parent) - outerWidth(node) - node.offsetLeft,
      bottom: innerHeight(parent) - outerHeight(node) - node.offsetTop
    };
  }

  // Keep x and y below right and bottom limits...
  if (isNum(bounds.right)) clientX = Math.min(clientX, bounds.right);
  if (isNum(bounds.bottom)) clientY = Math.min(clientY, bounds.bottom);

  // But above left and top limits.
  if (isNum(bounds.left)) clientX = Math.max(clientX, bounds.left);
  if (isNum(bounds.top)) clientY = Math.max(clientY, bounds.top);

  return [clientX, clientY];
}

function snapToGrid(grid, pendingX, pendingY) {
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}

// Useful for preventing blue highlights all over everything when dragging.
var userSelectStyle = ';user-select: none;-webkit-user-select:none;-moz-user-select:none;' +
  '-o-user-select:none;-ms-user-select:none;';

function addUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style + userSelectStyle);
}

function removeUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style.replace(userSelectStyle, ''));
}

function createCSSTransform(style) {
  // Replace unitless items with px
  var x = style.x + 'px';
  var y = style.y + 'px';
  return {
    transform: 'translate(' + x + ',' + y + ')',
    WebkitTransform: 'translate(' + x + ',' + y + ')',
    OTransform: 'translate(' + x + ',' + y + ')',
    msTransform: 'translate(' + x + ',' + y + ')',
    MozTransform: 'translate(' + x + ',' + y + ')'
  };
}


//
// End Helpers.
//

//
// Define <Draggable>
//

module.exports = React.createClass({
  displayName: 'Draggable',

  propTypes: {
    /**
     * `axis` determines which axis the draggable can move.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     *
     * Defaults to 'both'.
     */
    axis: React.PropTypes.oneOf(['both', 'x', 'y']),

    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: React.PropTypes.oneOfType([
      React.PropTypes.shape({
        left: React.PropTypes.Number,
        right: React.PropTypes.Number,
        top: React.PropTypes.Number,
        bottom: React.PropTypes.Number
      }),
      React.PropTypes.oneOf(['parent', false])
    ]),

    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: React.PropTypes.bool,

    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: React.PropTypes.string,

    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *            <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: React.PropTypes.string,

    /**
     * `grid` specifies the x and y that dragging should snap to.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable grid={[25, 25]}>
     *                   <div>I snap to a 25 x 25 grid</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    grid: React.PropTypes.arrayOf(React.PropTypes.number),

    /**
     * `start` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      var App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable start={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    start: React.PropTypes.shape({
      x: React.PropTypes.number,
      y: React.PropTypes.number
    }),

    /**
     * `moveOnStartChange`, if true (default false) will move the element if the `start`
     * property changes.
     */
    moveOnStartChange: React.PropTypes.bool,


    /**
     * `zIndex` specifies the zIndex to use while dragging.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable zIndex={100}>
     *                   <div>I have a zIndex</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    zIndex: React.PropTypes.number,

    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStart: React.PropTypes.func,

    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onDrag: React.PropTypes.func,

    /**
     * Called when dragging stops.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStop: React.PropTypes.func,

    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (due to that there's internal use of onMouseDown)
     */
    onMouseDown: React.PropTypes.func,
  },

  componentWillReceiveProps: function(newProps) {
    // React to changes in the 'start' param.
    if (newProps.moveOnStartChange && newProps.start) {
      this.setState(this.getInitialState(newProps));
    }
  },

  componentWillUnmount: function() {
    // Remove any leftover event handlers
    removeEvent(document, dragEventFor['move'], this.handleDrag);
    removeEvent(document, dragEventFor['end'], this.handleDragEnd);
    removeUserSelectStyles(this);
  },

  getDefaultProps: function () {
    return {
      axis: 'both',
      bounds: false,
      handle: null,
      cancel: null,
      grid: null,
      moveOnStartChange: false,
      start: {x: 0, y: 0},
      zIndex: NaN,
      enableUserSelectHack: true,
      onStart: emptyFunction,
      onDrag: emptyFunction,
      onStop: emptyFunction,
      onMouseDown: emptyFunction
    };
  },

  getInitialState: function (props) {
    // Handle call from CWRP
    props = props || this.props;
    return {
      // Whether or not we are currently dragging.
      dragging: false,

      // Offset between start top/left and mouse top/left while dragging.
      offsetX: 0, offsetY: 0,

      // Current transform x and y.
      clientX: props.start.x, clientY: props.start.y
    };
  },

  handleDragStart: function (e) {
    // Make it possible to attach event handlers on top of this one
    this.props.onMouseDown(e);

    // Short circuit if handle or cancel prop was provided and selector doesn't match
    if ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||
      (this.props.cancel && matchesSelector(e.target, this.props.cancel))) {
      return;
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldStart = this.props.onStart(e, createUIEvent(this));
    if (shouldStart === false) return;

    var dragPoint = getControlPosition(e);

    // Add a style to the body to disable user-select. This prevents text from
    // being selected all over the page.
    addUserSelectStyles(this);

    // Initiate dragging. Set the current x and y as offsets
    // so we know how much we've moved during the drag. This allows us
    // to drag elements around even if they have been moved, without issue.
    this.setState({
      dragging: true,
      offsetX: dragPoint.clientX - this.state.clientX,
      offsetY: dragPoint.clientY - this.state.clientY
    });


    // Add event handlers
    addEvent(document, dragEventFor['move'], this.handleDrag);
    addEvent(document, dragEventFor['end'], this.handleDragEnd);
  },

  handleDragEnd: function (e) {
    // Short circuit if not currently dragging
    if (!this.state.dragging) {
      return;
    }

    removeUserSelectStyles(this);

    // Turn off dragging
    this.setState({
      dragging: false
    });

    // Call event handler
    this.props.onStop(e, createUIEvent(this));

    // Remove event handlers
    removeEvent(document, dragEventFor['move'], this.handleDrag);
    removeEvent(document, dragEventFor['end'], this.handleDragEnd);
  },

  handleDrag: function (e) {
    var dragPoint = getControlPosition(e);

    // Calculate X and Y
    var clientX = dragPoint.clientX - this.state.offsetX;
    var clientY = dragPoint.clientY - this.state.offsetY;

    // Snap to grid if prop has been provided
    if (Array.isArray(this.props.grid)) {
      var coords = snapToGrid(this.props.grid, clientX, clientY);
      clientX = coords[0], clientY = coords[1];
    }

    if (this.props.bounds) {
      var pos = getBoundPosition(this, clientX, clientY);
      clientX = pos[0], clientY = pos[1];
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldUpdate = this.props.onDrag(e, createUIEvent(this));
    if (shouldUpdate === false) return this.handleDragEnd();

    // Update transform
    this.setState({
      clientX: clientX,
      clientY: clientY
    });
  },

  onMouseDown: function(ev) {
    // Prevent 'ghost click' which happens 300ms after touchstart if the event isn't cancelled.
    // We don't cancel the event on touchstart because of #37; we might want to make a scrollable item draggable.
    // More on ghost clicks: http://ariatemplates.com/blog/2014/05/ghost-clicks-in-mobile-browsers/
    if (dragEventFor == eventsFor['touch']) {
      return ev.preventDefault();
    }

    return this.handleDragStart.apply(this, arguments);
  },

  onTouchStart: function(ev) {
    // We're on a touch device now, so change the event handlers
    dragEventFor = eventsFor['touch'];

    return this.handleDragStart.apply(this, arguments);
  },

  // Intended for use by a parent component. Resets internal state on this component. Useful for
  // <Resizable> and other components in case this element is manually resized and start/moveOnStartChange
  // don't work for you.
  resetState: function() {
    this.setState({
      offsetX: 0, offsetY: 0, clientX: 0, clientY: 0
    });
  },

  render: function () {
    // Create style object. We extend from existing styles so we don't
    // remove anything already set (like background, color, etc).
    var childStyle = this.props.children.props.style || {};

    // Add a CSS transform to move the element around. This allows us to move the element around
    // without worrying about whether or not it is relatively or absolutely positioned.
    // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
    // has a clean slate.
    var transform = createCSSTransform({
      // Set left if horizontal drag is enabled
      x: canDragX(this) ?
        this.state.clientX :
        0,

      // Set top if vertical drag is enabled
      y: canDragY(this) ?
        this.state.clientY :
        0
    });

    // Workaround IE pointer events; see #51
    // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
    var touchHacks = {
      touchAction: 'none'
    };

    var style = assign({}, childStyle, transform, touchHacks);

    // Set zIndex if currently dragging and prop has been provided
    if (this.state.dragging && !isNaN(this.props.zIndex)) {
      style.zIndex = this.props.zIndex;
    }

    var className = classNames((this.props.children.props.className || ''), 'react-draggable', {
      'react-draggable-dragging': this.state.dragging,
      'react-draggable-dragged': this.state.dragged
    });

    // Reuse the child provided
    // This makes it flexible to use whatever element is wanted (div, ul, etc)
    return React.cloneElement(React.Children.only(this.props.children), {
      style: style,
      className: className,

      onMouseDown: this.onMouseDown,
      onTouchStart: this.onTouchStart,
      onMouseUp: this.handleDragEnd,
      onTouchEnd: this.handleDragEnd
    });
  }
});

},{"classnames":3,"object-assign":4,"react":"react"}],3:[function(require,module,exports){
/*!
  Copyright (c) 2015 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

function classNames() {
	var classes = '';
	var arg;

	for (var i = 0; i < arguments.length; i++) {
		arg = arguments[i];
		if (!arg) {
			continue;
		}

		if ('string' === typeof arg || 'number' === typeof arg) {
			classes += ' ' + arg;
		} else if (Object.prototype.toString.call(arg) === '[object Array]') {
			classes += ' ' + classNames.apply(null, arg);
		} else if ('object' === typeof arg) {
			for (var key in arg) {
				if (!arg.hasOwnProperty(key) || !arg[key]) {
					continue;
				}
				classes += ' ' + key;
			}
		}
	}
	return classes.substr(1);
}

// safely export classNames for node / browserify
if (typeof module !== 'undefined' && module.exports) {
	module.exports = classNames;
}

// safely export classNames for RequireJS
if (typeof define !== 'undefined' && define.amd) {
	define('classnames', [], function() {
		return classNames;
	});
}

},{}],4:[function(require,module,exports){
'use strict';

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = Object.keys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],5:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],6:[function(require,module,exports){
'use strict';

// Rune
let Events = require('./global/Events');
let keys = require('./global/keys');
let Util = require('./global/Util');

let WorkSpaceController = require('./workspace/WorkspaceController');
let ViewController = require('./workspace/canvas/ViewController');
let DataController = require('./models/ModelController');



    function App( ) {

        this.config = {
            nudge: {
                normal: 1,
                super : 10,
            }
        }

        // Setup workspace
        this.savedTablets = Object.keys(localStorage).map(function(ref)  {
            return Util.getLocalData(ref);
        });

        let data = this.savedTablets[0];
        this.data = DataController;
        this.data.setTablet(data);

        this.view = ViewController;
        this.view.loadTablet(this.data.tablet)

        this.workspace = new WorkSpaceController(this);

        let app = this;
        //setInterval(this.save.bind(this), 20000);

    }

    Object.defineProperty(App.prototype,"save",{writable:true,configurable:true,value:function( ) {
        Events.renderSVG.dispatch();
        this.data.save();
    }});


let app = new App();

},{"./global/Events":14,"./global/Util":16,"./global/keys":18,"./models/ModelController":28,"./workspace/WorkspaceController":34,"./workspace/canvas/ViewController":42}],7:[function(require,module,exports){
'use strict';

let React = require('react');

module.exports = React.createClass({displayName: "exports",
    // getInitialState: function () {
        // debugger;
        // return null;   
    // },
    // clickHandler : function () {
    //     this.props.handler();
    // },
    click: function (event) {
        this.props.handler(event);
    },
    render: function() {
        return (
            React.createElement("div", {
                className: "button", 
                onClick: this.click}, 
                 this.props.children || this.props.symbol
            )
        );
    }
});

},{"react":"react"}],8:[function(require,module,exports){
'use strict';

let React = require('react');

module.exports = React.createClass({displayName: "exports",
    render: function() {
        return (
            React.createElement("div", {
                className: "button-group"}, 
                 this.props.children
            )
        );
    }
});

},{"react":"react"}],9:[function(require,module,exports){
'use strict';

let React = require('react');
let Button = require('./Button.jsx');

module.exports = React.createClass({displayName: "exports",
    // getInitialState: function () {
    //     return {toggle: this.props.toggle};
    // },
    // toggle: function () {
    //     this.props.onToggle();
    //     this.setState({toggle: !this.state.toggle});
    // },
    hide: function () {
        React.unmountComponentAtNode(this.props.element);
    },
    render: function () {
        return (
            React.createElement("div", {
                className: "overlay"}, 
                React.createElement("div", {className: "dialogue"}, 
                    React.createElement(Button, {handler: this.hide.bind(this), symbol: "X"}), 
                     this.props.children
                )
            )
        );
    }
});

},{"./Button.jsx":7,"react":"react"}],10:[function(require,module,exports){
'use strict';

let React = require('react');

module.exports = React.createClass({displayName: "exports",
    getInitialState: function () {
        return {active: this.props.active};
    },
    componentWillReceiveProps : function (nextProps) {
        this.setState({active: nextProps.active});
    },
    render: function () {
        let classNames = this.state.active ? 'sheet active' : 'sheet';
        if (this.props.icon) {
            let Icon = this.props.icon;
            debugger;
        }
        return (
            React.createElement("div", {
                className: classNames, 
                onClick: this.props.onClick}, 
                 this.props.icon ?
                    React.createElement(Icon, null)
                    : this.props.name, 
                
                React.createElement("div", {className: "actions"}, 
                    this.props.children
                )
            )
        );
    }
})

},{"react":"react"}],11:[function(require,module,exports){
'use strict';

let React = require('react');

module.exports = React.createClass({displayName: "exports",
    getInitialState: function () {
        return {toggle: this.props.toggle};
    },
    toggle: function () {
        this.props.onToggle();
        this.setState({toggle: !this.state.toggle});
    },
    render: function() {
        let classes = ("switch " + (this.state.toggle ? 'on' : 'off'));
        return (
            React.createElement("div", {
                className: classes, 
                onClick: this.toggle}, 
                 this.props.children || this.props.symbol
            )
        );
    }
});

},{"react":"react"}],12:[function(require,module,exports){
'use strict';

let React = require('react');

module.exports = React.createClass({displayName: "exports",
    getInitialState: function () {
        return {coords: this.props.value};
    },
    updateX: function (event) {
        this.state.coords.x = +event.target.value;
        this.props.change(this.state.coords);
    },
    updateY: function (event) {
        this.state.coords.y = +event.target.value;
        this.props.change(this.state.coords);
    },
    render: function() {
        return (
            React.createElement("div", null, 
                this.props.label, 
                React.createElement("input", {
                    className: "input-x", 
                    defaultValue: this.state.coords.x, 
                    onChange: this.updateX, 
                    type: "number", 
                    step: "1"}), 
                React.createElement("input", {
                    className: "input-y", 
                    defaultValue: this.state.coords.y, 
                    onChange: this.updateY, 
                    type: "number", 
                    step: "1"})
            )
        );
    }
});

},{"react":"react"}],13:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 280,
	BLUE:  '#27dded',
    RED: '#e13d1c',
    GREEN: '#14bb5b',
    CREAM: '#ece5d4'
};

},{}],14:[function(require,module,exports){
let signals = require('signals');

let events = [
    'addPath',
    'addPoint',
    'addTablet',
    'addSubPath',
    'clearPoints',
    'deletePoint',
    'deleteSelected',
    'deletePath',
    'deselectAll',
    'display',
    'draw',
    'renderSVG',
    'gridUpdate',
    'updateGridView',
    'loadTablet',
    'nudge',
    'redrawView',
    'refreshPanels',
    'reloadPanels',
    'resetData',
    'selectPath',
    'selectPoint',
    'superNudge',
    'zoomIn',
    'zoomOut'
];

Events = {};

events.forEach(function(event)  {
    Events[event] = new signals.Signal();
});

module.exports = Events;

},{"signals":5}],15:[function(require,module,exports){
function Trig(){"use strict";}

    Object.defineProperty(Trig,"getMid",{writable:true,configurable:true,value:function(p1, p2) {"use strict";
        return [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2];
    }});
    Object.defineProperty(Trig,"getDistance",{writable:true,configurable:true,value:function(p1, p2) {"use strict";
        return this.getSize(p1.y - p2.y, p1.x - p2.x, null);
    }});
    Object.defineProperty(Trig,"getSize",{writable:true,configurable:true,value:function(adj, opp, hyp) {"use strict";
            if(adj & hyp) {
                return Math.sqrt(hyp*hyp - adj*adj);
            } else if(adj & opp) {
                return Math.sqrt(opp*opp + adj*adj);
            } else if(opp & hyp) {
                return Math.sqrt(hyp*hyp - opp*opp);
            }
    }});
    Object.defineProperty(Trig,"getAngle",{writable:true,configurable:true,value:function(p1, p2) {"use strict";
        // var adj = that.xRes;

        var adj = p1.getDistance(new paper.Point(p2.x, p1.y));
        var hyp = p1.getDistance(p2);

        // cos() = a / h;

        return (Math.PI / 2) - Math.acos( adj / hyp );

    }});
    Object.defineProperty(Trig,"radToDeg",{writable:true,configurable:true,value:function(radians) {"use strict";
        return radians / (Math.PI / 180)
    }});
    Object.defineProperty(Trig,"degToRad",{writable:true,configurable:true,value:function(degrees) {"use strict";
        return degrees * (Math.PI / 180);
    }});


module.exports = Trig;

},{}],16:[function(require,module,exports){
/* ========== Utilities ========== */

function Util(){"use strict";}
	Object.defineProperty(Util,"getIndices",{writable:true,configurable:true,value:function(points, gridPoints) {"use strict";
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	}});

	Object.defineProperty(Util,"object",{writable:true,configurable:true,value:function(o) {"use strict";
        function F() {}
        F.prototype = o;
        return new F();
    }});

    Object.defineProperty(Util,"getLocalData",{writable:true,configurable:true,value:function(ref) {"use strict";
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : null;
    }});


module.exports = Util;

},{}],17:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 280,
	BLUE:  '#27dded',
    RED: '#e13d1c',
    GREEN: '#14bb5b',
    CREAM: '#ece5d4'
};

},{}],18:[function(require,module,exports){
'use strict';

let Events = require('./Events');

const MODIFIERS = [
    'shiftKey',
    'ctrlKey'
];

const keyMap = {
    delete: 8,
    tab: 9,
    enter: 13,
    esc: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    p: 80
};

var superNudgeVectors = {
    'up' : [0,-1],
    'down': [0,1],
    'left' : [-1,0],
    'right' : [1,0]
};

var nudgeVectors = {
    'up' : [0,-0.1],
    'down': [0,0.1],
    'left' : [-0.1,0],
    'right' : [0.1,0]
};


let Keys = {
    key: keyMap,
    maps: {},
    mapKey:function (key, callback) {
        if (this.maps[key]) {
            throw new Error('Key already mapped, soz bro.');
        }
        this.maps[key] = callback;
    },
    init:function () {
        let _this = this;
        document.addEventListener('keydown', function(e) {
            let hasModifier = MODIFIERS.find(function(mod)  {return e[mod];});

            let ref = ((hasModifier && hasModifier + '+' || '') + e.keyCode);

            console.log(ref);

            if (_this.maps[ref] && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                _this.maps[ref]();
            }
        });

        this.mapKey(this.key.delete, function()  {
            Events.deleteSelected.dispatch();
        });

        this.mapKey(this.key.p, function()  {
            Events.display.dispatch();
        });

        Object.keys({
            'up' : this.key.up,
            'down' : this.key.down,
            'left' : this.key.left,
            'right' : this.key.right,
        }).forEach(function(key)  {
            Keys.mapKey(("shiftKey+" + Keys.key[key]), function()  {
                Events.nudge.dispatch(superNudgeVectors[key]);
            });
            Keys.mapKey((Keys.key[key]), function()  {
                Events.nudge.dispatch(nudgeVectors[key]);
            });
        });

        return this;
    }
};

module.exports = Keys.init();

},{"./Events":14}],19:[function(require,module,exports){
'use strict';

let constants = require('./const');
let paper = require('paper');

module.exports = {
    node : {
        normal: {
            strokeWidth: 2,
            strokeColor: 'black',
            fillColor: 'white'
        },
        generated: {
            strokeWidth: 2,
            strokeColor: '#cccccc',
            fillColor: '#f4f4f4'
        },
        selected: {
            strokeWidth: 4,
            strokeColor: 'black',
            fillColor: constants.BLUE
        },
        handle: {
            strokeColor: constants.RED
        }
    },
    grid: {
        fill: {
            fillColor: new paper.Color(constants.BLUE, 0.2)
        }
    },
    overlay: {
        strokeColor: constants.BLUE
    },
    path: {
        filled: {
            fillColor: new paper.Color(0,0,0,0.6),
        },
        outline: {
            strokeColor: 'black'
        },
        active: {
            strokeColor: constants.RED
        }
    }
}

},{"./const":17,"paper":"paper"}],20:[function(require,module,exports){
/* ========== Utilities ========== */

function Util(){"use strict";}
	Object.defineProperty(Util,"getIndices",{writable:true,configurable:true,value:function(points, gridPoints) {"use strict";
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	}});

	Object.defineProperty(Util,"object",{writable:true,configurable:true,value:function(o) {"use strict";
        function F() {}
        F.prototype = o;
        return new F();
    }});

    Object.defineProperty(Util,"getLocalData",{writable:true,configurable:true,value:function(ref) {"use strict";
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : null;
    }});


module.exports = Util;

},{}],21:[function(require,module,exports){
let React = require('react');

module.exports = React.createClass({displayName: "exports",
    render: function () {
        return (
         React.createElement("svg", {viewBox: "0,0,200,200", width: "200", height: "200", xmlns: "http://www.w3.org/2000/svg"}, React.createElement("path", {d: "M40 200c0-88.366 71.634-160 160-160V0C89.543 0 0 89.543 0 200z", "stroke-miterlimit": "10", "font-family": "sans-serif", "font-size": "12"}))
        );
    }
});

},{"react":"react"}],22:[function(require,module,exports){
let React = require('react');

module.exports = React.createClass({displayName: "exports",
    render: function () {
        return (
            React.createElement("svg", {viewBox: "0,0,200,200", width: "200", height: "200", xmlns: "http://www.w3.org/2000/svg"}, React.createElement("path", {d: "M0 0c110.457 0 200 89.543 200 200h-40C160 111.634 88.366 40 0 40V0z", "stroke-miterlimit": "10", "font-family": "sans-serif", "font-size": "12"}))
        );
    }
});

},{"react":"react"}],23:[function(require,module,exports){
let React = require('react');

module.exports = React.createClass({displayName: "exports",
	render: function () {
		return (
			React.createElement("svg", {viewBox: "0,0,200,200", width: "200", height: "200", xmlns: "http://www.w3.org/2000/svg"}, React.createElement("path", {d: "M0 120V80h80V0h40v80h80v40h-80v80H80v-80", "fill-opacity": ".6", "stroke-miterlimit": "10", "font-family": "sans-serif", "font-size": "12"}))
		);
	}
});

},{"react":"react"}],24:[function(require,module,exports){
let React = require('react');

module.exports = React.createClass({displayName: "exports",
    render: function () {
        return (
           React.createElement("svg", {viewBox: "0,0,240,240", width: "240", height: "240", xmlns: "http://www.w3.org/2000/svg"}, React.createElement("path", {d: "M0 120C0 53.726 53.726 0 120 0s120 53.726 120 120-53.726 120-120 120S0 186.274 0 120m40 0c0 44.183 35.817 80 80 80s80-35.817 80-80-35.817-80-80-80-80 35.817-80 80m40 0c0 22.09 17.91 40 40 40s40-17.91 40-40-17.91-40-40-40-40 17.91-40 40", "stroke-miterlimit": "10", "font-family": "sans-serif", "font-size": "12"}))
        );
    }
});

},{"react":"react"}],25:[function(require,module,exports){
let React = require('react');

module.exports = React.createClass({displayName: "exports",
	render: function () {
		return (
			React.createElement("svg", {viewBox: "0,0,200,200", width: "200", height: "200", xmlns: "http://www.w3.org/2000/svg"}, React.createElement("g", {"stroke-miterlimit": "10", "font-family": "sans-serif", "font-size": "12"}, React.createElement("path", {d: "M0 40h200V0H0zM0 120h200V80H0zM0 200h200v-40H0z"})))
		);
	}
});

},{"react":"react"}],26:[function(require,module,exports){
let React = require('react');

module.exports = React.createClass({displayName: "exports",
	render: function () {
		return (
			React.createElement("svg", {viewBox: "0,0,240,240", width: "240", height: "240", xmlns: "http://www.w3.org/2000/svg"}, React.createElement("path", {d: "M120 80l80-80 40 40-80 80 80 80-40 40-80-80-80 80-40-40 80-80L0 40 40 0z", "fill-opacity": ".6", "stroke-miterlimit": "10", "font-family": "sans-serif", "font-size": "12"}))
			);
	}
});

},{"react":"react"}],27:[function(require,module,exports){
let constants = require('../global/const');

const DEFAULT_UNITS = 6;
const DEFAULT_BASE_UNIT = 40;



    function GridModel(data) {"use strict";
        this.units = data && data.units || (DEFAULT_UNITS % 2 == 0 ? DEFAULT_UNITS : DEFAULT_UNITS++);
        this.ratio = data && data.ratio || 1;
        this.baseUnit = data && data.baseUnit || DEFAULT_BASE_UNIT;
    }

    Object.defineProperty(GridModel.prototype,"res",{configurable:true,get:function( ) {"use strict";
        return {
            x: this.baseUnit,
            y: this.baseUnit * this.ratio 
        };
    }});


module.exports = GridModel;

},{"../global/const":17}],28:[function(require,module,exports){
var TabletModel = require('./TabletModel');
var RuneModel = require('./RuneModel');
var Events = require('../global/Events');
var _ = require('lodash');

/* ========== Data ========== */


    function ModelController( ) {"use strict";

        Events.addPoint.add(this.addPoint.bind(this));

        Events.selectPoint.add(this.selectPoint.bind(this));
        Events.selectPath.add(this.selectPath.bind(this));
        Events.clearPoints.add(this.clearRune.bind(this));
        Events.addPath.add(this.addPath.bind(this));
        Events.deletePoint.add(this.deletePoint.bind(this));
        Events.addSubPath.add(this.addSubPath.bind(this));
        Events.deselectAll.add(this.deselectAll.bind(this));

        Events.addTablet.add(this.newTablet.bind(this));
        Events.loadTablet.add(this.loadTablet.bind(this));

        Events.deletePath.add(this.deletePath.bind(this));

        Events.gridUpdate.add(this.updateGrid.bind(this));

        Events.nudge.add(this.addTransformToSelected.bind(this));

    }

    Object.defineProperty(ModelController.prototype,"activeRune",{configurable:true,get:function( ) {"use strict";
        // TODO: Remove & refactor
        return this.tablet.activeRune;
    }});

    Object.defineProperty(ModelController.prototype,"newTablet",{writable:true,configurable:true,value:function( ) {"use strict";
        this.save();
        this.tablet = new TabletModel();
        Events.resetData.dispatch(this.tablet);
        Events.redrawView.dispatch();
        Events.refreshPanels.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"setTablet",{writable:true,configurable:true,value:function(tablet) {"use strict";
        if (this.tablet) {
            this.save();
        }
        this.tablet = new TabletModel(tablet);
    }});

    Object.defineProperty(ModelController.prototype,"loadTablet",{writable:true,configurable:true,value:function(tablet) {"use strict";
        this.setTablet(tablet);
        Events.resetData.dispatch(this.tablet);
        Events.redrawView.dispatch();
        Events.refreshPanels.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"save",{writable:true,configurable:true,value:function( ) {"use strict";
        localStorage[this.tablet.id] = JSON.stringify(this.tablet);
    }});

    Object.defineProperty(ModelController.prototype,"addRune",{writable:true,configurable:true,value:function( ) {"use strict";
        this.tablet.runes.push(new RuneModel());
    }});

    Object.defineProperty(ModelController.prototype,"addPoint",{writable:true,configurable:true,value:function(gridRef) {"use strict";
        this.activeRune.addPoint(gridRef);
        Events.redrawView.dispatch();
        Events.refreshPanels.dispatch();
        // Events.reloadPanels.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"deletePoint",{writable:true,configurable:true,value:function(p) {"use strict";
        this.activeRune.deletePoint(p);
        Events.redrawView.dispatch();
        Events.refreshPanels.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"deletePath",{writable:true,configurable:true,value:function(p) {"use strict";
        this.activeRune.deletePath(p);
        Events.redrawView.dispatch();
        Events.refreshPanels.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"addPath",{writable:true,configurable:true,value:function( ) {"use strict";
        this.activeRune.addPath();
        Events.reloadPanels.dispatch();
        Events.redrawView.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"addSubPath",{writable:true,configurable:true,value:function(path) {"use strict";
        this.activeRune.addSubPath(path);
        Events.reloadPanels.dispatch();
        Events.redrawView.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"clearRune",{writable:true,configurable:true,value:function() {"use strict";
        this.activeRune.clearPaths();
        Events.reloadPanels.dispatch();
        Events.redrawView.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"updateGrid",{writable:true,configurable:true,value:function(grid) {"use strict";
        this.tablet.runes.forEach(function(r)  {return r.updateGrid(grid);});
        Events.updateGridView.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"addTransformToSelected",{writable:true,configurable:true,value:function(transform) {"use strict";

        this.activeRune.selectedPoint.x += transform[0];
        this.activeRune.selectedPoint.y += transform[1];

        Events.redrawView.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"selectPoint",{writable:true,configurable:true,value:function(point) {"use strict";
        this.activeRune.selectHandler(point);
        Events.refreshPanels.dispatch();
        Events.redrawView.dispatch();
    }});

    Object.defineProperty(ModelController.prototype,"deselectAll",{writable:true,configurable:true,value:function( ) {"use strict";
        this.activeRune.deselect();
    }});

    Object.defineProperty(ModelController.prototype,"selectPath",{writable:true,configurable:true,value:function(path) {"use strict";
        this.activeRune.selectPath(path);
        Events.refreshPanels.dispatch();
        Events.draw.dispatch();
    }});


module.exports = new ModelController();

},{"../global/Events":14,"./RuneModel":31,"./TabletModel":32,"lodash":"lodash"}],29:[function(require,module,exports){
'use strict';

let paper = require('paper');
let PointModel = require('./PointModel');


    function PathModel(data) {
        let _this = this;
        this.points = data && data.points.map(function(p)  {return new PointModel(this, p);}.bind(this)) || [];
        this.isClosed = data && data.isClosed || false;
        this.isActive = data && data.isActive || false;
        this.children = data && data.children.map(function(c)  {return new PathModel(c);}) || [];
    }

    Object.defineProperty(PathModel.prototype,"addChild",{writable:true,configurable:true,value:function(path) {
        this.children.push(path);
    }});

    Object.defineProperty(PathModel.prototype,"hasChildren",{configurable:true,get:function( ) {
        return !!this.children.length;
    }});

    Object.defineProperty(PathModel.prototype,"hasPoints",{configurable:true,get:function( ) {
        return !!this.points.length;
    }});



module.exports = PathModel;

},{"./PointModel":30,"paper":"paper"}],30:[function(require,module,exports){
'use strict';

// let ArcModel = require('./ArcModel');


    function ArcModel(obj) {

        // if (typeof obj === 'object') {
            this.size = obj && obj.size || 2;
            this.center = obj && new PointModel(null, obj.center) || new PointModel(null, 1,1);
            this.endPoint = obj && new PointModel(null, obj.endPoint) || new PointModel(null, 0, 0);
            this.direction = obj && obj.direction || false;
        // } else {
        //     this.size = 2;
        //     this.center = new RunePoint(null, 1,1);
        //     this.endPoint = new RunePoint(null, 0,0);
        //     this.direction = false;
        // }
    }





    function PointModel(path, x, y) {

        if (path) {
            Object.defineProperty(this, 'path', {
                value: path,
                writable: true,
                configurable: true
            });
            this.path = path;
        }

        if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
        } else {
             this.x = x;
             this.y = y;
        }

        this.transforms = x.transforms || [];
        this.transform = x.transform || [0,0];
        this.handleIn = x.handleIn || null;
        this.handleOut = x.handleOut || null;
        this.isCurve = x.isCurve || false;
        this.isSelected = x.isSelected || false;
        this.arcIn = x.arcIn && new ArcModel(x.arcIn) || null;
        this.arcOut = x.arcOut && new ArcModel(x.arcOut) || null;
    }

    Object.defineProperty(PointModel.prototype,"toggleCurve",{writable:true,configurable:true,value:function(isCurve) {
        this.isCurve = !this.isCurve;
    }});

    Object.defineProperty(PointModel.prototype,"hasArcIn",{configurable:true,get:function( ) {
        return !!this.arcIn;
    }});

    Object.defineProperty(PointModel.prototype,"hasArcOut",{configurable:true,get:function( ) {
        return !!this.arcOut;
    }});

    Object.defineProperty(PointModel.prototype,"hasArc",{configurable:true,get:function( ) {
        return this.hasArcIn || this.hasArcOut;
    }});

    Object.defineProperty(PointModel.prototype,"setArcIn",{writable:true,configurable:true,value:function( ) {
        this.arcIn = this.hasArcIn ? null : new ArcModel();
    }});

    Object.defineProperty(PointModel.prototype,"setArcOut",{writable:true,configurable:true,value:function( ) {
        this.arcOut = this.hasArcOut ? null : new ArcModel();
    }});

    // set handleIn (coords) {
    //     this._handleIn = this.addHandle(coords);
    // }

    // set handleOut (coords) {
    //     this._handleOut = this.addHandle(coords);
    // }

    // get handleIn () {
    //     return this._handleIn;
    // }

    // get handleOut () {
    //     return this._handleOut;100,10
    // }

    // addHandle (coords) {
    //     return new BasePoint(coords[0], coords[1]);
    // }

    Object.defineProperty(PointModel.prototype,"render",{writable:true,configurable:true,value:function(res) {
        return [
            (this.x * res.x) + (this.transform[0] * res.x),
            (this.y * res.y) + (this.transform[1] * res.y)
        ];
    }});

    Object.defineProperty(PointModel.prototype,"focusNode",{writable:true,configurable:true,value:function( ) {
        if (this.node) {
            this.node.focus();
        }
    }});

    Object.defineProperty(PointModel.prototype,"blurNode",{writable:true,configurable:true,value:function( ) {
        if (this.node) {
            this.node.blur();
        }
    }});

    Object.defineProperty(PointModel.prototype,"setSelected",{writable:true,configurable:true,value:function(selected) {
        this.isSelected = selected;
        if (this.node) {
            this.node.setSelected(selected);
        }
    }});


module.exports = PointModel;

},{}],31:[function(require,module,exports){
'use strict';

let PathModel = require('./PathModel');
let PointModel = require('./PointModel');
let Events = require('../global/Events');



    function RuneModel(data) {

        this.paths = data && data.paths.map(function(p)  {return new PathModel(p);}) || [new PathModel()];
        this.activePath = this.paths.find(function(p)  {return p.isActive;}) || this.paths[0];
        this.selectedPoints = data && data.selectedPoints || [];
        this.currentPointIndex = data && data.currentPointIndex || 0;
        this.reverseAdd = false;
        this.selectedPoint = null;

        let _this = this;

        // Get selected point
        this.paths.forEach(function(p)  {
            if (p.points.some(function(pt)  {return pt.isSelected;})) {
                _this.selectedPoint = p.points.find(function(pt)  {return pt.isSelected;});
            }
        });

        // Events.
    }

    Object.defineProperty(RuneModel.prototype,"clearPaths",{writable:true,configurable:true,value:function( )  {
        this.paths = [new PathModel()];
        this.activePath = this.paths[0];
        return this;
    }});

    Object.defineProperty(RuneModel.prototype,"deletePath",{writable:true,configurable:true,value:function(path) {
        let _this = this;

        del(path, this.paths);

        function del (path, paths) {
            paths.forEach(function(p, i)  {
                if (p.children) {
                    del(path, p.children);
                }
                if (p === path) {
                    paths.splice(i, 1);
                }
            });
        }
    }});

    Object.defineProperty(RuneModel.prototype,"selectHandler",{writable:true,configurable:true,value:function(point, dontSelectPath) {
        if (this.selectedPoint === point) {
            this.deselect();
            return;
        }
        if (this.selectedPoint) {
            this.selectedPoint.setSelected(false);
        }
        if (!dontSelectPath && point.path) {
            this.selectPath(point.path, true);
        }
        point.setSelected(true);
        this.selectedPoint = point;

    }});

    Object.defineProperty(RuneModel.prototype,"updateGrid",{writable:true,configurable:true,value:function(grid) {
        this.paths.forEach(function(path)  {
            path.points.forEach(function(p)  {
                // eg: grid units = 4, point is 1.5 | 1.5
                // we want 4 | 4
                // -1.5 | -0.5 | 0.5 | 1.5
                // 1,2,3,4 
                // + 2.5
                // Eg. grid units = 3, point is -1 | 1
                // we want 1 | 3
                // -1 | 0 | 1
                // + 2
                // == (+ 1/2 + 0.5)
                console.log("p", p);
                let rX =  p.x + ((grid.old.units/2) + 0.5);
                rX = rX / grid.old.units;
                let nX = grid.new.units * rX;
                nX = nX - ((grid.new.units/2) + 0.5);
                p.x = nX;
                console.log(rX,nX);
            });
        });
    }});

    Object.defineProperty(RuneModel.prototype,"deselect",{writable:true,configurable:true,value:function( ) {
        if (this.selectedPoint) {
            this.selectedPoint.setSelected(false);
            this.selectedPoint = null;
        }
    }});

    Object.defineProperty(RuneModel.prototype,"selectPath",{writable:true,configurable:true,value:function(path, dontSelectPoint) {
        if (path !== this.activePath) {
            path.isActive = true;
            if (this.activePath) {
                this.activePath.isActive = false;
            }
            this.activePath = path;
            if (path.hasPoints && !dontSelectPoint) {
              //  this.selectHandler(path.points[0], true);
            } else if (!path.hasPoints) {
              //  this.selectedPoint = null;
            }
        }
    }});

    Object.defineProperty(RuneModel.prototype,"addPath",{writable:true,configurable:true,value:function( ) {
	console.log("Creating path");
        let path = new PathModel();
        this.paths.push(path);
        this.selectPath(path);
        this.selectedPoint = null;
    }});

    Object.defineProperty(RuneModel.prototype,"addSubPath",{writable:true,configurable:true,value:function(path) {
        let subPath = new PathModel();
        path.addChild(subPath);
        this.selectPath(subPath);
    }});

    Object.defineProperty(RuneModel.prototype,"addPoint",{writable:true,configurable:true,value:function(gridPoint) {

        let point = new PointModel(this.activePath, gridPoint.x, gridPoint.y);
        // point.gridPoint = gridPoint;
        let selectedIndex = this.activePath.points.indexOf(this.selectedPoint);

        if (selectedIndex > -1) {
            if (selectedIndex === 0) {
                this.activePath.points.unshift(point);
            } else if (selectedIndex === this.activePath.points.length -1) {
                this.activePath.points.push(point);
            } else {
                this.activePath.points.splice(selectedIndex, 0, point);
            }
        } else {
            this.activePath.points.push(point);
        }

        this.selectHandler(point);

        return this;
    }});

    Object.defineProperty(RuneModel.prototype,"currentPoint",{configurable:true,get:function() {
        return this.paths[this.activePathIndex][this.currentPointIndex];
    }});

    Object.defineProperty(RuneModel.prototype,"currentPoint",{configurable:true,set:function(arr) {
        this.activePathIndex = arr[0];
        this.currentPointIndex = arr[1];
    }});

    Object.defineProperty(RuneModel.prototype,"deletePoint",{writable:true,configurable:true,value:function(p) {

        if (this.selectedPoint = p) {
            this.selectedPoint = null;
        }
        this.activePath.points.forEach(function(point, i)  {
            if (point === p) {
                this.activePath.points.splice(i, 1);
            }
        }.bind(this));
    }});


module.exports = RuneModel;

},{"../global/Events":14,"./PathModel":29,"./PointModel":30}],32:[function(require,module,exports){
'use static';

let RuneModel = require('./RuneModel');
let GridModel = require('./GridModel');

/* ========== Tablet Model ========== */


    function TabletModel(data) {"use strict";

        this.isActive = false;
        this.id = data && data.id || this.guid();
        this.gridOptions = new GridModel(data && data.gridOptions);
        this.renderedSVG = data && data.renderedSVG || '';
        // this.activePathIndex = data && data.activePathIndex || 0;
        this.runes = data && data.runes.map(function(rune)  {return new RuneModel(rune);}) || [new RuneModel()];
        this.activeRune = this.runes[0];
    }

     Object.defineProperty(TabletModel.prototype,"guid",{writable:true,configurable:true,value:function( ) {"use strict";
	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000)
	      .toString(16)
	      .substring(1);
	  }
	  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	    s4() + '-' + s4() + s4() + s4();
	}});


module.exports = TabletModel;

},{"./GridModel":27,"./RuneModel":31}],33:[function(require,module,exports){
'use strict';

let Events = require('../global/Events');

let React = require('react');
let paper = require('paper');

// var SVGO = require('svgo'),
//     svgo = new SVGO({
//          plugins: [
//          ],
//          multipass: true
//     });

// React components:
let Dialogue = require('../components/Dialogue.jsx');
let Button = require('../components/Button.jsx');


    function ActionBar(app) {

    	var actionBar = this;
    	actionBar.app = app;

    	this.actions = [
    		{
    			id : "save",
    			title : "Save",
    			action : function(e) {
    				e.preventDefault();
    				// debugger;
    				actionBar.app.data.save();

    			}
    		},
    		{
    			id : "clear",
    			title : "Clear",
    			action: function(e) {
    				e.preventDefault();
    				// Util.dispatchRuneEvent("clearGridPoints");
                    Events.clearPoints.dispatch();
    			}
    		},
    		{
    			id: "grid",
    			title: "Preview",
    			action: function(e) {
    				e.preventDefault();
                    Events.display.dispatch();
    			}
    		},
    		{
    			id: "rune",
    			title: "Add rune",
    			action: function(e) {
    				e.preventDefault();
    				app.tablet.addRune();
    			}
    		},
    		{
    			id: "svg",
    			title: "Export as SVG",
    			action: function(e) {
    				e.preventDefault();

                    Events.renderSVG.dispatch();

                    let element = document.getElementById('rune-overlay');

                    let dialogue = React.render(
                        React.createElement(Dialogue, {
                            element: element}, 
                            React.createElement("h2", null, "SVG code:"), 
                            React.createElement("textarea", null,  actionBar.app.data.tablet.renderedSVG)
                        ),
                        element
                    );

    				// svgo.optimize(svgString, (result) => {
                    // });

                    // actionBar.app.canvas.displayMode = 'preview';
                    // console.log("here");

    				// let svgString = paper.project.exportSVG({asString: true, layerIndex: 1}});

    				// var link = document.createElement("a");
                    // console.log("and here");
    				// link.download = 'rune_export.svg';
    				// link.href = url;
    				// link.click();
                    // actionBar.app.canvas.displayMode = 'working';
                    // var url = "data:image/svg+xml;utf8," + encodeURIComponent(svgString);
    		  }
    		}
    	];

	   this.render();
	   this.addEvents();
    }

    Object.defineProperty(ActionBar.prototype,"addEvents",{writable:true,configurable:true,value:function(container) {
    	for (var i=0; i < this.actions.length; i++) {
    		var action = this.actions[i];
    		document.querySelectorAll('[data-action="' + action.id + '"]')[0].onclick = action.action;
    	}
    }});;

    Object.defineProperty(ActionBar.prototype,"render",{writable:true,configurable:true,value:function( ) {
    	var actions = this.actions;
    	var ActionBarComponent = React.createClass({displayName: "ActionBarComponent",
    	    render: function() {
    	        return (
    				React.createElement("ul", null, 
    					
    						this.props.actions.map(function(action, i) {
    							return React.createElement("li", {key: action.id}, React.createElement("a", {className: "action", "data-action":  action.id},  action.title));
    						})
    					
    				)
    	        );
    	    }
    	});

    	React.render(
    	    React.createElement(ActionBarComponent, {actions: actions}),
    	    document.getElementById('rune-actionbar')
    	);
    }});


module.exports = ActionBar;

},{"../components/Button.jsx":7,"../components/Dialogue.jsx":9,"../global/Events":14,"paper":"paper","react":"react"}],34:[function(require,module,exports){
var ActionBar = require('./ActionBarController.jsx');
var PanelController = require('./panels/PanelController.jsx');

function WorkSpaceController(app) {

	this.actionBar = new ActionBar(app);
	this.panels = new PanelController(app, app.savedTablets);
}

WorkSpaceController.prototype = {
	constructor: WorkSpaceController,
}

module.exports = WorkSpaceController;

},{"./ActionBarController.jsx":33,"./panels/PanelController.jsx":46}],35:[function(require,module,exports){
let paper = require('paper');


    function CanvasService( ) {"use strict";

        // Setup paper
        this.canvas = document.getElementById('rune-canvas');
        paper.setup(this.canvas).install(window);
        paper.settings.handleSize = 8;

        this.layers = {
            grid: new paper.Layer(),
            render: new paper.Layer(),
            overlay: new paper.Layer(),
            interactive: new paper.Layer()
        };
    }

    Object.defineProperty(CanvasService.prototype,"clearAllLayers",{writable:true,configurable:true,value:function( ) {"use strict";
        Object.keys(this.layers).forEach(function(k)  {return this.layers[k].removeChildren();}.bind(this));
    }});

    Object.defineProperty(CanvasService.prototype,"clearAllLayersBut",{writable:true,configurable:true,value:function(layer) {"use strict";
        Object.keys(this.layers).forEach(function(k)  {
            if( layer !== k) {
                this.clearLayer(k);
            }
        }.bind(this));
    }});

    Object.defineProperty(CanvasService.prototype,"clearLayer",{writable:true,configurable:true,value:function(layer) {"use strict";
        this.layers[layer].removeChildren();
    }});

    Object.defineProperty(CanvasService.prototype,"drawToLayer",{writable:true,configurable:true,value:function(layer, cb) {"use strict";
        this.layers[layer].activate();
        cb();
    }});

    Object.defineProperty(CanvasService.prototype,"centerLayers",{writable:true,configurable:true,value:function( ) {"use strict";
        this.layers.interactive.translate(paper.view.center);
        this.layers.render.translate(paper.view.center);
        this.layers.overlay.translate(paper.view.center);
    }});


module.exports = new CanvasService();

},{"paper":"paper"}],36:[function(require,module,exports){
var Util = require('../../global/util');
var constants = require('../../global/Const');
var Events = require('../../global/Events');
var styles = require('../../global/styles');
var PointModel = require('../../models/PointModel');

var paper = require('paper');
var Canvas = require('./CanvasService');

/* ========== Grid view ========== */

var gridPointFactory = function(point, res)  {

    let p = point.render(res);
    let paperPoint = new paper.Point( p[0] - (res.x/2), p[1] - (res.y/2) );
    // let path = new paper.Path.Ellipse({point: paperPoint, size: [res.x, res.y]});
    let path;

    Canvas.drawToLayer('grid', function()  {
        path = new paper.Path.Rectangle(paperPoint, res.x-2, res.y-2);
    });

    path.value = point;
    path.active = false;

    path.style = styles.grid.fill;
    path.opacity = 0.2;

    path.onMouseEnter = function (e) {
        this.opacity = 0.4;
    };

    path.onMouseLeave = function (e) {
        this.opacity = 0.2;
    };

    path.onMouseDown = function (e) {
        this.opacity = 0.6;
        Events.addPoint.dispatch(e.target.value);
        Events.draw.dispatch();
    };

    return path;
}.bind(this)


	function GridView(options) {"use strict";

    	this.options = options;
    	this.points = [];

        let col, row;
        col = row = -(this.options.units/2) + 0.5;

        for (let i = 1; i <= this.options.units * this.options.units; i++) {
            this.points.push(new PointModel(null, row, col));
            if (i && i % this.options.units == 0) {
                row++;
                col = -(this.options.units/2) + 0.5;
            } else {
                col++;
            }
        }

    }

	Object.defineProperty(GridView.prototype,"draw",{writable:true,configurable:true,value:function( ) {"use strict";

        Canvas.drawToLayer('grid', this.drawToGrid.bind(this));
        this.createGridPoints();

	}});

    Object.defineProperty(GridView.prototype,"drawToGrid",{writable:true,configurable:true,value:function( ) {"use strict";

        let gridColor = new paper.Color(this.gridColor, 100);

        let $__0=  this.options.res,x=$__0.x,y=$__0.y;

        let rowLines, colLines;

        rowLines = new paper.Group();
        colLines = new paper.Group();

        for (let i = -this.options.units/2; i < this.options.units/2; i++) {
            rowLines.addChild(this.xLine(i * y));
            colLines.addChild(this.yLine(i * x));
        }
        colLines.translate([paper.view.center.x + (x/2), 0]);
        rowLines.translate([0, paper.view.center.y + (y/2)]);

        this.xLine(paper.view.center.y, constants.RED);
        this.yLine(paper.view.center.x, constants.RED);

    }});

    Object.defineProperty(GridView.prototype,"createGridPoints",{writable:true,configurable:true,value:function( ) {"use strict";

        this.gridPoints = new paper.Group();

        let _this = this;

        this.points.forEach(function(point)  {
            _this.gridPoints.addChild(gridPointFactory(point, this.options.res));
        }.bind(this));

        this.gridPoints.translate(paper.view.center);
    }});

	Object.defineProperty(GridView.prototype,"yLine",{writable:true,configurable:true,value:function(xLoc, color) {"use strict";
        let line = new paper.Path.Rectangle([xLoc, 0], 1, 2000);
        line.fillColor = color ? color : constants.BLUE;

        return line;
	}});

	Object.defineProperty(GridView.prototype,"xLine",{writable:true,configurable:true,value:function(yLoc, color) {"use strict";
		let line = new paper.Path.Rectangle([0, yLoc], 2000, 1);
        line.fillColor = color ? color : constants.BLUE;

        return line;
	}});


module.exports = GridView;

},{"../../global/Const":13,"../../global/Events":14,"../../global/styles":19,"../../global/util":20,"../../models/PointModel":30,"./CanvasService":35,"paper":"paper"}],37:[function(require,module,exports){
'use strict';

let Events = require('../../global/Events');
let constants = require('../../global/const');
let styles = require('../../global/styles');
let paper = require('paper');
let Trig = require('../../global/Trig');
let RuneArcView = require('./RuneArcView');
let RunePointViewFactory = require('./RunePointViewFactory');
let RuneNodeFactory = require('./RuneNodeFactory');

let Canvas = require('./CanvasService');



    function RunePathView(path, grid) {

        this.grid = grid;

        let style = path.isClosed ? styles.path.filled : path.isActive ? styles.path.active : styles.path.outline;
        let paperPath;

        if (path.hasChildren) {
            let paths = [path].concat(path.children);
            Canvas.drawToLayer('render', function()  {
                paperPath = new paper.CompoundPath({
                    children: paths.map(function(p)  {
                        return this.generatePath(p, style);
                    }.bind(this)),
                    style: style
                });
            }.bind(this));

        } else {
            paperPath = this.generatePath(path, style);
            if (paperPath) {
                paperPath.style = style;
                paperPath.isClosed = path.isClosed;
                paperPath.closed = path.isClosed;
            }
        }

        this.path = paperPath;
    }

    Object.defineProperty(RunePathView.prototype,"generatePath",{writable:true,configurable:true,value:function(path, style) {
        let _this = this;
        let paths = [];
        let segments = [];

        path.points.forEach(function(p)  {
            if (p.hasArc) {
                if (segments.length > 0) {
                    paths.push(new paper.Path(segments));
                    segments = [];
                }
                let renderedPoint = new paper.Point(
                    p.render(_this.grid.res)
                );
                paths = paths.concat(new RuneArcView(p, renderedPoint, _this.grid.res).paths);
            } else {
                segments.push(RunePointViewFactory(p, this.grid.res));
            }
        }.bind(this));


        if (segments.length > 0) {
           paths.push(new paper.Path(segments));
        }

        if (paths.length > 1) {
            let newPath;
            Canvas.drawToLayer('render', function()  {
                newPath = new paper.Path();
            });
            paths.forEach(function(p)  {return newPath.join(p);});
            return newPath;
        } else if (paths[0]) {
            return paths[0];
        } else {
            return null;
        }
    }});

    Object.defineProperty(RunePathView.prototype,"getPathSegment",{writable:true,configurable:true,value:function(path) {
        let _this = this;
        return path.points.map(function(point) {
            return RunePointViewFactory(point, this.grid.res);
        })
    }});


module.exports = RunePathView;

},{"../../global/Events":14,"../../global/Trig":15,"../../global/const":17,"../../global/styles":19,"./CanvasService":35,"./RuneArcView":38,"./RuneNodeFactory":39,"./RunePointViewFactory":40,"paper":"paper"}],38:[function(require,module,exports){
'use strict';

let paper = require('paper');
let Trig = require('../../global/Trig');
let styles = require('../../global/styles');
let RuneNodeFactory = require('./RuneNodeFactory');


    function RuneArcView(point, renderedPoint, res) {

        this.point = point;
        this.renderedPoint = renderedPoint;
        this.res = res;
        this.paths = [];

        if (point.hasArcIn) {
            this.createArc(point.arcIn, true);
        }

        if (point.hasArcOut) {
            this.createArc(point.arcOut, false);
        }
    }

    Object.defineProperty(RuneArcView.prototype,"createArc",{writable:true,configurable:true,value:function(arc, isIn) {

        let center = this.renderedPoint.add(new paper.Point(arc.center.render(this.res)));
        let radius = this.renderedPoint.getDistance(center);
        let rotation = this.renderedPoint.subtract(center);
        let midRotation = this.renderedPoint.subtract(center);

        rotation.length = radius;
        midRotation.length = radius;

        let dirVec = arc.direction ? -1 : 1;
        let angle = Trig.radToDeg(Math.PI/+arc.size) * dirVec;
        let angleVec = this.renderedPoint.angle - center.angle - 90;

        rotation.angle += angle;
        midRotation.angle += angle / 2;

        if (isIn) {
            this.paths.push(new paper.Path.Arc({
                from: center.add(rotation),
                through: center.add(midRotation),
                to: this.renderedPoint,
                strokeColor: 'black'
            }));
        } else {
            this.paths.push(new paper.Path.Arc({
                from: this.renderedPoint,
                through: center.add(midRotation),
                to: center.add(rotation),
                strokeColor: 'black'
            }));
        }

        RuneNodeFactory(this.point, this.renderedPoint);

        if (this.point.isSelected || arc.center.isSelected) {

            RuneNodeFactory(arc.center, center);

            RuneNodeFactory(null, center.add(rotation));

            let circle = new paper.Path.Circle(center, radius);
            circle.style = styles.overlay;
        }
        // let c3 = new paper.Path.Circle(center.add(midRotation), 10);
        // c3.strokeColor = 'blue';
    }});


module.exports = RuneArcView;

},{"../../global/Trig":15,"../../global/styles":19,"./RuneNodeFactory":39,"paper":"paper"}],39:[function(require,module,exports){
'use strict';

let paper = require('paper');
let styles = require('../../global/styles');
let Events = require('../../global/Events');

let Canvas = require('./CanvasService');

module.exports = function (point, renderedPoint) {

	let node;
    Canvas.drawToLayer('interactive', function()  {
        node =  new paper.Path.Circle(renderedPoint, 8);
    });

    let _node = node;

    node.isHandle = true;

    if (point) {
        node.value = point;
        node.isSelected = point.isSelected || false;
        node.style = point.isSelected ? styles.node.selected : styles.node.normal;
        node.onMouseDown = function(e) {
            e.event.stopImmediatePropagation();
            _node.style = _node.isSelected ? styles.node.selected : styles.node.normal;
            Events.selectPoint.dispatch(e.target.value);
            Events.draw.dispatch();
        };
        node.setSelected = function (selected) {
            _node.isSelected = selected;
            _node.style = selected ? styles.node.selected : styles.node.normal;
        };
    } else {
        node.style = styles.node.generated;
    }

    node.focus = function () {
        Events.draw.dispatch();
    };

    node.blur = function () {
        _node.fillColor = 'white';
        Events.draw.dispatch();
    };

    return node;
}

},{"../../global/Events":14,"../../global/styles":19,"./CanvasService":35,"paper":"paper"}],40:[function(require,module,exports){
'use strict';

let paper = require('paper');
let RuneNodeFactory = require('./RuneNodeFactory');
let styles = require('../../global/styles');

function RunePointViewFactory (point, res) {

    let paperPoint = new paper.Point(
        point.render(res)
    );

    // if (point.transform) {
    //     paperPoint = paperPoint.add(new paper.Point(
    //         point.transform[0] * res.x,
    //         point.transform[1] * res.y
    //     ));
    // }

    let handleIn = point.handleIn ? new paper.Point(point.handleIn[0], point.handleIn[1]) : null;
    let handleOut = point.handleOut ? new paper.Point(point.handleOut[0], point.handleOut[1]) : null;

    point.node = RuneNodeFactory(point, paperPoint);

    if (point.isCurve) {
        if (point.isSelected) {
            CreateRuneHandle(paperPoint, paperPoint.add(handleIn));
            CreateRuneHandle(paperPoint, paperPoint.add(handleOut));
        }

        return new paper.Segment({
            point: paperPoint,
            handleIn: handleIn,
            handleOut: handleOut
        });

    } else {
        return paperPoint;
    }
}

function CreateRuneHandle (anchorPoint, handlePoint) {
    let hC = new paper.Path.Circle(handlePoint, 5);
    hC.style = styles.node.handle;
    let l = new paper.Path.Line(handlePoint, anchorPoint);
    l.style = styles.node.handle;
}

module.exports = RunePointViewFactory;

},{"../../global/styles":19,"./RuneNodeFactory":39,"paper":"paper"}],41:[function(require,module,exports){
'use strict';

let PathView = require('./PathView');


    function RuneView(runeModel, grid) {

        this.data = runeModel;
        this.grid = grid;
    }

    Object.defineProperty(RuneView.prototype,"draw",{writable:true,configurable:true,value:function( ) {

        if (this.data.paths) {
            this.data.paths.forEach(function(path)  {
                new PathView(path, this.grid);
            }.bind(this));
        }
    }});



module.exports = RuneView;

},{"./PathView":37}],42:[function(require,module,exports){
let GridView = require('./GridView.js');
let RuneView = require('./RuneView.js');
let Util = require('../../global/Util');
let Events = require('../../global/Events');
let paper = require('paper');

let Canvas = require('./CanvasService');

/* ========== Render Tablet ========== */


    function ViewController( ) {"use strict";

    	// Canvas
        this.isPreview = false;
        this.showGrid = true;

        paper.view.onResize = this.resizeHandler.bind(this);

        Events.draw.add(this.drawView.bind(this));
        Events.redrawView.add(this.redrawView.bind(this));
        Events.updateGridView.add(this.setupGridView.bind(this));
        Events.display.add(this.displayMode.bind(this));
        Events.resetData.add(this.loadTablet.bind(this));
        Events.renderSVG.add(this.renderSVG.bind(this));

    }

    Object.defineProperty(ViewController.prototype,"loadTablet",{writable:true,configurable:true,value:function(tabletModel) {"use strict";
        console.log("Loading model");
        this.tablet = tabletModel;
        this.createRuneView();
        this.setupGridView();
        Events.redrawView.dispatch();
    }});

    Object.defineProperty(ViewController.prototype,"createRuneView",{writable:true,configurable:true,value:function( ) {"use strict";
        this.runeView = new RuneView(
            this.tablet.activeRune,
            this.tablet.gridOptions
        );
    }});

    Object.defineProperty(ViewController.prototype,"displayMode",{writable:true,configurable:true,value:function() {"use strict";
        this.isPreview = !this.isPreview;
        this.redrawView();
    }});

	Object.defineProperty(ViewController.prototype,"setupGridView",{writable:true,configurable:true,value:function( ) {"use strict";
		this.gridView = new GridView(this.tablet.gridOptions);
	}});

    Object.defineProperty(ViewController.prototype,"resizeHandler",{writable:true,configurable:true,value:function( ) {"use strict";
        this.redrawView();
    }});

	Object.defineProperty(ViewController.prototype,"redrawGridLayer",{writable:true,configurable:true,value:function( ) {"use strict";
		Canvas.clearLayer('grid');
        this.gridView.draw();

	}});

    Object.defineProperty(ViewController.prototype,"refreshGrid",{writable:true,configurable:true,value:function( ) {"use strict";
        this.setupGrid();
        this.redrawView();
    }});

    Object.defineProperty(ViewController.prototype,"redrawView",{writable:true,configurable:true,value:function( ) {"use strict";

        Canvas.clearAllLayers();

        this.gridView.draw();
        this.runeView.draw();

        Canvas.centerLayers();

        if (this.isPreview) {
            Canvas.clearAllLayersBut('render');
        }

        this.drawView();
    }});

	Object.defineProperty(ViewController.prototype,"drawView",{writable:true,configurable:true,value:function( ) {"use strict";
        console.log("Redrawing...");
		paper.view.draw();
	}});

    Object.defineProperty(ViewController.prototype,"renderSVG",{writable:true,configurable:true,value:function( ) {"use strict";

        let renderCanvas = new paper.Project(document.getElementById('rune-render'));

        renderCanvas.addChild(Canvas.layers.render);

        let bounds = renderCanvas.layers[0].bounds;
        renderCanvas.layers[0].translate(-bounds.x, -bounds.y);
        renderCanvas.view.viewSize = new paper.Size(bounds.width, bounds.height);

        let svgString = renderCanvas.exportSVG({asString: true, layerIndex: 0});

        svgString = svgString.replace(/fill-opacity=".+?"/g, '');

        svgString = svgString.replace(/\<svg/, ("<svg viewBox=\"0,0," + bounds.width + "," + bounds.height + "\" "));

        this.tablet.renderedSVG = svgString;
    }});


module.exports = new ViewController();

},{"../../global/Events":14,"../../global/Util":16,"./CanvasService":35,"./GridView.js":36,"./RuneView.js":41,"paper":"paper"}],43:[function(require,module,exports){
'use strict';

let React = require('react');
let Events = require('../../global/Events');
let Button = require('../../components/Button.jsx');
let GridModel = require('../../models/GridModel');

module.exports = {
    title: 'Grid',
    collapsed: true,
    panel: React.createClass({displayName: "panel",
        getInitialState : function() {
            return {data: this.props.data.tablet.gridOptions };
        },
        updateData: function(e) {
            let baseUnit = this.refs.baseUnit.getDOMNode().value;
            let ratio = this.refs.ratio.getDOMNode().value;
            let units = this.refs.units.getDOMNode().value;
            let grid = {
                old: new GridModel(this.state.data)
            };
            this.state.data.baseUnit = +baseUnit;
            this.state.data.ratio = +ratio;
            this.state.data.units = +units;
            grid.new = new GridModel(this.state.data);
            Events.gridUpdate.dispatch(grid);
            Events.redrawView.dispatch();
        },
        render: function() {
            return (
                React.createElement("div", null, 
                    React.createElement("label", null, "Zoom level"), 
                    React.createElement("input", {type: "text", ref: "baseUnit", defaultValue:  this.state.data.baseUnit}), 
                    React.createElement("label", null, "Ratio"), 
                    React.createElement("input", {type: "text", ref: "ratio", defaultValue:  this.state.data.ratio}), 
                    React.createElement("label", null, "Units"), 
                    React.createElement("input", {type: "text", ref: "units", defaultValue: this.state.data.units}), 
                    React.createElement("button", {onClick: this.updateData}, 
                        "Update"
                    )
                )
            );
        }
    })
};

},{"../../components/Button.jsx":7,"../../global/Events":14,"../../models/GridModel":27,"react":"react"}],44:[function(require,module,exports){
'use strict';

let React = require('react');
let Events = require('../../global/Events');

// Components:
let Switch = require('../../components/Switch.jsx');
let Sheet = require('../../components/Sheet.jsx');
let Button = require('../../components/Button.jsx');
let ButtonGroup = require('../../components/ButtonGroup.jsx');
let Cross = require('../../icons/Cross.jsx');
let X = require('../../icons/X.jsx');
let PointIcon = require('../../icons/Point.jsx');


let Point = React.createClass({displayName: "Point",
    selectPoint: function(point)  {
        Events.selectPoint.dispatch(point);
    },
    deletePoint: function(point)  {
        Events.deletePoint.dispatch(point);
    },
    // componentWillReceiveProps : function (nextProps) {
    //     this.setState({point: nextProps.point});
    // },
    render: function () {
        return (
            React.createElement(Sheet, {
                icon: PointIcon, 
                active: this.props.point.isSelected, 
                onClick: this.selectPoint.bind(this, this.props.point)}, 
                React.createElement(ButtonGroup, null, 
                    React.createElement(Button, {
                        handler: this.deletePoint.bind(this, this.props.point)}, 
                        React.createElement(X, null)
                    )
                )
            )
        );
    }
})

let Path = React.createClass({displayName: "Path",
    getInitialState: function () {
        return {path: this.props.path};
    },
    changeHandler: function () {
        this.state.path.isClosed = !this.state.path.isClosed;
        this.setState({path: this.state.path});
        Events.redrawView.dispatch();
    },
    componentWillReceiveProps : function (nextProps) {
        this.setState({path :nextProps.path });
        return nextProps;
    },
    selectPath : function (path) {
        if (!this.state.path.isActive) {
            Events.selectPath.dispatch(path);
        }
    },
    removePath: function (path) {
        Events.deletePath.dispatch(path);
    },
    addSubPath: function(path)  {
        Events.addSubPath.dispatch(path);
    },
    render: function () {
        return (
            React.createElement("div", {className: "path"}, 
                React.createElement(Sheet, {
                    name: "––––", 
                    active: this.state.path.isActive, 
                    onClick: this.selectPath.bind(this, this.state.path)}, 
                    React.createElement(ButtonGroup, null, 
                        React.createElement(Button, {
                            handler: this.addSubPath.bind(this, this.state.path)}, 
                            React.createElement(Cross, null)
                        ), 
                        React.createElement(Switch, {onToggle: this.changeHandler, symbol: "&"}, 
                           React.createElement("svg", {viewBox: "0 0 200 200", width: "200", height: "200", xmlns: "http://www.w3.org/2000/svg"}, React.createElement("path", {d: "M120 0h80v200H0V0h80v40H40v120h120V40h-40", "fill-opacity": ".6", "stroke-miterlimit": "10", "font-family": "sans-serif", "font-size": "12"}))
                        ), 
                        React.createElement(Button, {
                            handler: this.removePath.bind(this, this.state.path)}, 
                            React.createElement(X, null)
                        )
                    )
                ), 
                 this.state.path.points.map(function(p)  {return React.createElement(Point, {point: p});}), 
                
                    this.state.path.hasChildren ?
                        this.state.path.children.map(function(p)  {
                            return React.createElement(Path, {path: p});
                        })
                    : null
                
            )
        );
    }
});

module.exports = {
    title: 'Inspect path',
    collapsed: false,
    panel: React.createClass({displayName: "panel",
        getInitialState: function () {
            return {paths: this.props.data.activeRune.paths};
        },
        componentWillReceiveProps: function(nextProps) {
            this.setState({
                paths: nextProps.data.activeRune.paths
            });
        },
        addPath: function()  {
            Events.addPath.dispatch();
        },
        render: function() {
            let _this = this;
            return (
                React.createElement("div", null, 
                    React.createElement(Sheet, {
                        name: "Paths"}, 
                        React.createElement(Button, {
                            handler: this.addPath.bind(this)}, 
                            React.createElement(Cross, null)
                        )
                    ), 
                    
                        this.state.paths.map(function(path)  {
                            return React.createElement(Path, {path: path})
                        })
                    
                )
            );
        }
    })
};

},{"../../components/Button.jsx":7,"../../components/ButtonGroup.jsx":8,"../../components/Sheet.jsx":10,"../../components/Switch.jsx":11,"../../global/Events":14,"../../icons/Cross.jsx":23,"../../icons/Point.jsx":24,"../../icons/X.jsx":26,"react":"react"}],45:[function(require,module,exports){
'use strict';

let React = require('react');
let Events = require('../../global/Events');

// Components
let Sheet = require('../../components/Sheet.jsx');
let Switch = require('../../components/Switch.jsx');
let Button = require('../../components/Button.jsx');
let ButtonGroup = require('../../components/ButtonGroup.jsx');
let XYInput = require('../../components/XYInput.jsx');

// Icons:
let ArcInIcon = require('../../icons/ArcIn.jsx');
let ArcOutIcon = require('../../icons/ArcOut.jsx');

let Handle = React.createClass({displayName: "Handle",
    getInitialState: function () {
        return {handle: this.props.handle};
    },
    componentWillReceiveProps: function(nextProps) {
        this.setState({
            handle: nextProps.handle
        });
    },
    changeHandle: function (event) {
        let coords = event.target.value.split(',');
        if (coords.length === 2) {
            this.props.onUpdate(coords.map(function(c)  {return +c;}));
        }
        // this.setState({handle: this.state.handle});
        // Events.redrawView.dispatch();
    },
    render: function () {
        return (
            React.createElement("div", null, 
                React.createElement("input", {
                    type: "text", 
                    defaultValue: this.state.handle ? this.state.handle.join(',') : null, 
                    onChange: this.changeHandle})
            )
        );
    }
});

let Arc = React.createClass({displayName: "Arc",
    getInitialState: function () {
        return {arc: this.props.arc};
    },
    updateArc: function (prop, arc, event) {
        let $__0=  event.target,value=$__0.value;
        if (prop === 'direction') {
            arc.direction = !arc.direction;
        } else if (prop === 'center') {
            if (value.indexOf(',') > -1) {
                value = value.split(',');
            }
            arc.center.x = +value[0];
            arc.center.y = +value[1];
        } else if (prop === 'size') {
            arc.size = value;
        }
        this.setState({arc: arc});
        Events.redrawView.dispatch();
    },
    updateCenter: function (val) {
        console.log("Arc center", val);
        this.state.arc.center = val;
        this.setState({arc: this.state.arc});
        Events.redrawView.dispatch();
    },
    render: function () {
        let arc = this.state.arc;
        let directionSymbol = this.state.arc.direction ? "⤿" : "⤾";
        return  React.createElement("div", null, 
                    "Arc", React.createElement("br", null), 
                    "Size: ", React.createElement("strong", null, "π/"), 
                    React.createElement("input", {
                        type: "text", 
                        defaultValue: arc.size, 
                        onChange: this.updateArc.bind(this, 'size', arc)}
                        ), 
                    "Center", 
                    React.createElement(XYInput, {
                        change: this.updateCenter, 
                        value: this.state.arc.center, 
                        label: "Center"}), 
                    React.createElement("input", {
                        type: "text", 
                        defaultValue: arc.center.x + ',' + arc.center.y, 
                        onChange: this.updateArc.bind(this, 'center', arc)}
                       ), 
                    React.createElement(Button, {
                        handler: this.updateArc.bind(this, 'direction', arc), 
                        symbol: directionSymbol}
                    )
                )
    }
});

module.exports = {
    title: 'Inspect point',
    collapsed: false,
    panel: React.createClass({displayName: "panel",
        getInitialState: function () {
            return {point: this.props.data.activeRune.selectedPoint};
        },
        setIsCurve: function (point) {
            point.toggleCurve();
            this.setState({point: point});
            Events.redrawView.dispatch();
        },
        componentWillReceiveProps: function(nextProps) {
            this.setState({
                point: nextProps.data.activeRune.selectedPoint
            });
        },
        toggleArcIn: function () {
            this.state.point.setArcIn();
            this.setState({point: this.state.point});
            Events.redrawView.dispatch();
        },
        toggleArcOut: function () {
            this.state.point.setArcOut();
            this.setState({point: this.state.point});
            Events.redrawView.dispatch();
        },
        updateHandleIn: function (val) {
            this.state.point.handleIn = val;
            this.setState({point: this.state.point});
            Events.redrawView.dispatch();
        },
        updateHandleOut: function (val) {
            this.state.point.handleOut = val;
            this.setState({point: this.state.point});
            Events.redrawView.dispatch();
        },
        render: function() {
            if (this.state.point) {
                let _this = this;
                let x = this.state.point.x;
                let y = this.state.point.y;
                return (
                    React.createElement("div", null, 
                        React.createElement("div", {className: "pane"}, 
                            React.createElement("small", null, 
                                React.createElement("span", null, "x: ", x.toFixed(2), ", y:", y.toFixed(2))
                            ), 
                            React.createElement(ButtonGroup, null, 
                                React.createElement(Switch, {
                                    onToggle: this.setIsCurve.bind(this, this.state.point), 
                                    toggle: this.state.point.isCurve, 
                                    symbol: "∩"}
                                ), 
                                React.createElement(Switch, {
                                    onToggle: this.toggleArcIn, 
                                    toggle: this.state.point.hasArcIn
                                    }, 
                                    React.createElement(ArcInIcon, null)
                                ), 
                                React.createElement(Switch, {
                                    onToggle: this.toggleArcOut, 
                                    toggle: this.state.point.hasArcOut}, 
                                    React.createElement(ArcOutIcon, null)
                                )
                            )
                        ), 
                        React.createElement("div", {className: "pane"}, 
                            React.createElement("div", null, 
                                
                                    this.state.point.isCurve ?
                                        React.createElement("div", null, 
                                            React.createElement(Handle, {handle: this.state.point.handleIn, onUpdate: this.updateHandleIn}), 
                                            React.createElement(Handle, {handle: this.state.point.handleOut, onUpdate: this.updateHandleOut})
                                        )
                                    : null, 
                                
                                
                                    this.state.point.hasArcIn ?
                                        React.createElement(Arc, {arc: this.state.point.arcIn})
                                    : null, 
                                
                                
                                    this.state.point.hasArcOut ?
                                        React.createElement(Arc, {arc: this.state.point.arcOut})
                                    : null
                                
                            )
                        )
                    )
                );
            } else {
                return null;
            }
        }
    })
};

},{"../../components/Button.jsx":7,"../../components/ButtonGroup.jsx":8,"../../components/Sheet.jsx":10,"../../components/Switch.jsx":11,"../../components/XYInput.jsx":12,"../../global/Events":14,"../../icons/ArcIn.jsx":21,"../../icons/ArcOut.jsx":22,"react":"react"}],46:[function(require,module,exports){
'use strict';

let Util = require('../../global/Util');
let Draggable = require('react-draggable');

let React = require('react');
let Events = require('../../global/Events');
let PanelWrapper = require('./PanelWrapper.jsx');
let TabletList = require('./TabletList.jsx');

let allPanels = [
    require('./InspectPath.jsx'),
    require('./InspectPoint.jsx'),
    require('./GridManager.jsx')
];



    function PanelController(app, tablets) {
        this.app = app;
        this.tablets = tablets;
        this.init();
    }

    Object.defineProperty(PanelController.prototype,"init",{writable:true,configurable:true,value:function( ) {

        let _this = this;

        let Panels = React.createClass({displayName: "Panels",
            getInitialState: function () {
                return { panels : this.props.panels, data : this.props.data, canvas: this.props.canvas };
            },
            componentWillReceiveProps: function (nextProps) {
                return nextProps;
            },
            render: function() {
                let _this = this;
                return (
                    React.createElement("div", null, 
                        
                            this.state.panels.map(function(panel)  {
                                let Component = panel.panel;
                                return React.createElement(PanelWrapper, {key: panel.title, options: {title : panel.title, collapsed: panel.collapsed}}, 
                                     React.createElement(Component, {data: _this.state.data, canvas: _this.state.canvas})
                                 );
                            })
                        
                    )
                );
            }
        });

        // Plugin panels
        let panels = React.render(
            React.createElement(Panels, {
                panels:  allPanels, 
                data: _this.app.data, 
                canvas: _this.app.canvas}),
            document.getElementById('rune-panels')
        );

        let TabletListPanel = React.createClass({displayName: "TabletListPanel",
            render: function () {
                let Component = TabletList.panel;
                return (React.createElement(PanelWrapper, {options: {title : this.props.title, collapsed: this.props.collapsed}}, 
                     React.createElement(Component, {
                        tablets: this.props.tablets, 
                        activeTablet: this.props.tablet})
                ));
            }
        });

        let tabletPanel = React.render(
            React.createElement(TabletListPanel, {
                title: TabletList.title, 
                collapsed: TabletList.collapsed, 
                tablets: _this.tablets, 
                tablet: this.app.data.tablet}),
             document.getElementById('rune-tabs')
        );

        function reloadHandler () {
            panels.replaceState({'data' : _this.app.data, 'panels' : allPanels, canvas: _this.app.canvas });
        };

        Events.reloadPanels.add(reloadHandler.bind(_this));

        Events.refreshPanels.add(function()  {
            panels.setState({'data' : _this.app.data});
            tabletPanel.setState({tablet: _this.app.data.tablet});
        });

    }});


// <Draggable
//     start={{x: offsetX + 800, y: offsetY }}
//     onStart={this.handleStart}
//     handle=".handle"
//     >
//     <div className="panel">
//         <div className="handle">{ this.props.options.title }<span className="toggle">-</span></div>
//         <div className="panel-content">
//             { this.props.children }
//         </div>
//     </div>
// </Draggable>


module.exports = PanelController;

},{"../../global/Events":14,"../../global/Util":16,"./GridManager.jsx":43,"./InspectPath.jsx":44,"./InspectPoint.jsx":45,"./PanelWrapper.jsx":47,"./TabletList.jsx":48,"react":"react","react-draggable":1}],47:[function(require,module,exports){
'use strict';

let React = require('react');

// Components
let Switch = require('../../components/Switch.jsx');

// Icons:
let Stack = require('../../icons/Stack.jsx');

module.exports = React.createClass({displayName: "exports",
    handleStart: function () {

    },
    handleDrag: function () {

    },
    toggleShow: function () {
        this.setState({collapsed: !this.state.collapsed});
    },
    getInitialState: function () {
        return { collapsed : this.props.options.collapsed };
    },
    render: function() {
        return (
            React.createElement("div", {className: "panel"}, 
                React.createElement("div", {className: "handle", onClick: this.toggleShow}, 
                     this.props.options.title, 
                    React.createElement(Switch, {
                        onToggle: this.toggleShow, 
                        toggle: this.props.collapsed}, 
                        React.createElement(Stack, null)
                    )
                ), 
                 !this.state.collapsed ?
                React.createElement("div", {className: "panel-content"}, 
                     this.props.children
                ) : null
            )
        );
    }
});

},{"../../components/Switch.jsx":11,"../../icons/Stack.jsx":25,"react":"react"}],48:[function(require,module,exports){
'use strict';

let React = require('react');
let paper = require('paper');
let Events = require('../../global/Events');

// Components:
let Button = require('../../components/Button.jsx');

// Icons
let Cross = require('../../icons/Cross.jsx');

module.exports = {
    title: 'Saved Tablets',
    collapsed: false,
    panel: React.createClass({displayName: "panel",
        getInitialState : function() {
            return {tablets: this.props.tablets };
        },
        loadTablet: function (tabletId) {
            Events.loadTablet.dispatch(tabletId);
        },
        newTablet: function () {
            Events.addTablet.dispatch();
        },
        render: function() {
            return (
                React.createElement("div", null, 
                    React.createElement("div", {className: "tablet-previews"}, 
                        
                            this.state.tablets.map(function(tablet)  {
                                return (
                                React.createElement("div", {
                                    className: "tablet-preview", 
                                    onClick: this.loadTablet.bind(this, tablet)}, 
                                    React.createElement("div", {
                                        dangerouslySetInnerHTML: {__html: tablet.renderedSVG}
                                        }
                                    )
                                ))
                            }.bind(this)), 
                        
                        React.createElement("div", {
                            className: "tablet-preview"}, 
                            React.createElement("div", {
                                dangerouslySetInnerHTML: {__html: this.props.activeTablet.renderedSVG}
                                }
                            )
                        ), 
                        React.createElement("div", {className: "tablet-preview"}, 
                            React.createElement(Button, {
                                handler: this.newTablet.bind(this)}, 
                                React.createElement(Cross, null)
                            )
                        )
                    )
                )
            );
        }
    })
};

},{"../../components/Button.jsx":7,"../../global/Events":14,"../../icons/Cross.jsx":23,"paper":"paper","react":"react"}]},{},[6]);
