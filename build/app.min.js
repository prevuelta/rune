(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/draggable');

},{"./lib/draggable":2}],2:[function(require,module,exports){
'use strict';

var React = require('react');
var emptyFunction = function(){};
var assign = require('object-assign');
var classNames = require('classnames');

//
// Helpers. See Element definition below this section.
//

function createUIEvent(draggable) {
  // State changes are often (but not always!) async. We want the latest value.
  var state = draggable._pendingState || draggable.state;
  return {
    node: draggable.getDOMNode(),
    position: {
      top: state.clientY,
      left: state.clientX
    }
  };
}

function canDragY(draggable) {
  return draggable.props.axis === 'both' ||
      draggable.props.axis === 'y';
}

function canDragX(draggable) {
  return draggable.props.axis === 'both' ||
      draggable.props.axis === 'x';
}

function isFunction(func) {
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array, callback) {
  for (var i = 0, length = array.length; i < length; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}

function matchesSelector(el, selector) {
  var method = findInArray([
    'matches',
    'webkitMatchesSelector',
    'mozMatchesSelector',
    'msMatchesSelector',
    'oMatchesSelector'
  ], function(method){
    return isFunction(el[method]);
  });

  return el[method].call(el, selector);
}

/**
 * simple abstraction for dragging events names
 * */
var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    end: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    end: 'mouseup'
  }
};

// Default to mouse events
var dragEventFor = eventsFor['mouse'];

/**
 * get {clientX, clientY} positions of control
 * */
function getControlPosition(e) {
  var position = (e.touches && e.touches[0]) || e;
  return {
    clientX: position.clientX,
    clientY: position.clientY
  };
}

function addEvent(el, event, handler) {
  if (!el) { return; }
  if (el.attachEvent) {
    el.attachEvent('on' + event, handler);
  } else if (el.addEventListener) {
    el.addEventListener(event, handler, true);
  } else {
    el['on' + event] = handler;
  }
}

function removeEvent(el, event, handler) {
  if (!el) { return; }
  if (el.detachEvent) {
    el.detachEvent('on' + event, handler);
  } else if (el.removeEventListener) {
    el.removeEventListener(event, handler, true);
  } else {
    el['on' + event] = null;
  }
}

function outerHeight(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height += int(computedStyle.borderTopWidth);
  height += int(computedStyle.borderBottomWidth);
  return height;
}

function outerWidth(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width += int(computedStyle.borderLeftWidth);
  width += int(computedStyle.borderRightWidth);
  return width;
}
function innerHeight(node) {
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height -= int(computedStyle.paddingTop);
  height -= int(computedStyle.paddingBottom);
  return height;
}

function innerWidth(node) {
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width -= int(computedStyle.paddingLeft);
  width -= int(computedStyle.paddingRight);
  return width;
}

function isNum(num) {
  return typeof num === 'number' && !isNaN(num);
}

function int(a) {
  return parseInt(a, 10);
}

function getBoundPosition(draggable, clientX, clientY) {
  var bounds = JSON.parse(JSON.stringify(draggable.props.bounds));
  var node = draggable.getDOMNode();
  var parent = node.parentNode;

  if (bounds === 'parent') {
    var nodeStyle = window.getComputedStyle(node);
    var parentStyle = window.getComputedStyle(parent);
    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
    bounds = {
      left: -node.offsetLeft + int(parentStyle.paddingLeft) +
            int(nodeStyle.borderLeftWidth) + int(nodeStyle.marginLeft),
      top: -node.offsetTop + int(parentStyle.paddingTop) +
            int(nodeStyle.borderTopWidth) + int(nodeStyle.marginTop),
      right: innerWidth(parent) - outerWidth(node) - node.offsetLeft,
      bottom: innerHeight(parent) - outerHeight(node) - node.offsetTop
    };
  }

  // Keep x and y below right and bottom limits...
  if (isNum(bounds.right)) clientX = Math.min(clientX, bounds.right);
  if (isNum(bounds.bottom)) clientY = Math.min(clientY, bounds.bottom);

  // But above left and top limits.
  if (isNum(bounds.left)) clientX = Math.max(clientX, bounds.left);
  if (isNum(bounds.top)) clientY = Math.max(clientY, bounds.top);

  return [clientX, clientY];
}

function snapToGrid(grid, pendingX, pendingY) {
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}

// Useful for preventing blue highlights all over everything when dragging.
var userSelectStyle = ';user-select: none;-webkit-user-select:none;-moz-user-select:none;' +
  '-o-user-select:none;-ms-user-select:none;';

function addUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style + userSelectStyle);
}

function removeUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style.replace(userSelectStyle, ''));
}

function createCSSTransform(style) {
  // Replace unitless items with px
  var x = style.x + 'px';
  var y = style.y + 'px';
  return {
    transform: 'translate(' + x + ',' + y + ')',
    WebkitTransform: 'translate(' + x + ',' + y + ')',
    OTransform: 'translate(' + x + ',' + y + ')',
    msTransform: 'translate(' + x + ',' + y + ')',
    MozTransform: 'translate(' + x + ',' + y + ')'
  };
}


//
// End Helpers.
//

//
// Define <Draggable>
//

module.exports = React.createClass({
  displayName: 'Draggable',

  propTypes: {
    /**
     * `axis` determines which axis the draggable can move.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     *
     * Defaults to 'both'.
     */
    axis: React.PropTypes.oneOf(['both', 'x', 'y']),

    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: React.PropTypes.oneOfType([
      React.PropTypes.shape({
        left: React.PropTypes.Number,
        right: React.PropTypes.Number,
        top: React.PropTypes.Number,
        bottom: React.PropTypes.Number
      }),
      React.PropTypes.oneOf(['parent', false])
    ]),

    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: React.PropTypes.bool,

    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: React.PropTypes.string,

    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *            <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: React.PropTypes.string,

    /**
     * `grid` specifies the x and y that dragging should snap to.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable grid={[25, 25]}>
     *                   <div>I snap to a 25 x 25 grid</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    grid: React.PropTypes.arrayOf(React.PropTypes.number),

    /**
     * `start` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      var App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable start={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    start: React.PropTypes.shape({
      x: React.PropTypes.number,
      y: React.PropTypes.number
    }),

    /**
     * `moveOnStartChange`, if true (default false) will move the element if the `start`
     * property changes.
     */
    moveOnStartChange: React.PropTypes.bool,


    /**
     * `zIndex` specifies the zIndex to use while dragging.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable zIndex={100}>
     *                   <div>I have a zIndex</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    zIndex: React.PropTypes.number,

    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStart: React.PropTypes.func,

    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onDrag: React.PropTypes.func,

    /**
     * Called when dragging stops.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStop: React.PropTypes.func,

    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (due to that there's internal use of onMouseDown)
     */
    onMouseDown: React.PropTypes.func,
  },

  componentWillReceiveProps: function(newProps) {
    // React to changes in the 'start' param.
    if (newProps.moveOnStartChange && newProps.start) {
      this.setState(this.getInitialState(newProps));
    }
  },

  componentWillUnmount: function() {
    // Remove any leftover event handlers
    removeEvent(document, dragEventFor['move'], this.handleDrag);
    removeEvent(document, dragEventFor['end'], this.handleDragEnd);
    removeUserSelectStyles(this);
  },

  getDefaultProps: function () {
    return {
      axis: 'both',
      bounds: false,
      handle: null,
      cancel: null,
      grid: null,
      moveOnStartChange: false,
      start: {x: 0, y: 0},
      zIndex: NaN,
      enableUserSelectHack: true,
      onStart: emptyFunction,
      onDrag: emptyFunction,
      onStop: emptyFunction,
      onMouseDown: emptyFunction
    };
  },

  getInitialState: function (props) {
    // Handle call from CWRP
    props = props || this.props;
    return {
      // Whether or not we are currently dragging.
      dragging: false,

      // Offset between start top/left and mouse top/left while dragging.
      offsetX: 0, offsetY: 0,

      // Current transform x and y.
      clientX: props.start.x, clientY: props.start.y
    };
  },

  handleDragStart: function (e) {
    // Make it possible to attach event handlers on top of this one
    this.props.onMouseDown(e);

    // Short circuit if handle or cancel prop was provided and selector doesn't match
    if ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||
      (this.props.cancel && matchesSelector(e.target, this.props.cancel))) {
      return;
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldStart = this.props.onStart(e, createUIEvent(this));
    if (shouldStart === false) return;

    var dragPoint = getControlPosition(e);

    // Add a style to the body to disable user-select. This prevents text from
    // being selected all over the page.
    addUserSelectStyles(this);

    // Initiate dragging. Set the current x and y as offsets
    // so we know how much we've moved during the drag. This allows us
    // to drag elements around even if they have been moved, without issue.
    this.setState({
      dragging: true,
      offsetX: dragPoint.clientX - this.state.clientX,
      offsetY: dragPoint.clientY - this.state.clientY
    });


    // Add event handlers
    addEvent(document, dragEventFor['move'], this.handleDrag);
    addEvent(document, dragEventFor['end'], this.handleDragEnd);
  },

  handleDragEnd: function (e) {
    // Short circuit if not currently dragging
    if (!this.state.dragging) {
      return;
    }

    removeUserSelectStyles(this);

    // Turn off dragging
    this.setState({
      dragging: false
    });

    // Call event handler
    this.props.onStop(e, createUIEvent(this));

    // Remove event handlers
    removeEvent(document, dragEventFor['move'], this.handleDrag);
    removeEvent(document, dragEventFor['end'], this.handleDragEnd);
  },

  handleDrag: function (e) {
    var dragPoint = getControlPosition(e);

    // Calculate X and Y
    var clientX = dragPoint.clientX - this.state.offsetX;
    var clientY = dragPoint.clientY - this.state.offsetY;

    // Snap to grid if prop has been provided
    if (Array.isArray(this.props.grid)) {
      var coords = snapToGrid(this.props.grid, clientX, clientY);
      clientX = coords[0], clientY = coords[1];
    }

    if (this.props.bounds) {
      var pos = getBoundPosition(this, clientX, clientY);
      clientX = pos[0], clientY = pos[1];
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldUpdate = this.props.onDrag(e, createUIEvent(this));
    if (shouldUpdate === false) return this.handleDragEnd();

    // Update transform
    this.setState({
      clientX: clientX,
      clientY: clientY
    });
  },

  onMouseDown: function(ev) {
    // Prevent 'ghost click' which happens 300ms after touchstart if the event isn't cancelled.
    // We don't cancel the event on touchstart because of #37; we might want to make a scrollable item draggable.
    // More on ghost clicks: http://ariatemplates.com/blog/2014/05/ghost-clicks-in-mobile-browsers/
    if (dragEventFor == eventsFor['touch']) {
      return ev.preventDefault();
    }

    return this.handleDragStart.apply(this, arguments);
  },

  onTouchStart: function(ev) {
    // We're on a touch device now, so change the event handlers
    dragEventFor = eventsFor['touch'];

    return this.handleDragStart.apply(this, arguments);
  },

  // Intended for use by a parent component. Resets internal state on this component. Useful for
  // <Resizable> and other components in case this element is manually resized and start/moveOnStartChange
  // don't work for you.
  resetState: function() {
    this.setState({
      offsetX: 0, offsetY: 0, clientX: 0, clientY: 0
    });
  },

  render: function () {
    // Create style object. We extend from existing styles so we don't
    // remove anything already set (like background, color, etc).
    var childStyle = this.props.children.props.style || {};

    // Add a CSS transform to move the element around. This allows us to move the element around
    // without worrying about whether or not it is relatively or absolutely positioned.
    // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
    // has a clean slate.
    var transform = createCSSTransform({
      // Set left if horizontal drag is enabled
      x: canDragX(this) ?
        this.state.clientX :
        0,

      // Set top if vertical drag is enabled
      y: canDragY(this) ?
        this.state.clientY :
        0
    });

    // Workaround IE pointer events; see #51
    // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
    var touchHacks = {
      touchAction: 'none'
    };

    var style = assign({}, childStyle, transform, touchHacks);

    // Set zIndex if currently dragging and prop has been provided
    if (this.state.dragging && !isNaN(this.props.zIndex)) {
      style.zIndex = this.props.zIndex;
    }

    var className = classNames((this.props.children.props.className || ''), 'react-draggable', {
      'react-draggable-dragging': this.state.dragging,
      'react-draggable-dragged': this.state.dragged
    });

    // Reuse the child provided
    // This makes it flexible to use whatever element is wanted (div, ul, etc)
    return React.cloneElement(React.Children.only(this.props.children), {
      style: style,
      className: className,

      onMouseDown: this.onMouseDown,
      onTouchStart: this.onTouchStart,
      onMouseUp: this.handleDragEnd,
      onTouchEnd: this.handleDragEnd
    });
  }
});

},{"classnames":3,"object-assign":4,"react":"react"}],3:[function(require,module,exports){
/*!
  Copyright (c) 2015 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

function classNames() {
	var classes = '';
	var arg;

	for (var i = 0; i < arguments.length; i++) {
		arg = arguments[i];
		if (!arg) {
			continue;
		}

		if ('string' === typeof arg || 'number' === typeof arg) {
			classes += ' ' + arg;
		} else if (Object.prototype.toString.call(arg) === '[object Array]') {
			classes += ' ' + classNames.apply(null, arg);
		} else if ('object' === typeof arg) {
			for (var key in arg) {
				if (!arg.hasOwnProperty(key) || !arg[key]) {
					continue;
				}
				classes += ' ' + key;
			}
		}
	}
	return classes.substr(1);
}

// safely export classNames for node / browserify
if (typeof module !== 'undefined' && module.exports) {
	module.exports = classNames;
}

// safely export classNames for RequireJS
if (typeof define !== 'undefined' && define.amd) {
	define('classnames', [], function() {
		return classNames;
	});
}

},{}],4:[function(require,module,exports){
'use strict';

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = Object.keys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],5:[function(require,module,exports){
'use strict';

// Rune
var Events = require('./global/Events');
var WorkSpaceController = require('./workspace/WorkspaceController');
var CanvasController = require('./canvas/CanvasController');
var DataController = require('./data/DataController');

// Extensions
// var FourPointWeightTransform = require('./plugins/FourPointWeightTransform.jsx');
// var PointTranslate = require('./plugins/PointTranslate.jsx');


function App() {

    var app = this;

    // Setup workspace
    app.util = require('./global/util');
    app.data = new DataController(app.util.checkLocal("runeData"));
    app.canvas = new CanvasController(app.data);

    app.plugins = require('./plugins')({
        gridOptions: app.data.tablet.gridOptions,
        selectedPoints: app.data.activeRune.selectedPoints,
        addTransformToSelected: function(data)  { app.data.addTransformToSelected(data); },
        util: app.util,
        layers: app.canvas.layerControllers
    });

    app.workspace = new WorkSpaceController(app);

    // Events
    var events = new Events(app);
    events.init();

}

App.prototype = {
    constructor: App,
    setup: function() {

    },
    save : function() {
        this.data.save();
    }
}


var app = new App();

},{"./canvas/CanvasController":6,"./data/DataController":9,"./global/Events":12,"./global/util":14,"./plugins":17,"./workspace/WorkspaceController":18}],6:[function(require,module,exports){
var GridView = require('./grid/GridView.js');
var RuneView = require('./rune/RuneView.js');

var util = require('../global/util');

var paper = require('paper');

/* ========== Render Tablet ========== */

function CanvasController (tabletModel) {

	// Canvas
	var canvasController = this;
    canvasController.data = tabletModel;

	canvasController.canvas = document.getElementById('rune-canvas');

	paper.setup(canvasController.canvas).install(window);

    paper.settings.handleSize = 8;

	canvasController.layerControllers = [{
        name: 'Grid',
        layer: new paper.Layer()
    }];

	// Setup grid

	canvasController.setupGrid();

	tabletModel.tablet.runes.forEach(function(val, idx) {
		canvasController.layerControllers.push({
            name: 'Rune ' + idx,
            layer: new paper.Layer(),
            view: new RuneView(val, canvasController.grid)
        });
	});

	canvasController.currentLayerIndex = 1;

	canvasController.draw();

	canvasController.showGrid = true;

    canvasController.canvas.addEventListener('mousedown', function(event) {
        util.dispatchRuneEvent('deselectAll');
    });

}

CanvasController.prototype = {
	constructor: CanvasController,
    set displayMode(displayMode) {
        this.toggleGrid();
        var isPreview = displayMode === 'preview';
        this.layerControllers.forEach(function(layerController, index) {
            if (index) {
                console.log(layerController.layer);
                layerController.layer.children.forEach(function(child){
                    console.log(child);
                    if (child.isHandle) {
                        child.visible = !isPreview;
                    } else if (child.runePath) {
                        child.fillColor = isPreview ? 'black' : null;
                        child.strokeColor = isPreview ? null : 'red';
                        child.closed = isPreview;
                    }
                });
            }
        });
        this._displayMode = displayMode;
        this.redraw();
    },
    get gridLayer() {
        return this.layerControllers[0].layer;
    },
	draw : function() {
		// Draw active layer
		this.layerControllers[this.currentLayerIndex].layer.removeChildren();
		this.layerControllers[this.currentLayerIndex].layer.activate();
		this.layerControllers[this.currentLayerIndex].view.draw();
		this.redraw();
	},
	setupGrid : function() {
		this.grid = new GridView(this.data.tablet.gridOptions);
		this.drawGrid();
	},
	drawGrid : function() {

		this.gridLayer.removeChildren();
		this.gridLayer.activate();

		this.grid.draw();

		this.redraw();

	},
	toggleGrid : function(showGrid) {
		this.showGrid = !this.showGrid;
		this.gridLayer.visible = this.showGrid;
		this.redraw();
	},
	redraw : function() {
		paper.view.draw();
	}
}

module.exports = CanvasController;

},{"../global/util":14,"./grid/GridView.js":7,"./rune/RuneView.js":8,"paper":"paper"}],7:[function(require,module,exports){
var util = require('../../global/util');
var constants = require('../../global/const');

var paper = require('paper');


/* ========== Grid view ========== */

function GridView(options) {

	this.res = options.res;
	this.units = options.units;

	this.points = [];

	this.gridColor = constants.BLUE;

	for(var row = 0; row < this.units; row++) {

		this.points[row] = [];

		for(var col = 0; col < this.units; col++) {

			var point = [row, col];
			this.points[row].push(point);

		}

		col = 0;
	}
}

GridView.prototype = {
	constructor: GridView,
	draw: function() {
		console.log("Drawing grid");

		var grid = this;

        var gridColor = new paper.Color(grid.gridColor, 100);

		// Draw lines
		var gridGrid = new paper.Raster();
		gridGrid.setImageData(gridGrid.createImageData(200));
		gridGrid.setPixel(10, 10, 'black');

		for(var i = this.res / 2; i < 2000; i+= this.res) {
			var p1 = new paper.Point(i, 0);
			var p2 = new paper.Point(i, 2000);
			var rec = new paper.Path.Rectangle([i, 0], 1, 2000);
			rec.fillColor = gridColor;
			for(var j = this.res / 2; j < 2000; j+= this.res) {
				var p1 = new paper.Point(0, i);
				var p2 = new paper.Point(2000, i);
				var rec = new paper.Path.Rectangle([0, i], 2000, 1);
				rec.fillColor = gridColor;
			}
		}

		for(var i = 0, arr; arr = grid.points[i++];) {
			for( var j = 0, point; point = arr[j++];) {
				var paperPoint = new paper.Point( this.renderPoint(point) );
				grid.createGridPoint(paperPoint, point);
			}
		}
	},
	renderPoint: function(point){
		return [point[0] * this.res + (this.res / 2), point[1] * this.res + (this.res/2)];
	},
	createGridPoint : function(point, value) {

		var path = paper.Path.Circle(point, this.res / 2);

		path.value = value;
		path.active = false;

		var opaque = new paper.Color(255, 0, 0, 0.2);

		path.fillColor = opaque;

		path.onMouseEnter = function(e) {
			this.fillColor = 'orange';
		}

		path.onMouseLeave = function(e) {
			this.fillColor = this.active ? 'red' : opaque;
		}

		path.onMouseDown = function(e) {

			this.fillColor = 'red';

			// this.active = true;

			util.dispatchRuneEvent('addPoint', e.target.value);
		}
	}
}

module.exports = GridView;

},{"../../global/const":13,"../../global/util":14,"paper":"paper"}],8:[function(require,module,exports){
var util = require('../../global/util');
var paper = require('paper');

/* ========== Tablet ========== */

function RuneView(runeModel, grid) {

    this.points = [];
    this.data = runeModel;
    this.grid = grid;
}

RuneView.prototype = {
    constructor: RuneView,
    draw : function() {

        var runeView = this;

        runeView.runePoints = [];
        runeView.path = new paper.Path();
        runeView.path.strokeColor = 'black';

        var testPath = new paper.Path({
            segments: runeView.data.currentPath.map(function(point, idx) {
                // var pointWithTransforms = point.reduce(function(prev, current) {
                //     return [prev[0] + current[0], prev[1] + current[1]];
                // });
                return runeView.createRuneSegment(
                    point.render(runeView.grid.res),
                    //runeView.grid.renderPoint(pointWithTransforms),
                    idx,
                    runeView.data.selectedPoints.indexOf(idx) > -1,
                    null
                );
            })
        })

        testPath.runePath = true;
        testPath.strokeColor = '#000000';

    },
    createRuneSegment: function(point, value, isSelected, transform) {

        let paperPoint;

        console.log("Point", point);

        if (point.length < 1) {
            paperPoint = new paper.Segment({
                point: point[0],
                handleIn: point[1],
                handleOut: point[2]
            });
        } else {
            paperPoint = new paper.Point(point);
        }

        let p = paperPoint.point || paperPoint;


        if(transform) {
            console.log(transform);
            p.add((function() {
                var point = new paper.Point();
                point.angle = transform[0];
                point.length = transform[1];
                return point;
            })());
        }

        let path = new paper.Path.Rectangle(p.subtract([7, 7]), 14);

        path.isHandle = true;
        path.fillColor = 'white';
        path.value = value;
        path.isSelected = isSelected || false;
        path.strokeWidth = 4;

        path.strokeColor = path.isSelected ? 'red' : false;

        path.onMouseEnter = function(e) {
            // this.fillColor = this.selected ? 'red' : 'orange';
        }

        path.onMouseLeave = function(e) {
            // this.fillColor = 'white';
        }

        path.onMouseDown = function(e) {
            e.event.stopImmediatePropagation();
            this.isSelected = !this.isSelected;
            util.dispatchRuneEvent('selectPoint', [this.isSelected, e.target.value] );
        }

        return paperPoint;
    }
}

module.exports = RuneView;

},{"../../global/util":14,"paper":"paper"}],9:[function(require,module,exports){
var TabletData = require('./DataModel');
var util = require('../global/util');

var _ = require('lodash');

/* ========== Data ========== */

function DataController(tabletModel) {

    this.tablet = new TabletData(tabletModel) || new TabletData(null);
    this.currentRune = 0;
}

DataController.prototype = {
    constructor: DataController,
    get activeRune() {
        return this.tablet.runes[this.currentRune];
    },
    save : function() {
        this.tablet.data.runes = this.tablet.runes.map(function(entry) {
            return entry.data;
        });
        localStorage["runeData"] = JSON.stringify(this.tablet.data);
    },
    addRune : function() {
        this.tablet.runes.push(new RuneData(null));
    },
    addPoint: function(gridRef) {
        this.activeRune.addPoint(gridRef);
        util.dispatchRuneEvent('deselectAll')

    },
    addTransformToSelected: function (transform) {
        var rune = this.activeRune;
        rune.selectedPoints.forEach(function(pointIndex) {
            rune.currentPath[pointIndex].push(transform);
        });
        util.dispatchRuneEvent('redraw');

    },
    clearRune: function() {
        this.activeRune.clearPaths().currentPointIndex = 0;
    },

    updateGrid : function() {
        // var rune = this.getactiveRune();
        // rune.letter.gridPoints.forEach(function(entry, i) {
        // });
    },
    deleteSelected : function() {
        var rune = this.activeRune;
        rune.currentPath = rune.currentPath.filter(function(point, idx) {
            return !~rune.selectedPoints.indexOf(idx);
        });
    },
    selectPoint: function(data) {
        this.activeRune.selectedPoints.push(data);
        this.activeRune.currentPointIndex = data;
        console.log("Current index: " + this.activeRune.currentPointIndex);
    },
    deselectPoint: function(data) {
        this.activeRune.selectedPoints = _.without(this.activeRune.selectedPoints, data);
    }
}

module.exports = DataController;

},{"../global/util":14,"./DataModel":10,"lodash":"lodash"}],10:[function(require,module,exports){
var constants = require('../global/const');
var RunePoint = require('./RunePoint');

/* ========== Tablet Model ========== */


    function TabletData(data) {"use strict";

        var defaultUnits = 10;
        var defaultRes = constants.CANVAS_SIZE / defaultUnits

        var tablet = this;

        if (data) {
            data.runes.forEach(function(rune, i, runes) {
                rune.paths.forEach(function(path, i2, paths) {
                    path.forEach(function(point, i3, points) {
                        data.runes[i].paths[i2][i3] = new RunePoint(point);
                    });
                });
            });
        }

        tablet.data = data || {
            gridOptions: {
                units: defaultUnits,
                res: defaultRes
            },
            renderedSVG: '',
            currentPathIndex: 0
        };

        tablet.runes = [];

        if(data) {
            data.runes.forEach(function(entry) {
                console.log(entry);
                tablet.runes.push(new RuneModel(entry));
            });
        } else {
            tablet.runes.push(new RuneModel(null));
        }
    }

    Object.defineProperty(TabletData.prototype,"gridOptions",{configurable:true,get:function() {"use strict";
         return this.data.gridOptions;
    }});
       
          
     




/* ========== Rune Model ========== */

function RuneModel (data) {
    this.data = data || {
        paths: [ [] ],
        selectedPoints: [],
        currentPathIndex: 0,
        currentPointIndex: 0
    };
   this.reverseAdd = false;
}

RuneModel.prototype = {
    constructor: RuneModel,
    clearPaths: function()  {
        this.data.paths = [[]];
        return this;
    }.bind(this),
    addPoint: function(gridRef)  {
        if (this.selectedPoints.length) {
            if (this.selectedPoints[0] == 0 ) {
                this.reverseAdd = true;
            } else if (this.selectedPoints[0] == this.currentPath.length-1) {
                this.reverseAdd = false;
            }
        }
        if(this.reverseAdd) {
            this.currentPath.unshift(new RunePoint(gridRef[0], gridRef[1]));
        } else {
            this.currentPointIndex++;
            this.currentPath.splice(this.currentPointIndex, 0, new RunePoint(gridRef[0], gridRef[1]));
        }
        return this;
    }.bind(this),
    get currentPath() {
        return this.data.paths[this.data.currentPathIndex];
    },
    set currentPath(arr) {
        this.data.paths[this.data.currentPathIndex] = arr;
    },
    set selectedPoints(selectedPoints) {
        this.data.selectedPoints = selectedPoints;
    },
    get selectedPoints() {
        return this.data.selectedPoints;
    },
    get currentPoint() {
        return this.data.paths[this.data.currentPathIndex][this.data.currentPointIndex];
    },
    set currentPoint(arr) {
        this.currentPathIndex = arr[0];
        this.currentPointIndex = arr[1];
    },
    get currentPathIndex() {
        return this.data.currentPathIndex;
    },
    get currentPointIndex() {
        return this.data.currentPointIndex;
    },
    set currentPointIndex(currentPointIndex) {
        this.data.currentPointIndex = currentPointIndex;
    }
}

module.exports = TabletData;

},{"../global/const":13,"./RunePoint":11}],11:[function(require,module,exports){
/* ========== Point Model ========== */


    function BasePoint(x, y) {"use strict";
        this.x = x;
        this.y = y;
    }

    Object.defineProperty(BasePoint.prototype,"getActual",{writable:true,configurable:true,value:function( ) {"use strict";

    }});

    Object.defineProperty(BasePoint.prototype,"getRelative",{writable:true,configurable:true,value:function( ) {"use strict";

    }});


for(var BasePoint____Key in BasePoint){if(BasePoint.hasOwnProperty(BasePoint____Key)){RunePoint[BasePoint____Key]=BasePoint[BasePoint____Key];}}var ____SuperProtoOfBasePoint=BasePoint===null?null:BasePoint.prototype;RunePoint.prototype=Object.create(____SuperProtoOfBasePoint);RunePoint.prototype.constructor=RunePoint;RunePoint.__superConstructor__=BasePoint;

    function RunePoint(x, y) {"use strict";
        if (typeof x === 'object') {
            BasePoint.call(this,x.x, x.y);
            this.transforms = x.transforms || [];
            this.handles = x.handles || [];
        } else {
            BasePoint.call(this,x, y);
            this.transforms = [];
            this.handles = [];
        }
    }

    Object.defineProperty(RunePoint.prototype,"addHandles",{writable:true,configurable:true,value:function( ) {"use strict";
        this.handles = [new BasePoint(), new BasePoint()];
    }});

    Object.defineProperty(RunePoint.prototype,"render",{writable:true,configurable:true,value:function(unit) {"use strict";
        return [this.x * unit  + (unit / 2), this.y * unit  + (unit / 2)]; 
    }});

    Object.defineProperty(RunePoint.prototype,"isCurve",{configurable:true,get:function( ) {"use strict";
        return 'maybe...';
    }});


module.exports = RunePoint;

},{}],12:[function(require,module,exports){
var util = require('./util');

// Event listeners
function Events(app) {

	this.app = app;

	var events = this;

	this.eventHandlers = {
		addPoint : function (data) {
			events.app.data.addPoint(data);
			events.app.canvas.draw();
		},
		selectPoint: function (data) {
			if(data[0]) {
				events.app.data.selectPoint(data[1]);
			} else {
                events.app.data.deselectPoint(data[1]);
			}
            console.log("Selected points:");
			console.log(app.data.activeRune.selectedPoints);
            events.app.canvas.draw();
		},
		clearGridPoints : function (e) {
			events.app.data.clearRune();
			events.app.canvas.draw();
		},
		preview: function (e) {
			events.app.canvas.displayMode = 'preview';
		},
		deselectAll: function (e) {
			events.app.data.activeRune.selectedPoints = [];
			events.app.canvas.draw();
		},
        refreshCanvas: function () {
            events.app.canvas.setupGrid();
        },
        redraw : function () {
            events.app.canvas.draw();
        }
	}
}

Events.prototype = {
	constructor: Events,
	init: function() {
		var events = this;

		document.addEventListener('runeEvent', function(e) {
			console.log('Event received: ' + e.detail.event);
			events.eventHandlers[e.detail.event](e.detail.data);

		});

        // Needs fixing
		document.addEventListener('keydown', function(e) {
            if(e.target.tagName !== 'INPUT') {
    			switch(e.keyCode) {
    				case 8: //delete
    					e.preventDefault();
    					events.app.data.deleteSelected();
    					events.app.canvas.draw();
    					util.dispatchRuneEvent('deselectAll');

    				break;
    			}
            }
		});
	}
}

module.exports = Events;

},{"./util":14}],13:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 360,
	BLUE:  '#41d4f3'
};

},{}],14:[function(require,module,exports){

var paper = require('paper');

/* ========== Utilities ========== */

module.exports = {
	getIndices: function(points, gridPoints) {
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	},
	object: function (o) {
        function F() {}
        F.prototype = o;
        return new F();
    },
    checkLocal: function(ref) {
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : false;
    },
    dispatchRuneEvent: function(name, data) {
		var runeEvent = new CustomEvent('runeEvent', { 'detail' : { 'event' : name, 'data' :  data }});
		document.dispatchEvent(runeEvent);
	},
	trig: {
		getMid : function(p1, p2) {
			return [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2];
		},
		getDistance : function(p1, p2) {
			return this.getSize(p1.y - p2.y, p1.x - p2.x, null);
		},
		getSize : function (adj, opp, hyp) {
				if(adj & hyp) {
					return Math.sqrt(hyp*hyp - adj*adj);
				} else if(adj & opp) {
					return Math.sqrt(opp*opp + adj*adj);
				} else if(opp & hyp) {
					return Math.sqrt(hyp*hyp - opp*opp);
				}
		},
		getAngle: function(p1, p2) {
			// var adj = that.xRes;

			var adj = p1.getDistance(new paper.Point(p2.x, p1.y));
			var hyp = p1.getDistance(p2);

			// cos() = a / h;

			return (Math.PI / 2) - Math.acos( adj / hyp );

		},
		radToDeg: function(radians) {
			return radians * (180 / Math.PI)
		},
		degToRad: function(degrees) {
			return degrees / (180 / Math.PI);
		}
	}
};

/* ========== Paper prototypes ========== */

paper.Point.prototype.getMid = function(p2) {
	return new paper.Point((this.x + p2.x) / 2, (this.y + p2.y) / 2);
};

},{"paper":"paper"}],15:[function(require,module,exports){
'use strict';

var util = require('../global/util.js');
var React = require('react');
var Draggable = require('react-draggable');

// var getGridPanelComponent = require('./grid/GridPanelComponent.jsx');


function PanelController (app) {
    this.app = app;
    this.loadPanels();
}

// <Draggable
//     start={{x: offsetX + 800, y: offsetY }}
//     onStart={this.handleStart}
//     handle=".handle"
//     >
//     <div className="panel">
//         <div className="handle">{ this.props.options.title }</div>
//         <div className="panel-content">
//             { this.props.children }
//         </div>
//     </div>
// </Draggable>

PanelController.prototype = {
    constructor: PanelController,
    loadPanels: function() {

        var panelController = this;

        var PanelWrapper = React.createClass({displayName: "PanelWrapper",
            handleStart: function() {

            },
            handleDrag: function() {

            },
            render: function() {
                var offsetY = this.props.offset * 50;
                var offsetX = this.props.offset * 5;
                return (
                    React.createElement("div", {className: "panel"}, 
                        React.createElement("div", {className: "handle"},  this.props.options.title), 
                        React.createElement("div", {className: "panel-content"}, 
                             this.props.children
                        )
                    )
                );
            }
        });

        var Panels = React.createClass({displayName: "Panels",
            render: function() {
                console.log(this.props.data);
                return (
                    React.createElement("div", null, 
                        
                            this.props.data.map(function(panel, idx) {
                                var Component = panel.panel;
                                return React.createElement(PanelWrapper, {offset: idx, options: {title : panel.title}}, 
                                     React.createElement(Component, null)
                                 );
                            })
                        
                    )
                );
            }
        });

        console.log(panelController.app.plugins);

        // Plugin panels
        React.render(
            React.createElement(Panels, {data: panelController.app.plugins}),
            document.getElementById('rune-panels')
        );


    },
    updateProperties : function(model) {

    }
}

module.exports = PanelController;

},{"../global/util.js":14,"react":"react","react-draggable":1}],16:[function(require,module,exports){
'use strict';

var React = require('react');

module.exports = function(data) {
    return {
        title: 'Inspect point',
        panel: React.createClass({displayName: "panel",
            getInitialState : function() {
                debugger;
                return { points: data.selectedPoints };
            },
            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("ul", null, 
                            
                                this.state.points.map(function(point) {
                                    console.log(point);
                                    return React.createElement("li", null, 
                                        point.x, ", ", point.y, 
                                         point.isCurve
                                    )
                                })
                            
                        )
                    )
                );
            }
        })
    };
}

},{"react":"react"}],17:[function(require,module,exports){
module.exports = function(exposedData) {
    return [
    	require('./InspectPoint.jsx')(exposedData)
        // require('./GridManager.jsx')(exposedData),
        // require('./PointTranslate.jsx')(exposedData),
        // require('./LayerManager.jsx')(exposedData),
        // require('./PointRandomise.jsx')(exposedData),
        // require('./Shapes.jsx')(exposedData),
        // require('./FourPointWeightTransform.jsx')(exposedData)
    ];
};

},{"./InspectPoint.jsx":16}],18:[function(require,module,exports){
var ActionBar = require('./actionbar/ActionBarController.jsx');
var PanelController = require('./../panels/PanelController.jsx');

function WorkSpaceController(app) {

	this.actionBar = new ActionBar(app);
	this.panels = new PanelController(app);
}

WorkSpaceController.prototype = {
	constructor: WorkSpaceController,
}

module.exports = WorkSpaceController;

},{"./../panels/PanelController.jsx":15,"./actionbar/ActionBarController.jsx":19}],19:[function(require,module,exports){
var util = require('../../global/util.js');

var React = require('react');
var paper = require('paper');

function ActionBar(app) {

	var actionBar = this;
	actionBar.app = app;

	this.actions = [
		{
			id : "save",
			title : "Save",
			action : function(e) {
				e.preventDefault();
				// debugger;
				actionBar.app.data.save();

			}
		},
		{
			id : "clear",
			title : "Clear",
			action: function(e) {
				e.preventDefault();
				util.dispatchRuneEvent("clearGridPoints");
			}
		},
		{
			id: "grid",
			title: "Preview",
			action: function(e) {
				e.preventDefault();
				util.dispatchRuneEvent("preview");
			}
		},
		{
			id: "rune",
			title: "Add rune",
			action: function(e) {
				e.preventDefault();
				app.tablet.addRune();
			}
		},
		{
			id: "svg",
			title: "Export as SVG",
			action: function(e) {
				e.preventDefault();
                actionBar.app.canvas.displayMode = 'preview';
                console.log("here");
				var svgString = paper.project.exportSVG({asString:true, layerIndex: 1});
				var url = "data:image/svg+xml;utf8," + encodeURIComponent(svgString);
				var link = document.createElement("a");
                console.log("and here");
				link.download = 'rune_export.svg';
				link.href = url;
				link.click();
                actionBar.app.canvas.displayMode = 'working';
			}
		}
	];
	this.render();
	this.addEvents();
}

ActionBar.prototype.addEvents = function(container) {
	for (var i=0; i < this.actions.length; i++) {
		var action = this.actions[i];
		document.querySelectorAll('[data-action="' + action.id + '"]')[0].onclick = action.action;
	}
};

ActionBar.prototype.render = function() {
	console.log("this is working");

	var actions = this.actions;

	var ActionBarComponent = React.createClass({displayName: "ActionBarComponent",
	    render: function() {
	        return (
				React.createElement("ul", null, 
					
						this.props.actions.map(function(action, i) {
							return React.createElement("li", null, React.createElement("a", {className: "action", "data-action":  action.id},  action.title));
						})
					
				)
	        );
	    }
	});

	React.render(
	    React.createElement(ActionBarComponent, {actions: actions}),
	    document.getElementById('rune-actionbar')
	);
};

module.exports = ActionBar;

},{"../../global/util.js":14,"paper":"paper","react":"react"}]},{},[5]);
