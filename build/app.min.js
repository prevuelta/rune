(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

// Rune
var Events = require('./global/Events');
var WorkSpaceController = require('./workspace/WorkspaceController');
var CanvasController = require('./canvas/CanvasController');
var DataController = require('./data/DataController');

// Extensions
// var FourPointWeightTransform = require('./plugins/FourPointWeightTransform.jsx');
// var PointTranslate = require('./plugins/PointTranslate.jsx');


function App() {

    var app = this;

    // Setup workspace
    app.util = require('./global/util');
    app.data = new DataController(app.util.checkLocal("runeData"));
    app.canvas = new CanvasController(app.data);

    app.plugins = require('./plugins')({
        gridOptions: app.data.tablet.gridOptions,
        selectedPoints: app.data.activeRune.selectedPoints,
        addTransformToSelected: function(data) { app.data.addTransformToSelected(data); },
        util: app.util,
        layers: app.canvas.layerControllers
    });

    app.workspace = new WorkSpaceController(app);

    // Events
    var events = new Events(app);
    events.init();

}

App.prototype = {
    constructor: App,
    setup: function() {

    },
    save : function() {
        this.data.save();
    }
}


var app = new App();

},{"./canvas/CanvasController":2,"./data/DataController":5,"./global/Events":7,"./global/util":9,"./plugins":12,"./workspace/WorkspaceController":13}],2:[function(require,module,exports){
var GridView = require('./grid/GridView.js');
var RuneView = require('./rune/RuneView.js');

var util = require('../global/util');

var paper = require('paper');

/* ========== Render Tablet ========== */

function CanvasController (tabletModel) {

	// Canvas
	var canvasController = this;
    canvasController.data = tabletModel;

	canvasController.canvas = document.getElementById('rune-canvas');

	paper.setup(canvasController.canvas).install(window);

    paper.settings.handleSize = 8;

	canvasController.layerControllers = [{
        name: 'Grid',
        layer: new paper.Layer()
    }];

	// Setup grid

	canvasController.setupGrid();

	tabletModel.tablet.runes.forEach(function(val, idx) {
		canvasController.layerControllers.push({
            name: 'Rune ' + idx,
            layer: new paper.Layer(),
            view: new RuneView(val, canvasController.grid)
        });
	});

	canvasController.currentLayerIndex = 1;

	canvasController.draw();

	canvasController.showGrid = true;

    canvasController.canvas.addEventListener('mousedown', function(event) {
        util.dispatchRuneEvent('deselectAll');
    });

}

CanvasController.prototype = {
	constructor: CanvasController,
    set displayMode(displayMode) {
        this.toggleGrid();
        var isPreview = displayMode === 'preview';
        this.layerControllers.forEach(function(layerController, index) {
            if (index) {
                console.log(layerController.layer);
                layerController.layer.children.forEach(function(child){
                    console.log(child);
                    if (child.isHandle) {
                        child.visible = !isPreview;
                    } else if (child.runePath) {
                        child.fillColor = isPreview ? 'black' : null;
                        child.strokeColor = isPreview ? null : 'red';
                        child.closed = isPreview;
                    }
                });
            }
        });
        this._displayMode = displayMode;
        this.redraw();
    },
    get gridLayer() {
        return this.layerControllers[0].layer;
    },
	draw : function() {
		// Draw active layer
		this.layerControllers[this.currentLayerIndex].layer.removeChildren();
		this.layerControllers[this.currentLayerIndex].layer.activate();
		this.layerControllers[this.currentLayerIndex].view.draw();
		this.redraw();
	},
	setupGrid : function() {
		this.grid = new GridView(this.data.tablet.gridOptions);
		this.drawGrid();
	},
	drawGrid : function() {

		this.gridLayer.removeChildren();
		this.gridLayer.activate();

		this.grid.draw();

		this.redraw();

	},
	toggleGrid : function(showGrid) {
		this.showGrid = !this.showGrid;
		this.gridLayer.visible = this.showGrid;
		this.redraw();
	},
	redraw : function() {
		paper.view.draw();
	}
}

module.exports = CanvasController;

},{"../global/util":9,"./grid/GridView.js":3,"./rune/RuneView.js":4,"paper":"paper"}],3:[function(require,module,exports){
var util = require('../../global/util');
var constants = require('../../global/const');

var paper = require('paper');


/* ========== Grid view ========== */

function GridView(options) {

	this.res = options.res;
	this.units = options.units;

	this.points = [];

	this.gridColor = constants.BLUE;

	for(var row = 0; row < this.units; row++) {

		this.points[row] = [];

		for(var col = 0; col < this.units; col++) {

			var point = [row, col];
			this.points[row].push(point);

		}

		col = 0;
	}
}

GridView.prototype = {
	constructor: GridView,
	draw: function() {
		console.log("Drawing grid");

		var grid = this;

        var gridColor = new paper.Color(grid.gridColor, 100);

		// Draw lines
		var gridGrid = new paper.Raster();
		gridGrid.setImageData(gridGrid.createImageData(200));
		gridGrid.setPixel(10, 10, 'black');

		for(var i = this.res / 2; i < 2000; i+= this.res) {
			var p1 = new paper.Point(i, 0);
			var p2 = new paper.Point(i, 2000);
			var rec = new paper.Path.Rectangle([i, 0], 1, 2000);
			rec.fillColor = gridColor;
			for(var j = this.res / 2; j < 2000; j+= this.res) {
				var p1 = new paper.Point(0, i);
				var p2 = new paper.Point(2000, i);
				var rec = new paper.Path.Rectangle([0, i], 2000, 1);
				rec.fillColor = gridColor;
			}
		}

		for(var i = 0, arr; arr = grid.points[i++];) {
			for( var j = 0, point; point = arr[j++];) {
				var paperPoint = new paper.Point( this.renderPoint(point) );
				grid.createGridPoint(paperPoint, point);
			}
		}
	},
	renderPoint: function(point){
		return [point[0] * this.res + (this.res / 2), point[1] * this.res + (this.res/2)];
	},
	createGridPoint : function(point, value) {

		var path = paper.Path.Circle(point, this.res / 2);

		path.value = value;
		path.active = false;

		var opaque = new paper.Color(255, 0, 0, 0.2);

		path.fillColor = opaque;

		path.onMouseEnter = function(e) {
			this.fillColor = 'orange';
		}

		path.onMouseLeave = function(e) {
			this.fillColor = this.active ? 'red' : opaque;
		}

		path.onMouseDown = function(e) {

			this.fillColor = 'red';

			// this.active = true;

			util.dispatchRuneEvent('addPoint', e.target.value);
		}
	}
}

module.exports = GridView;

},{"../../global/const":8,"../../global/util":9,"paper":"paper"}],4:[function(require,module,exports){
var util = require('../../global/util');
var paper = require('paper');

/* ========== Tablet ========== */

function RuneView(runeModel, grid) {

    this.points = [];
    this.data = runeModel;
    this.grid = grid;
}

RuneView.prototype = {
    constructor: RuneView,
    draw : function() {

        var runeView = this;

        runeView.runePoints = [];
        runeView.path = new paper.Path();
        runeView.path.strokeColor = 'black';

        var testPath = new paper.Path({
            segments: runeView.data.currentPath.map(function(point, idx) {
                // var pointWithTransforms = point.reduce(function(prev, current) {
                //     return [prev[0] + current[0], prev[1] + current[1]];
                // });
                debugger;
                return runeView.createRuneSegment(
                    point.render(runeView.grid.res),
                    //runeView.grid.renderPoint(pointWithTransforms),
                    idx,
                    runeView.data.selectedPoints.indexOf(idx) > -1,
                    null
                );
            })
        })

        testPath.runePath = true;
        testPath.strokeColor = '#000000';

    },
    createRuneSegment: function(point, value, selected, transform) {

        let paperPoint;

        console.log("Point", point);

        if (point.length < 1) {
            paperPoint = new paper.Segment({
                point: point[0],
                handleIn: point[1],
                handleOut: point[2]
            });
        } else {
            paperPoint = new paper.Point(point);
        }

        let p = paperPoint.point || paperPoint;


        if(transform) {
            console.log(transform);
            p.add((function() {
                var point = new paper.Point();
                point.angle = transform[0];
                point.length = transform[1];
                return point;
            })());
        }

        let path = new paper.Path.Rectangle(p.subtract([7, 7]), 14);

        path.isHandle = true;
        path.fillColor = 'white';
        path.value = value;
        path.selected = selected || false;

        path.onMouseEnter = function(e) {
            // this.fillColor = this.selected ? 'red' : 'orange';
        }

        path.onMouseLeave = function(e) {
            // this.fillColor = 'white';
        }

        path.onMouseDown = function(e) {
            e.event.stopImmediatePropagation();
            this.selected = !this.selected;
            util.dispatchRuneEvent('selectPoint', [this.selected, e.target.value] );
        }

        return paperPoint;
    }
}

module.exports = RuneView;

},{"../../global/util":9,"paper":"paper"}],5:[function(require,module,exports){
var TabletData = require('./DataModel');
var util = require('../global/util');

/* ========== Data ========== */

function DataController(tabletModel) {

    this.tablet = new TabletData(tabletModel) || new TabletData(null);
    this.currentRune = 0;
}

DataController.prototype = {
    constructor: DataController,
    get activeRune() {
        return this.tablet.runes[this.currentRune];
    },
    save : function() {
        this.tablet.data.runes = this.tablet.runes.map(function(entry) {
            return entry.data;
        });
        localStorage["runeData"] = JSON.stringify(this.tablet.data);
    },
    addRune : function() {
        this.tablet.runes.push(new RuneData(null));
    },
    addPoint: function(gridRef) {
        this.activeRune.addPoint(gridRef);
        util.dispatchRuneEvent('deselectAll')

    },
    addTransformToSelected: function (transform) {
        var rune = this.activeRune;
        rune.selectedPoints.forEach(function(pointIndex) {
            rune.currentPath[pointIndex].push(transform);
        });
        util.dispatchRuneEvent('redraw');

    },
    clearRune: function() {
        this.activeRune.clearPaths().currentPointIndex = 0;
    },

    updateGrid : function() {
        // var rune = this.getactiveRune();
        // rune.letter.gridPoints.forEach(function(entry, i) {
        // });
    },
    deleteSelected : function() {
        var rune = this.activeRune;
        rune.currentPath = rune.currentPath.filter(function(point, idx) {
            return !~rune.selectedPoints.indexOf(idx);
        });
    },
    selectPoint: function(data) {
        this.activeRune.selectedPoints.push(data);
        this.activeRune.currentPointIndex = data;
        console.log("Current index: " + this.activeRune.currentPointIndex);
    },
    deselectPoint: function(data) {
        this.activeRune.selectedPoints = _.without(this.activeRune.selectedPoints, data);
    }
}

module.exports = DataController;

},{"../global/util":9,"./DataModel":6}],6:[function(require,module,exports){
var constants = require('../global/const');

/* ========== Tablet Model ========== */

function TabletData(data) {

    var defaultUnits = 10;
    var defaultRes = constants.CANVAS_SIZE / defaultUnits

    var tablet = this;

    tablet.data = data || {
        gridOptions: {
            units: defaultUnits,
            res: defaultRes
        },
        renderedSVG: '',
        currentPathIndex: 0
    };

    tablet.runes = [];

    if(data) {
        data.runes.forEach(function(entry) {
            console.log(entry);
            tablet.runes.push(new RuneModel(entry));
        });
    } else {
        tablet.runes.push(new RuneModel(null));
    }

    // if(gridOptions != null){
    //     $.extend(this.data.gridOptions, gridOptions);
    // }
}

TabletData.prototype = {
    constructor: TabletData,
    get gridOptions() {
         return this.data.gridOptions;
    }
}

/* ========== Point Model ========== */


    function BasePoint(x, y) {"use strict";
        this.x = x;
        this.y = y;
    }
    Object.defineProperty(BasePoint.prototype,"somfunc",{writable:true,configurable:true,value:function() {"use strict";
        
    }});


for(var BasePoint____Key in BasePoint){if(BasePoint.hasOwnProperty(BasePoint____Key)){RunePoint[BasePoint____Key]=BasePoint[BasePoint____Key];}}var ____SuperProtoOfBasePoint=BasePoint===null?null:BasePoint.prototype;RunePoint.prototype=Object.create(____SuperProtoOfBasePoint);RunePoint.prototype.constructor=RunePoint;RunePoint.__superConstructor__=BasePoint;
    
    function RunePoint(x, y) {"use strict"; 
        BasePoint.call(this,x, y); 
        this.transforms = [];
        this.handles = [];
    }

    Object.defineProperty(RunePoint.prototype,"addHandles",{writable:true,configurable:true,value:function( ) {"use strict";
        this.handles = [new BasePoint(), new BasePoint()];
    }});

    Object.defineProperty(RunePoint.prototype,"render",{writable:true,configurable:true,value:function(unit) {"use strict";
        return [this.x * unit  + (unit / 2), this.y * unit  + (unit / 2)]; 
    }});

    Object.defineProperty(RunePoint.prototype,"isCurve",{configurable:true,get:function( ) {"use strict";
        return 'maybe...';
    }});


/* ========== Rune Model ========== */

function RuneModel (data) {
    this.data = data || {
        paths: [ [] ],
        selectedPoints: [],
        currentPathIndex: 0,
        currentPointIndex: 0
    };
   this.reverseAdd = false;
}

RuneModel.prototype = {
    constructor: RuneModel,
    clearPaths: function() {
        this.data.paths = [[]];
        return this;
    },
    addPoint: function(gridRef) {
        if (this.selectedPoints.length) {
            if (this.selectedPoints[0] == 0 ) {
                this.reverseAdd = true;
            } else if (this.selectedPoints[0] == this.currentPath.length-1) {
                this.reverseAdd = false;
            }
        }
        if(this.reverseAdd) {
            this.currentPath.unshift(new RunePoint(gridRef[0], gridRef[1]));
        } else {
            this.currentPointIndex++;
            this.currentPath.splice(this.currentPointIndex, 0, new RunePoint(gridRef[0], gridRef[1]));
        }
        return this;
    },
    get currentPath() {
        return this.data.paths[this.data.currentPathIndex];
    },
    set currentPath(arr) {
        this.data.paths[this.data.currentPathIndex] = arr;
    },
    set selectedPoints(selectedPoints) {
        this.data.selectedPoints = selectedPoints;
    },
    get selectedPoints() {
        return this.data.selectedPoints;
    },
    get currentPoint() {
        return this.data.paths[this.data.currentPathIndex][this.data.currentPointIndex];
    },
    set currentPoint(arr) {
        this.currentPathIndex = arr[0];
        this.currentPointIndex = arr[1];
    },
    get currentPathIndex() {
        return this.data.currentPathIndex;
    },
    get currentPointIndex() {
        return this.data.currentPointIndex;
    },
    set currentPointIndex(currentPointIndex) {
        this.data.currentPointIndex = currentPointIndex;
    }
}

module.exports = TabletData;

},{"../global/const":8}],7:[function(require,module,exports){
var util = require('./util');

// Event listeners
function Events(app) {

	this.app = app;

	var events = this;

	this.eventHandlers = {
		addPoint : function (data) {
			events.app.data.addPoint(data);
			events.app.canvas.draw();
		},
		selectPoint: function (data) {
			if(data[0]) {
				events.app.data.selectPoint(data[1]);
			} else {
                events.app.data.deselectPoint(data[1]);
			}
            console.log("Selected points:");
			console.log(app.data.activeRune.selectedPoints);
		},
		clearGridPoints : function (e) {
			events.app.data.clearRune();
			events.app.canvas.draw();
		},
		preview: function (e) {
			events.app.canvas.displayMode = 'preview';
		},
		deselectAll: function (e) {
			events.app.data.activeRune.selectedPoints = [];
			events.app.canvas.draw();
		},
        refreshCanvas: function () {
            events.app.canvas.setupGrid();
        },
        redraw : function () {
            events.app.canvas.draw();
        }
	}
}

Events.prototype = {
	constructor: Events,
	init: function() {
		var events = this;

		document.addEventListener('runeEvent', function(e) {
			console.log('Event received: ' + e.detail.event);
			events.eventHandlers[e.detail.event](e.detail.data);

		});

        // Needs fixing
		document.addEventListener('keydown', function(e) {
            if(e.target.tagName !== 'INPUT') {
    			switch(e.keyCode) {
    				case 8: //delete
    					e.preventDefault();
    					events.app.data.deleteSelected();
    					events.app.canvas.draw();
    					util.dispatchRuneEvent('deselectAll');

    				break;
    			}
            }
		});
	}
}

module.exports = Events;

},{"./util":9}],8:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 360,
	BLUE:  '#41d4f3'
};

},{}],9:[function(require,module,exports){

var paper = require('paper');

/* ========== Utilities ========== */

module.exports = {
	getIndices: function(points, gridPoints) {
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	},
	object: function (o) {
        function F() {}
        F.prototype = o;
        return new F();
    },
    checkLocal: function(ref) {
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : false;
    },
    dispatchRuneEvent: function(name, data) {
		var runeEvent = new CustomEvent('runeEvent', { 'detail' : { 'event' : name, 'data' :  data }});
		document.dispatchEvent(runeEvent);
	},
	trig: {
		getMid : function(p1, p2) {
			return [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2];
		},
		getDistance : function(p1, p2) {
			return this.getSize(p1.y - p2.y, p1.x - p2.x, null);
		},
		getSize : function (adj, opp, hyp) {
				if(adj & hyp) {
					return Math.sqrt(hyp*hyp - adj*adj);
				} else if(adj & opp) {
					return Math.sqrt(opp*opp + adj*adj);
				} else if(opp & hyp) {
					return Math.sqrt(hyp*hyp - opp*opp);
				}
		},
		getAngle: function(p1, p2) {
			// var adj = that.xRes;

			var adj = p1.getDistance(new paper.Point(p2.x, p1.y));
			var hyp = p1.getDistance(p2);

			// cos() = a / h;

			return (Math.PI / 2) - Math.acos( adj / hyp );

		},
		radToDeg: function(radians) {
			return radians * (180 / Math.PI)
		},
		degToRad: function(degrees) {
			return degrees / (180 / Math.PI);
		}
	}
};

/* ========== Paper prototypes ========== */

paper.Point.prototype.getMid = function(p2) {
	return new paper.Point((this.x + p2.x) / 2, (this.y + p2.y) / 2);
};

},{"paper":"paper"}],10:[function(require,module,exports){
'use strict';

var util = require('../global/util.js');

// var getGridPanelComponent = require('./grid/GridPanelComponent.jsx');


function PanelController (app) {
    this.app = app;
    this.loadPanels();
}

PanelController.prototype = {
    constructor: PanelController,
    loadPanels: function() {

        var panelController = this;

        var PanelWrapper = React.createClass({displayName: "PanelWrapper",
            handleStart: function() {

            },
            handleDrag: function() {

            },
            render: function() {
                var offsetY = this.props.offset * 50;
                var offsetX = this.props.offset * 5;
                return (
                    React.createElement(Draggable, {
                        start: {x: offsetX + 800, y: offsetY}, 
                        onStart: this.handleStart, 
                        handle: ".handle"
                        }, 
                        React.createElement("div", {className: "panel"}, 
                            React.createElement("div", {className: "handle"},  this.props.options.title), 
                            React.createElement("div", {className: "panel-content"}, 
                                 this.props.children
                            )
                        )
                    )
                );
            }
        });

        var Panels = React.createClass({displayName: "Panels",
            render: function() {
                console.log(this.props.data);
                return (
                    React.createElement("div", null, 
                        
                            this.props.data.map(function(panel, idx) {
                                var Component = panel.panel;
                                return React.createElement(PanelWrapper, {offset: idx, options: {title : panel.title}}, 
                                     React.createElement(Component, null)
                                 );
                            })
                        
                    )
                );
            }
        });

        console.log(panelController.app.plugins);

        // Plugin panels
        React.render(
            React.createElement(Panels, {data: panelController.app.plugins}),
            document.getElementById('rune-panels')
        );


    },
    updateProperties : function(model) {

    }
}

module.exports = PanelController;

},{"../global/util.js":9}],11:[function(require,module,exports){
'use strict';

var React = require('react');

module.exports = function(data) {
    return {
        title: 'Inspect point',
        panel: React.createClass({displayName: "panel",
            getInitialState : function() {
                debugger;
                return { data: data.selectedPoints };
            },
            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("ul", null, 
                            
                                this.state.data.map(function(point) {
                                    return React.createElement("li", null, " ", point.x, ", ", point.y, 
                                         point.isCurve, " ")
                                })
                            
                        )
                    )
                );
            }
        })
    };
}

},{"react":"react"}],12:[function(require,module,exports){
module.exports = function(exposedData) {
    return [
    	require('./InspectPoint.jsx')(exposedData)
        // require('./GridManager.jsx')(exposedData),
        // require('./PointTranslate.jsx')(exposedData),
        // require('./LayerManager.jsx')(exposedData),
        // require('./PointRandomise.jsx')(exposedData),
        // require('./Shapes.jsx')(exposedData),
        // require('./FourPointWeightTransform.jsx')(exposedData)
    ];
};

},{"./InspectPoint.jsx":11}],13:[function(require,module,exports){
var ActionBar = require('./actionbar/ActionBarController.jsx');
var PanelController = require('./../panels/PanelController.jsx');

function WorkSpaceController(app) {

	this.actionBar = new ActionBar(app);
	this.panels = new PanelController(app);
}

WorkSpaceController.prototype = {
	constructor: WorkSpaceController,
}

module.exports = WorkSpaceController;

},{"./../panels/PanelController.jsx":10,"./actionbar/ActionBarController.jsx":14}],14:[function(require,module,exports){
var util = require('../../global/util.js');

var React = require('react');
var paper = require('paper');

function ActionBar(app) {

	var actionBar = this;
	actionBar.app = app;

	this.actions = [
		{
			id : "save",
			title : "Save",
			action : function(e) {
				e.preventDefault();
				// debugger;
				actionBar.app.data.save();

			}
		},
		{
			id : "clear",
			title : "Clear",
			action: function(e) {
				e.preventDefault();
				util.dispatchRuneEvent("clearGridPoints");
			}
		},
		{
			id: "grid",
			title: "Preview",
			action: function(e) {
				e.preventDefault();
				util.dispatchRuneEvent("preview");
			}
		},
		{
			id: "rune",
			title: "Add rune",
			action: function(e) {
				e.preventDefault();
				app.tablet.addRune();
			}
		},
		{
			id: "svg",
			title: "Export as SVG",
			action: function(e) {
				e.preventDefault();
                actionBar.app.canvas.displayMode = 'preview';
                console.log("here");
				var svgString = paper.project.exportSVG({asString:true, layerIndex: 1});
				var url = "data:image/svg+xml;utf8," + encodeURIComponent(svgString);
				var link = document.createElement("a");
                console.log("and here");
				link.download = 'rune_export.svg';
				link.href = url;
				link.click();
                actionBar.app.canvas.displayMode = 'working';
			}
		}
	];
	this.render();
	this.addEvents();
}

ActionBar.prototype.addEvents = function(container) {
	for (var i=0; i < this.actions.length; i++) {
		var action = this.actions[i];
		document.querySelectorAll('[data-action="' + action.id + '"]')[0].onclick = action.action;
	}
};

ActionBar.prototype.render = function() {
	console.log("this is working");

	var actions = this.actions;

	var ActionBarComponent = React.createClass({displayName: "ActionBarComponent",
	    render: function() {
	        return (
				React.createElement("ul", null, 
					
						this.props.actions.map(function(action, i) {
							return React.createElement("li", null, React.createElement("a", {className: "action", "data-action":  action.id},  action.title));
						})
					
				)
	        );
	    }
	});

	React.render(
	    React.createElement(ActionBarComponent, {actions: actions}),
	    document.getElementById('rune-actionbar')
	);
};

module.exports = ActionBar;

},{"../../global/util.js":9,"paper":"paper","react":"react"}]},{},[1]);
