(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/draggable');

},{"./lib/draggable":2}],2:[function(require,module,exports){
'use strict';

var React = require('react');
var emptyFunction = function(){};
var assign = require('object-assign');
var classNames = require('classnames');

//
// Helpers. See Element definition below this section.
//

function createUIEvent(draggable) {
  // State changes are often (but not always!) async. We want the latest value.
  var state = draggable._pendingState || draggable.state;
  return {
    node: draggable.getDOMNode(),
    position: {
      top: state.clientY,
      left: state.clientX
    }
  };
}

function canDragY(draggable) {
  return draggable.props.axis === 'both' ||
      draggable.props.axis === 'y';
}

function canDragX(draggable) {
  return draggable.props.axis === 'both' ||
      draggable.props.axis === 'x';
}

function isFunction(func) {
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array, callback) {
  for (var i = 0, length = array.length; i < length; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}

function matchesSelector(el, selector) {
  var method = findInArray([
    'matches',
    'webkitMatchesSelector',
    'mozMatchesSelector',
    'msMatchesSelector',
    'oMatchesSelector'
  ], function(method){
    return isFunction(el[method]);
  });

  return el[method].call(el, selector);
}

/**
 * simple abstraction for dragging events names
 * */
var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    end: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    end: 'mouseup'
  }
};

// Default to mouse events
var dragEventFor = eventsFor['mouse'];

/**
 * get {clientX, clientY} positions of control
 * */
function getControlPosition(e) {
  var position = (e.touches && e.touches[0]) || e;
  return {
    clientX: position.clientX,
    clientY: position.clientY
  };
}

function addEvent(el, event, handler) {
  if (!el) { return; }
  if (el.attachEvent) {
    el.attachEvent('on' + event, handler);
  } else if (el.addEventListener) {
    el.addEventListener(event, handler, true);
  } else {
    el['on' + event] = handler;
  }
}

function removeEvent(el, event, handler) {
  if (!el) { return; }
  if (el.detachEvent) {
    el.detachEvent('on' + event, handler);
  } else if (el.removeEventListener) {
    el.removeEventListener(event, handler, true);
  } else {
    el['on' + event] = null;
  }
}

function outerHeight(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height += int(computedStyle.borderTopWidth);
  height += int(computedStyle.borderBottomWidth);
  return height;
}

function outerWidth(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width += int(computedStyle.borderLeftWidth);
  width += int(computedStyle.borderRightWidth);
  return width;
}
function innerHeight(node) {
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height -= int(computedStyle.paddingTop);
  height -= int(computedStyle.paddingBottom);
  return height;
}

function innerWidth(node) {
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width -= int(computedStyle.paddingLeft);
  width -= int(computedStyle.paddingRight);
  return width;
}

function isNum(num) {
  return typeof num === 'number' && !isNaN(num);
}

function int(a) {
  return parseInt(a, 10);
}

function getBoundPosition(draggable, clientX, clientY) {
  var bounds = JSON.parse(JSON.stringify(draggable.props.bounds));
  var node = draggable.getDOMNode();
  var parent = node.parentNode;

  if (bounds === 'parent') {
    var nodeStyle = window.getComputedStyle(node);
    var parentStyle = window.getComputedStyle(parent);
    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
    bounds = {
      left: -node.offsetLeft + int(parentStyle.paddingLeft) +
            int(nodeStyle.borderLeftWidth) + int(nodeStyle.marginLeft),
      top: -node.offsetTop + int(parentStyle.paddingTop) +
            int(nodeStyle.borderTopWidth) + int(nodeStyle.marginTop),
      right: innerWidth(parent) - outerWidth(node) - node.offsetLeft,
      bottom: innerHeight(parent) - outerHeight(node) - node.offsetTop
    };
  }

  // Keep x and y below right and bottom limits...
  if (isNum(bounds.right)) clientX = Math.min(clientX, bounds.right);
  if (isNum(bounds.bottom)) clientY = Math.min(clientY, bounds.bottom);

  // But above left and top limits.
  if (isNum(bounds.left)) clientX = Math.max(clientX, bounds.left);
  if (isNum(bounds.top)) clientY = Math.max(clientY, bounds.top);

  return [clientX, clientY];
}

function snapToGrid(grid, pendingX, pendingY) {
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}

// Useful for preventing blue highlights all over everything when dragging.
var userSelectStyle = ';user-select: none;-webkit-user-select:none;-moz-user-select:none;' +
  '-o-user-select:none;-ms-user-select:none;';

function addUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style + userSelectStyle);
}

function removeUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style.replace(userSelectStyle, ''));
}

function createCSSTransform(style) {
  // Replace unitless items with px
  var x = style.x + 'px';
  var y = style.y + 'px';
  return {
    transform: 'translate(' + x + ',' + y + ')',
    WebkitTransform: 'translate(' + x + ',' + y + ')',
    OTransform: 'translate(' + x + ',' + y + ')',
    msTransform: 'translate(' + x + ',' + y + ')',
    MozTransform: 'translate(' + x + ',' + y + ')'
  };
}


//
// End Helpers.
//

//
// Define <Draggable>
//

module.exports = React.createClass({
  displayName: 'Draggable',

  propTypes: {
    /**
     * `axis` determines which axis the draggable can move.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     *
     * Defaults to 'both'.
     */
    axis: React.PropTypes.oneOf(['both', 'x', 'y']),

    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: React.PropTypes.oneOfType([
      React.PropTypes.shape({
        left: React.PropTypes.Number,
        right: React.PropTypes.Number,
        top: React.PropTypes.Number,
        bottom: React.PropTypes.Number
      }),
      React.PropTypes.oneOf(['parent', false])
    ]),

    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: React.PropTypes.bool,

    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: React.PropTypes.string,

    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *            <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: React.PropTypes.string,

    /**
     * `grid` specifies the x and y that dragging should snap to.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable grid={[25, 25]}>
     *                   <div>I snap to a 25 x 25 grid</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    grid: React.PropTypes.arrayOf(React.PropTypes.number),

    /**
     * `start` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      var App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable start={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    start: React.PropTypes.shape({
      x: React.PropTypes.number,
      y: React.PropTypes.number
    }),

    /**
     * `moveOnStartChange`, if true (default false) will move the element if the `start`
     * property changes.
     */
    moveOnStartChange: React.PropTypes.bool,


    /**
     * `zIndex` specifies the zIndex to use while dragging.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable zIndex={100}>
     *                   <div>I have a zIndex</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    zIndex: React.PropTypes.number,

    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStart: React.PropTypes.func,

    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onDrag: React.PropTypes.func,

    /**
     * Called when dragging stops.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStop: React.PropTypes.func,

    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (due to that there's internal use of onMouseDown)
     */
    onMouseDown: React.PropTypes.func,
  },

  componentWillReceiveProps: function(newProps) {
    // React to changes in the 'start' param.
    if (newProps.moveOnStartChange && newProps.start) {
      this.setState(this.getInitialState(newProps));
    }
  },

  componentWillUnmount: function() {
    // Remove any leftover event handlers
    removeEvent(document, dragEventFor['move'], this.handleDrag);
    removeEvent(document, dragEventFor['end'], this.handleDragEnd);
    removeUserSelectStyles(this);
  },

  getDefaultProps: function () {
    return {
      axis: 'both',
      bounds: false,
      handle: null,
      cancel: null,
      grid: null,
      moveOnStartChange: false,
      start: {x: 0, y: 0},
      zIndex: NaN,
      enableUserSelectHack: true,
      onStart: emptyFunction,
      onDrag: emptyFunction,
      onStop: emptyFunction,
      onMouseDown: emptyFunction
    };
  },

  getInitialState: function (props) {
    // Handle call from CWRP
    props = props || this.props;
    return {
      // Whether or not we are currently dragging.
      dragging: false,

      // Offset between start top/left and mouse top/left while dragging.
      offsetX: 0, offsetY: 0,

      // Current transform x and y.
      clientX: props.start.x, clientY: props.start.y
    };
  },

  handleDragStart: function (e) {
    // Make it possible to attach event handlers on top of this one
    this.props.onMouseDown(e);

    // Short circuit if handle or cancel prop was provided and selector doesn't match
    if ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||
      (this.props.cancel && matchesSelector(e.target, this.props.cancel))) {
      return;
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldStart = this.props.onStart(e, createUIEvent(this));
    if (shouldStart === false) return;

    var dragPoint = getControlPosition(e);

    // Add a style to the body to disable user-select. This prevents text from
    // being selected all over the page.
    addUserSelectStyles(this);

    // Initiate dragging. Set the current x and y as offsets
    // so we know how much we've moved during the drag. This allows us
    // to drag elements around even if they have been moved, without issue.
    this.setState({
      dragging: true,
      offsetX: dragPoint.clientX - this.state.clientX,
      offsetY: dragPoint.clientY - this.state.clientY
    });


    // Add event handlers
    addEvent(document, dragEventFor['move'], this.handleDrag);
    addEvent(document, dragEventFor['end'], this.handleDragEnd);
  },

  handleDragEnd: function (e) {
    // Short circuit if not currently dragging
    if (!this.state.dragging) {
      return;
    }

    removeUserSelectStyles(this);

    // Turn off dragging
    this.setState({
      dragging: false
    });

    // Call event handler
    this.props.onStop(e, createUIEvent(this));

    // Remove event handlers
    removeEvent(document, dragEventFor['move'], this.handleDrag);
    removeEvent(document, dragEventFor['end'], this.handleDragEnd);
  },

  handleDrag: function (e) {
    var dragPoint = getControlPosition(e);

    // Calculate X and Y
    var clientX = dragPoint.clientX - this.state.offsetX;
    var clientY = dragPoint.clientY - this.state.offsetY;

    // Snap to grid if prop has been provided
    if (Array.isArray(this.props.grid)) {
      var coords = snapToGrid(this.props.grid, clientX, clientY);
      clientX = coords[0], clientY = coords[1];
    }

    if (this.props.bounds) {
      var pos = getBoundPosition(this, clientX, clientY);
      clientX = pos[0], clientY = pos[1];
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldUpdate = this.props.onDrag(e, createUIEvent(this));
    if (shouldUpdate === false) return this.handleDragEnd();

    // Update transform
    this.setState({
      clientX: clientX,
      clientY: clientY
    });
  },

  onMouseDown: function(ev) {
    // Prevent 'ghost click' which happens 300ms after touchstart if the event isn't cancelled.
    // We don't cancel the event on touchstart because of #37; we might want to make a scrollable item draggable.
    // More on ghost clicks: http://ariatemplates.com/blog/2014/05/ghost-clicks-in-mobile-browsers/
    if (dragEventFor == eventsFor['touch']) {
      return ev.preventDefault();
    }

    return this.handleDragStart.apply(this, arguments);
  },

  onTouchStart: function(ev) {
    // We're on a touch device now, so change the event handlers
    dragEventFor = eventsFor['touch'];

    return this.handleDragStart.apply(this, arguments);
  },

  // Intended for use by a parent component. Resets internal state on this component. Useful for
  // <Resizable> and other components in case this element is manually resized and start/moveOnStartChange
  // don't work for you.
  resetState: function() {
    this.setState({
      offsetX: 0, offsetY: 0, clientX: 0, clientY: 0
    });
  },

  render: function () {
    // Create style object. We extend from existing styles so we don't
    // remove anything already set (like background, color, etc).
    var childStyle = this.props.children.props.style || {};

    // Add a CSS transform to move the element around. This allows us to move the element around
    // without worrying about whether or not it is relatively or absolutely positioned.
    // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
    // has a clean slate.
    var transform = createCSSTransform({
      // Set left if horizontal drag is enabled
      x: canDragX(this) ?
        this.state.clientX :
        0,

      // Set top if vertical drag is enabled
      y: canDragY(this) ?
        this.state.clientY :
        0
    });

    // Workaround IE pointer events; see #51
    // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
    var touchHacks = {
      touchAction: 'none'
    };

    var style = assign({}, childStyle, transform, touchHacks);

    // Set zIndex if currently dragging and prop has been provided
    if (this.state.dragging && !isNaN(this.props.zIndex)) {
      style.zIndex = this.props.zIndex;
    }

    var className = classNames((this.props.children.props.className || ''), 'react-draggable', {
      'react-draggable-dragging': this.state.dragging,
      'react-draggable-dragged': this.state.dragged
    });

    // Reuse the child provided
    // This makes it flexible to use whatever element is wanted (div, ul, etc)
    return React.cloneElement(React.Children.only(this.props.children), {
      style: style,
      className: className,

      onMouseDown: this.onMouseDown,
      onTouchStart: this.onTouchStart,
      onMouseUp: this.handleDragEnd,
      onTouchEnd: this.handleDragEnd
    });
  }
});

},{"classnames":3,"object-assign":4,"react":"react"}],3:[function(require,module,exports){
/*!
  Copyright (c) 2015 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

function classNames() {
	var classes = '';
	var arg;

	for (var i = 0; i < arguments.length; i++) {
		arg = arguments[i];
		if (!arg) {
			continue;
		}

		if ('string' === typeof arg || 'number' === typeof arg) {
			classes += ' ' + arg;
		} else if (Object.prototype.toString.call(arg) === '[object Array]') {
			classes += ' ' + classNames.apply(null, arg);
		} else if ('object' === typeof arg) {
			for (var key in arg) {
				if (!arg.hasOwnProperty(key) || !arg[key]) {
					continue;
				}
				classes += ' ' + key;
			}
		}
	}
	return classes.substr(1);
}

// safely export classNames for node / browserify
if (typeof module !== 'undefined' && module.exports) {
	module.exports = classNames;
}

// safely export classNames for RequireJS
if (typeof define !== 'undefined' && define.amd) {
	define('classnames', [], function() {
		return classNames;
	});
}

},{}],4:[function(require,module,exports){
'use strict';

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = Object.keys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],5:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],6:[function(require,module,exports){
'use strict';

// Rune
var Events = require('./global/Events');
var keys = require('./global/keys');
var Util = require('./global/Util');
var WorkSpaceController = require('./features/workspace/WorkspaceController');
var CanvasController = require('./features/canvas/CanvasController');
var DataController = require('./models/DataController');



    function App( ) {

        this.config = {
            nudge: {
                normal: 1,
                super : 10,
            }
        }

        // Setup workspace
        this.data = new DataController(Util.getLocalData("runeData"));
        this.canvas = new CanvasController(this.data);

        this.plugins = require('./plugins')({
            gridOptions: this.data.tablet.gridOptions,
            selectedPoints: this.data.activeRune.selectedPoints,
            path: this.data.activeRune.currentPath,
            addTransformToSelected: function(data)  { this.data.addTransformToSelected(data); }.bind(this),
            layers: this.canvas.layerControllers,
            config: this.config
        });

        this.workspace = new WorkSpaceController(this);

    }

    Object.defineProperty(App.prototype,"save",{writable:true,configurable:true,value:function( ) {
        this.data.save();
    }});


var app = new App();

},{"./features/canvas/CanvasController":7,"./features/workspace/WorkspaceController":12,"./global/Events":14,"./global/Util":16,"./global/keys":18,"./models/DataController":20,"./plugins":32}],7:[function(require,module,exports){
var GridView = require('./GridView.js');
var RuneView = require('./RuneView.js');
var Util = require('../../global/Util');
var Events = require('../../global/Events');

var paper = require('paper');

/* ========== Render Tablet ========== */


    function CanvasController(tabletModel) {"use strict";

    	// Canvas
        let _this = this;

        this.data = tabletModel;

    	this.canvas = document.getElementById('rune-canvas');

    	paper.setup(this.canvas).install(window);

        paper.settings.handleSize = 8;

    	this.layerControllers = [{
            name: 'Grid',
            layer: new paper.Layer()
        }];

        paper.view.onResize = this.resizeHandler.bind(this);

    	// Setup grid

    	this.setupGrid();

    	tabletModel.tablet.runes.forEach(function(val, idx) {
    		_this.layerControllers.push({
                name: 'Rune ' + idx,
                layer: new paper.Layer(),
                view: new RuneView(val, _this.grid)
            });
    	});

    	this.currentLayerIndex = 1;

    	this.showGrid = true;

        this.canvas.addEventListener('mousedown', function(event) {
            Events.deselectAll.dispatch();
        });

        Events.redraw.add(this.drawCanvas.bind(this));
        Events.refreshCanvas.add(this.refreshCanvas.bind(this));
        Events.display.add(this.displayMode.bind(this));

        Events.redraw.dispatch();

    }

    Object.defineProperty(CanvasController.prototype,"displayMode",{writable:true,configurable:true,value:function(displayMode) {"use strict";

        this.toggleGrid();

        var isPreview = displayMode === 'preview';

        this.layerControllers.forEach(function(layerController, index) {
            if (index) {
                console.log(layerController.layer);
                layerController.layer.children.forEach(function(child){
                    console.log(child);
                    if (child.isHandle) {
                        child.visible = !isPreview;
                    } else if (child.runePath) {
                        child.fillColor = isPreview ? 'black' : null;
                        child.strokeColor = isPreview ? null : 'red';
                        child.closed = isPreview;
                    }
                });
            }
        });

        Events.redraw.dispatch();
    }});

    Object.defineProperty(CanvasController.prototype,"gridLayer",{configurable:true,get:function() {"use strict";
        return this.layerControllers[0].layer;
    }});


	Object.defineProperty(CanvasController.prototype,"setupGrid",{writable:true,configurable:true,value:function( ) {"use strict";
		this.grid = new GridView(this.data.tablet.gridOptions);
		this.redrawGrid();
	}});

    Object.defineProperty(CanvasController.prototype,"toggleGrid",{writable:true,configurable:true,value:function(showGrid) {"use strict";
        this.showGrid = !this.showGrid;
        this.gridLayer.visible = this.showGrid;
        Events.redraw.dispatch();
    }});

    Object.defineProperty(CanvasController.prototype,"resizeHandler",{writable:true,configurable:true,value:function( ) {"use strict";
        this.redrawAllLayers();
    }});

    Object.defineProperty(CanvasController.prototype,"redrawAllLayers",{writable:true,configurable:true,value:function( ) {"use strict";
        this.redrawGrid();
        this.layerControllers.forEach(function(ctrl)  {
            if (ctrl.view) {
                ctrl.layer.removeChildren();
                ctrl.layer.activate();
                ctrl.view.draw();
                ctrl.layer.translate(paper.view.center);
            }
        });
    }});

    Object.defineProperty(CanvasController.prototype,"redrawCurrentLayer",{writable:true,configurable:true,value:function( ) {"use strict";
        // Draw active layer
        let ctrl = this.layerControllers[this.currentLayerIndex];
        ctrl.layer.removeChildren();
        ctrl.layer.activate();
        ctrl.view.draw();
        ctrl.layer.translate(paper.view.center);
    }});

	Object.defineProperty(CanvasController.prototype,"redrawGrid",{writable:true,configurable:true,value:function( ) {"use strict";
		this.gridLayer.removeChildren();
		this.gridLayer.activate();
		this.grid.draw();
	}});

    Object.defineProperty(CanvasController.prototype,"refreshCanvas",{writable:true,configurable:true,value:function( ) {"use strict";
        this.setupGrid();
        this.redrawAllLayers();
        paper.view.draw();

    }});

	Object.defineProperty(CanvasController.prototype,"drawCanvas",{writable:true,configurable:true,value:function( ) {"use strict";
        this.redrawCurrentLayer();
		paper.view.draw();
	}});


module.exports = CanvasController;

},{"../../global/Events":14,"../../global/Util":16,"./GridView.js":8,"./RuneView.js":9,"paper":"paper"}],8:[function(require,module,exports){
var Util = require('../../global/util');
var constants = require('../../global/Const');
var Events = require('../../global/Events');
var RunePoint = require('../../models/RunePoint');

var paper = require('paper');


/* ========== Grid view ========== */

var gridPointFactory = function(point, res)  {

    let paperPoint = new paper.Point( point.render(res) );
    let path = new paper.Path.Ellipse({point: paperPoint, size: [res.x, res.y]});

    path.value = point;
    path.active = false;

    var opaque = new paper.Color(255, 0, 0, 0.2);

    path.fillColor = opaque;

    path.onMouseEnter = function (e) {
        this.fillColor = 'orange';
    };

    path.onMouseLeave = function (e) {
        this.fillColor = this.active ? 'red' : opaque;
    };

    path.onMouseDown = function (e) {
        this.fillColor = 'red';
        Events.addPoint.dispatch(e.target.value);
        Events.redraw.dispatch();
    };

    return path;
}.bind(this)


	function GridView(options) {"use strict";

    	this.res = options.res;
    	this.units = options.units;

    	this.points = [];

        let col, row;
        col = row = -this.units/2;

        for (let i = 1; i <= this.units * this.units; i++) {
            this.points.push(new RunePoint(row, col));
            if (i && i % this.units == 0) {
                row++;
                col = -this.units/2;
            } else {
                col++;
            }
        }

    }

	Object.defineProperty(GridView.prototype,"draw",{writable:true,configurable:true,value:function( ) {"use strict";

		let _this = this;

        let gridColor = new paper.Color(_this.gridColor, 100);

        let rowLines = new paper.Group();
        let colLines = new paper.Group();

        for (let i = -this.units/2; i < this.units/2; i++) {
            rowLines.addChild(this.xLine(i * this.res.y));
            colLines.addChild(this.yLine(i * this.res.x));
        }

        rowLines.translate([0, paper.view.center.y + (this.res.y/2)]);
        colLines.translate([paper.view.center.x + (this.res.x/2), 0]);

        this.xLine(paper.view.center.y, constants.RED);
        this.yLine(paper.view.center.x, constants.RED);

        this.createGridPoints();

	}});

    Object.defineProperty(GridView.prototype,"createGridPoints",{writable:true,configurable:true,value:function( ) {"use strict";

        this.gridPoints = new paper.Group();

        let _this = this;

        this.points.forEach(function(point)  {
            _this.gridPoints.addChild(gridPointFactory(point, this.res));
        }.bind(this));

        this.gridPoints.translate(paper.view.center);
    }});

	Object.defineProperty(GridView.prototype,"yLine",{writable:true,configurable:true,value:function(xLoc, color) {"use strict";
		let line = new paper.Path.Rectangle([xLoc, 0], 1, 2000);
		line.fillColor = color ? color : constants.BLUE;
        return line;
	}});

	Object.defineProperty(GridView.prototype,"xLine",{writable:true,configurable:true,value:function(yLoc, color) {"use strict";
		let line = new paper.Path.Rectangle([0, yLoc], 2000, 1);
		line.fillColor = color ? color : constants.BLUE;
        return line;
	}});


module.exports = GridView;

},{"../../global/Const":13,"../../global/Events":14,"../../global/util":19,"../../models/RunePoint":22,"paper":"paper"}],9:[function(require,module,exports){
var Events = require('../../global/Events');
var paper = require('paper');

/* ========== Tablet ========== */


    function RuneView(runeModel, grid) {"use strict";
        this.data = runeModel;
        this.grid = grid;
    }

    Object.defineProperty(RuneView.prototype,"draw",{writable:true,configurable:true,value:function( ) {"use strict";

        var runeView = this;

        runeView.path = new paper.Path({
            segments: runeView.data.currentPath.points.map(function(point, idx) {
                return runeView.createRuneSegment(
                    point,
                    idx,
                    !!runeView.data.selectedPoints[idx],
                    null
                );
            }),
            closed: runeView.data.currentPath.isClosed,
            style: (runeView.data.currentPath.isClosed ? {fillColor: 'black'} : {strokeColor: 'black'}),
            opacity: 0.6
        });

        runeView.path.runePath = true;

    }});
    
    Object.defineProperty(RuneView.prototype,"createRuneSegment",{writable:true,configurable:true,value:function(point, idx, isSelected, transform) {"use strict";

        let segment;

        let renderedPoint = new paper.Point(
            point.render(this.grid.res)
        ).add(
            new paper.Point(this.grid.res.x/2, this.grid.res.y/2)
        );

        if(point.transforms) {
            point.transforms.forEach(function(transform)  {
                console.log("T:", transform);
                renderedPoint = renderedPoint.add(new paper.Point(
                    transform[0] * this.grid.res.x,
                    transform[1] * this.grid.res.y
                ));
            }.bind(this));
        }


        if (point.isCurve) {
            segment = new paper.Segment({
                point: renderedPoint,
                handleIn: new paper.Point(point.handles[0]),
                handleOut: new paper.Point(point.handles[1])
            });
        }

        if (point.handles.length > 0 && isSelected) {
            let h1 = new paper.Path.Circle(new paper.Point(point.handles[1]), 5);
            let h2 = new paper.Path.Circle(new paper.Point(point.handles[1]), 5);
            h1.strokeColor = 'red';
        }

        let path = new paper.Path.Circle(renderedPoint, 8);
        path.isHandle = true;
        path.fillColor = 'white';
        path.value = { idx: idx, point: point};
        path.isSelected = isSelected || false;
        path.strokeWidth = 4;
        path.strokeColor = path.isSelected ? 'red' : false;

        path.onMouseDown = function(e) {
            e.event.stopImmediatePropagation();
            this.isSelected = !this.isSelected;
            Events.selectPoint.dispatch(this.isSelected, e.target.value);
            Events.redraw.dispatch();
        }

        return segment || renderedPoint;
    }});


module.exports = RuneView;

},{"../../global/Events":14,"paper":"paper"}],10:[function(require,module,exports){
'use strict';

var Util = require('../../global/Util');
var React = require('react');
var Draggable = require('react-draggable');

var React = require('react');
var Events = require('../../global/Events');



    function PanelController(app) {
        this.app = app;
        this.init();
    }

    Object.defineProperty(PanelController.prototype,"init",{writable:true,configurable:true,value:function( ) {

        var panelController = this;

        var PanelWrapper = React.createClass({displayName: "PanelWrapper",
            handleStart: function () {

            },
            handleDrag: function () {

            },
            toggleShow: function () {
                this.setState({show: !this.state.show});
            },
            getInitialState: function () {
                return { show : false };
            },
            render: function() {
                var offsetY = this.props.offset * 50;
                var offsetX = this.props.offset * 5;
                return (
                    React.createElement("div", {className: "panel"}, 
                        React.createElement("div", {className: "handle", onClick: this.toggleShow}, 
                             this.props.options.title, 
                            React.createElement("span", {className: "toggle"}, this.state.show ? '-' : '+')
                        ), 
                         this.state.show ? 
                        React.createElement("div", {className: "panel-content"}, 
                             this.props.children
                        ) : null
                    )
                );
            }
        });

        var Panels = React.createClass({displayName: "Panels",
            render: function() {
                return (
                    React.createElement("div", null, 
                        
                            this.props.data.map(function(panel, idx) {
                                var Component = panel.panel;
                                return React.createElement(PanelWrapper, {offset: idx, options: {title : panel.title}}, 
                                     React.createElement(Component, {data: panel.data})
                                 );
                            })
                        
                    )
                );
            }
        });

        // Plugin panels
        let panels = React.render(
            React.createElement(Panels, {data: panelController.app.plugins}),
            document.getElementById('rune-panels')
        );

        Events.reloadPanels.add(function()  {
            panels.setState({'data' : panelController.app.plugins});
        });


    }});

    Object.defineProperty(PanelController.prototype,"updateProperties",{writable:true,configurable:true,value:function(model) {

    }});


// <Draggable
//     start={{x: offsetX + 800, y: offsetY }}
//     onStart={this.handleStart}
//     handle=".handle"
//     >
//     <div className="panel">
//         <div className="handle">{ this.props.options.title }<span className="toggle">-</span></div>
//         <div className="panel-content">
//             { this.props.children }
//         </div>
//     </div>
// </Draggable>


module.exports = PanelController;

},{"../../global/Events":14,"../../global/Util":16,"react":"react","react-draggable":1}],11:[function(require,module,exports){
let Events = require('../../global/Events');

var React = require('react');
var paper = require('paper');

function ActionBar(app) {

	var actionBar = this;
	actionBar.app = app;

	this.actions = [
		{
			id : "save",
			title : "Save",
			action : function(e) {
				e.preventDefault();
				// debugger;
				actionBar.app.data.save();

			}
		},
		{
			id : "clear",
			title : "Clear",
			action: function(e) {
				e.preventDefault();
				// Util.dispatchRuneEvent("clearGridPoints");
                Events.clearPoints.dispatch();
			}
		},
		{
			id: "grid",
			title: "Preview",
			action: function(e) {
				e.preventDefault();
                Events.display.dispatch('preview');
			}
		},
		{
			id: "rune",
			title: "Add rune",
			action: function(e) {
				e.preventDefault();
				app.tablet.addRune();
			}
		},
		{
			id: "svg",
			title: "Export as SVG",
			action: function(e) {
				e.preventDefault();
                actionBar.app.canvas.displayMode = 'preview';
                console.log("here");
				var svgString = paper.project.exportSVG({asString:true, layerIndex: 1});
				var url = "data:image/svg+xml;utf8," + encodeURIComponent(svgString);
				var link = document.createElement("a");
                console.log("and here");
				link.download = 'rune_export.svg';
				link.href = url;
				link.click();
                actionBar.app.canvas.displayMode = 'working';
			}
		}
	];
	this.render();
	this.addEvents();
}

ActionBar.prototype.addEvents = function(container) {
	for (var i=0; i < this.actions.length; i++) {
		var action = this.actions[i];
		document.querySelectorAll('[data-action="' + action.id + '"]')[0].onclick = action.action;
	}
};

ActionBar.prototype.render = function() {
	console.log("this is working");

	var actions = this.actions;

	var ActionBarComponent = React.createClass({displayName: "ActionBarComponent",
	    render: function() {
	        return (
				React.createElement("ul", null, 
					
						this.props.actions.map(function(action, i) {
							return React.createElement("li", null, React.createElement("a", {className: "action", "data-action":  action.id},  action.title));
						})
					
				)
	        );
	    }
	});

	React.render(
	    React.createElement(ActionBarComponent, {actions: actions}),
	    document.getElementById('rune-actionbar')
	);
};

module.exports = ActionBar;

},{"../../global/Events":14,"paper":"paper","react":"react"}],12:[function(require,module,exports){
var ActionBar = require('./ActionBarController.jsx');
var PanelController = require('./../panels/PanelController.jsx');

function WorkSpaceController(app) {

	this.actionBar = new ActionBar(app);
	this.panels = new PanelController(app);
}

WorkSpaceController.prototype = {
	constructor: WorkSpaceController,
}

module.exports = WorkSpaceController;

},{"./../panels/PanelController.jsx":10,"./ActionBarController.jsx":11}],13:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 280,
	BLUE:  '#41d4f3',
    RED: '#ff0000'
};

},{}],14:[function(require,module,exports){
// var Util = require('./Util');

// class RuneEvents {
//     dispatch () {

//     }

//     listen (Event, callback) {

//     }
// }
    // dispatchRuneEvent: function(name, data) {
    //     var runeEvent = new CustomEvent('runeEvent', { 'detail' : { 'event' : name, 'data' :  data }});
    //     document.dispatchEvent(runeEvent);
    // },
// Event listeners
// function Events(app) {

// 	this.app = app;

// 	var events = this;

// 	this.eventHandlers = {
// 		addPoint : function (data) {
// 			events.app.data.addPoint(data);
// 			events.app.canvas.draw();
// 		},
// 		selectPoint: function (data) {
// 			if(data[0]) {
// 				events.app.data.selectPoint(data[1]);
// 			} else {
//                 events.app.data.deselectPoint(data[1]);
// 			}
//             console.log("Selected points:");
// 			console.log(app.data.activeRune.selectedPoints);
//             events.app.canvas.draw();
// 		},
// 		clearGridPoints : function (e) {
// 			events.app.data.clearRune();
// 			events.app.canvas.draw();
// 		},
// 		preview: function (e) {
// 			events.app.canvas.displayMode = 'preview';
// 		},
// 		deselectAll: function (e) {
// 			events.app.data.activeRune.selectedPoints = [];
// 			events.app.canvas.draw();
// 		},
//         refreshCanvas: function () {
//             events.app.canvas.setupGrid();
//         },
//         redraw : function () {
//             events.app.canvas.draw();
//         }
// 	}
// }

// Events.prototype = {
// 	constructor: Events,
// 	init: function() {
// 		var events = this;

// 		document.addEventListener('runeEvent', function(e) {
// 			console.log('Event received: ' + e.detail.event);
// 			events.eventHandlers[e.detail.event](e.detail.data);

// 		});

//         // Needs fixing
// 		document.addEventListener('keydown', function(e) {
//             if(e.target.tagName !== 'INPUT') {
//     			switch(e.keyCode) {
//     				case 8: //delete
//     					e.preventDefault();
//     					events.app.data.deleteSelected();
//     					events.app.canvas.draw();
//     					util.dispatchRuneEvent('deselectAll');

//     				break;
//     			}
//             }
// 		});
// 	}
// }

let signals = require('signals');

let events = [
    'addPoint',
    'addPath',
    'selectPoint',
    'deleteSelected',
    'clearPoints',
    'display',
    'deselectAll',
    'refreshCanvas',
    'redraw',
    'reloadPanels'
];

Events = {};

events.forEach(function(event)  {
    Events[event] = new signals.Signal();
});

module.exports = Events;

},{"signals":5}],15:[function(require,module,exports){
'use strict';

let Events = require('./Events');

const MODIFIERS = [
    'shiftKey',
    'ctrlKey'
];

const keyMap = {
    delete: 8,
    tab: 9,
    enter: 13,
    esc: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40
};

let Keys = {
    key: keyMap,
    maps: {},
    mapKey:function (key, callback) {
        if (this.maps[key]) {
            throw new Error('Key already mapped, soz bro.');
        }
        this.maps[key] = callback;
    },
    init:function () {
        let _this = this;
        document.addEventListener('keydown', function(e) {
            console.log("Key down: ", e.keyCode);
            let hasModifier = MODIFIERS.find(function(mod)  {return e[mod];});

            let ref = ((hasModifier || '') + "+" + e.keyCode);

            if (_this.maps[ref] && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                _this.maps[ref]();
            }
        });

        this.mapKey(this.key.delete, function()  {
            Events.deleteSelected.dispatch();
        });

        return this;
    }
};

module.exports = Keys.init();

},{"./Events":14}],16:[function(require,module,exports){
/* ========== Utilities ========== */

function Util(){"use strict";}
	Object.defineProperty(Util,"getIndices",{writable:true,configurable:true,value:function(points, gridPoints) {"use strict";
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	}});

	Object.defineProperty(Util,"object",{writable:true,configurable:true,value:function(o) {"use strict";
        function F() {}
        F.prototype = o;
        return new F();
    }});

    Object.defineProperty(Util,"getLocalData",{writable:true,configurable:true,value:function(ref) {"use strict";
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : null;
    }});


module.exports = Util;

},{}],17:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 280,
	BLUE:  '#41d4f3',
    RED: '#ff0000'
};

},{}],18:[function(require,module,exports){
'use strict';

let Events = require('./Events');

const MODIFIERS = [
    'shiftKey',
    'ctrlKey'
];

const keyMap = {
    delete: 8,
    tab: 9,
    enter: 13,
    esc: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40
};

let Keys = {
    key: keyMap,
    maps: {},
    mapKey:function (key, callback) {
        if (this.maps[key]) {
            throw new Error('Key already mapped, soz bro.');
        }
        this.maps[key] = callback;
    },
    init:function () {
        let _this = this;
        document.addEventListener('keydown', function(e) {
            console.log("Key down: ", e.keyCode);
            let hasModifier = MODIFIERS.find(function(mod)  {return e[mod];});

            let ref = ((hasModifier || '') + "+" + e.keyCode);

            if (_this.maps[ref] && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                _this.maps[ref]();
            }
        });

        this.mapKey(this.key.delete, function()  {
            Events.deleteSelected.dispatch();
        });

        return this;
    }
};

module.exports = Keys.init();

},{"./Events":14}],19:[function(require,module,exports){
/* ========== Utilities ========== */

function Util(){"use strict";}
	Object.defineProperty(Util,"getIndices",{writable:true,configurable:true,value:function(points, gridPoints) {"use strict";
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	}});

	Object.defineProperty(Util,"object",{writable:true,configurable:true,value:function(o) {"use strict";
        function F() {}
        F.prototype = o;
        return new F();
    }});

    Object.defineProperty(Util,"getLocalData",{writable:true,configurable:true,value:function(ref) {"use strict";
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : null;
    }});


module.exports = Util;

},{}],20:[function(require,module,exports){
var TabletModel = require('./TabletModel');
var Events = require('../global/Events');
var _ = require('lodash');

/* ========== Data ========== */


    function DataController(tabletModel) {"use strict";

        this.tablet = new TabletModel(tabletModel);
        this.currentRune = 0;

        Events.addPoint.add(this.addPoint.bind(this));
        Events.selectPoint.add(this.selectPoint.bind(this));
        Events.clearPoints.add(this.clearRune.bind(this));
        Events.addPath.add(this.addPath.bind(this));

    }

    Object.defineProperty(DataController.prototype,"activeRune",{configurable:true,get:function( ) {"use strict";
        return this.tablet.runes[this.currentRune];
    }});

    Object.defineProperty(DataController.prototype,"save",{writable:true,configurable:true,value:function( ) {"use strict";
        this.tablet.data.runes = this.tablet.runes;
        localStorage["runeData"] = JSON.stringify(this.tablet.data);
    }});

    Object.defineProperty(DataController.prototype,"addRune",{writable:true,configurable:true,value:function( ) {"use strict";
        this.tablet.runes.push(new RuneData(null));
    }});

    Object.defineProperty(DataController.prototype,"addPoint",{writable:true,configurable:true,value:function(gridRef) {"use strict";
        this.activeRune.addPoint(gridRef);
        Events.deselectAll.dispatch();
    }});

    Object.defineProperty(DataController.prototype,"addPath",{writable:true,configurable:true,value:function( ) {"use strict";
        this.activeRune.addPath();
        Events.redraw.dispatch();
    }});

    Object.defineProperty(DataController.prototype,"addTransformToSelected",{writable:true,configurable:true,value:function(transform) {"use strict";
        var rune = this.activeRune;
        Object.keys(rune.selectedPoints).forEach(function(key)  {
            rune.currentPath.points[key].transforms.push(transform);
        });
        Events.redraw.dispatch();
    }});

    Object.defineProperty(DataController.prototype,"clearRune",{writable:true,configurable:true,value:function() {"use strict";
        this.activeRune.clearPaths().currentPointIndex = 0;
        Events.redraw.dispatch();
    }});

    Object.defineProperty(DataController.prototype,"updateGrid",{writable:true,configurable:true,value:function( ) {"use strict";
        // var rune = this.getactiveRune();
        // rune.letter.gridPoints.forEach(function(entry, i) {
        // });
    }});

    Object.defineProperty(DataController.prototype,"selectPoint",{writable:true,configurable:true,value:function(isSelected, point) {"use strict";
        this.activeRune.selectHandler(isSelected, point);
    }});


module.exports = DataController;

},{"../global/Events":14,"./TabletModel":23,"lodash":"lodash"}],21:[function(require,module,exports){
var RunePoint = require('./RunePoint');

/* ========== Rune Model ========== */


    function RunePath( ) {"use strict";
        this.points = [];
        this.isClosed = false;
    }



    function RuneModel(data) {"use strict";

        this.paths = data && data.paths || [new RunePath()];
        this.selectedPoints = data && data.selectedPoints || {};
        this.currentPointIndex = data && data.currentPointIndex || 0;
        this.currentPathIndex = data && data.currentPathIndex || 0;
        this.reverseAdd = false;

        // Events.
    }

    Object.defineProperty(RuneModel.prototype,"clearPaths",{writable:true,configurable:true,value:function( )  {"use strict";
        this.paths = [new RunePath()];
        Events.reloadPanels.dispatch();
        return this;
    }});

    Object.defineProperty(RuneModel.prototype,"selectHandler",{writable:true,configurable:true,value:function(isSelected, point) {"use strict";
        console.log(this);
        if(isSelected) {
            this.selectedPoints[point.idx] = point.point;
            this.currentPointIndex = point.idx;
        } else {
            delete this.selectedPoints[point.idx];
        }
        Events.reloadPanels.dispatch();
        console.log("Updated selected", this.selectedPoints);
    }});

    Object.defineProperty(RuneModel.prototype,"addPath",{writable:true,configurable:true,value:function( ) {"use strict";
        this.paths.push(new RunePath());
        this.currentPathIndex++;

        debugger;
    }});

    Object.defineProperty(RuneModel.prototype,"addPoint",{writable:true,configurable:true,value:function(gridRef) {"use strict";
        if (this.selectedPoints.length) {
            if (this.selectedPoints[0] == 0 ) {
                this.reverseAdd = true;
            } else if (this.selectedPoints[0] == this.currentPath.length-1) {
                this.reverseAdd = false;
            }
        }
        if(this.reverseAdd) {
            this.currentPath.points.unshift(new RunePoint(gridRef.x, gridRef.y));
        } else {
            this.currentPointIndex++;
            this.currentPath.points.splice(this.currentPointIndex, 0, new RunePoint(gridRef.x, gridRef.y));
        }
        return this;
    }});

    Object.defineProperty(RuneModel.prototype,"currentPath",{configurable:true,get:function() {"use strict";
        return this.paths[this.currentPathIndex];
    }});

    Object.defineProperty(RuneModel.prototype,"currentPath",{configurable:true,set:function(obj) {"use strict";
        this.paths[this.currentPathIndex] = obj;
    }});

    Object.defineProperty(RuneModel.prototype,"currentPoint",{configurable:true,get:function() {"use strict";
        return this.paths[this.currentPathIndex][this.currentPointIndex];
    }});

    Object.defineProperty(RuneModel.prototype,"currentPoint",{configurable:true,set:function(arr) {"use strict";
        this.currentPathIndex = arr[0];
        this.currentPointIndex = arr[1];
    }});

    Object.defineProperty(RuneModel.prototype,"deleteSelected",{writable:true,configurable:true,value:function( ) {"use strict";
        // FIX THIS
        // var rune = this.activeRune;
        // this.currentPath = this.currentPath.filter(function(value, idx) {
            // return !~rune.selectedPoints.indexOf(idx);
        // });
    }});

       
           
     

       
          
     


       
          
     

       
          
     

       
           
     


module.exports = RuneModel;

},{"./RunePoint":22}],22:[function(require,module,exports){
/* ========== Point Model ========== */


    function BasePoint(x, y) {"use strict";
        this.x = x;
        this.y = y;
    }


for(var BasePoint____Key in BasePoint){if(BasePoint.hasOwnProperty(BasePoint____Key)){RunePoint[BasePoint____Key]=BasePoint[BasePoint____Key];}}var ____SuperProtoOfBasePoint=BasePoint===null?null:BasePoint.prototype;RunePoint.prototype=Object.create(____SuperProtoOfBasePoint);RunePoint.prototype.constructor=RunePoint;RunePoint.__superConstructor__=BasePoint;

    function RunePoint(x, y) {"use strict";
        if (typeof x === 'object') {
            BasePoint.call(this,x.x, x.y);
            this.transforms = x.transforms || [];
            this.handles = x.handles || [];
            this.isCurve = x.isCurve || false;
        } else {
            BasePoint.call(this,x, y);
            this.transforms = [];
            this.handles = [];
            this.isCurve = false;
        }
    }

    Object.defineProperty(RunePoint.prototype,"addHandles",{writable:true,configurable:true,value:function( ) {"use strict";
        this.handles = [new BasePoint(), new BasePoint()];
    }});

    Object.defineProperty(RunePoint.prototype,"render",{writable:true,configurable:true,value:function(res) {"use strict";
        return [
            this.x * res.x, 
            this.y * res.y
        ]; 
    }});


module.exports = RunePoint;

},{}],23:[function(require,module,exports){
var constants = require('../global/const');
var RunePoint = require('./RunePoint');
var RuneModel = require('./RuneModel');

/* ========== Tablet Model ========== */


    function TabletModel(data) {"use strict";

        var defaultUnits = 10;

        defaultUnits = defaultUnits % 2 == 0  ? defaultUnits : defaultUnits++;

        var defaultRes = constants.CANVAS_SIZE / defaultUnits;

        var tablet = this;

        if (data) {
            data.runes.forEach(function(rune, i, runes) {
                rune.paths.forEach(function(path, i2, paths) {
                    path.points.forEach(function(point, i3, points) {
                        data.runes[i].paths[i2].points[i3] = new RunePoint(point);
                    });
                });
            });
        }

        tablet.data = data || {
            gridOptions: {
                units: defaultUnits,
                res: {
                    x: defaultRes,
                    y: defaultRes
                }
            },
            renderedSVG: '',
            currentPathIndex: 0
        };

        tablet.runes = [];

        if(data) {
            data.runes.forEach(function(entry) {
                tablet.runes.push(new RuneModel(entry));
            });
        } else {
            tablet.runes.push(new RuneModel(null));
        }
    }

    Object.defineProperty(TabletModel.prototype,"gridOptions",{configurable:true,get:function( ) {"use strict";
         return this.data.gridOptions;
    }});
       
          
     


module.exports = TabletModel;

},{"../global/const":17,"./RuneModel":21,"./RunePoint":22}],24:[function(require,module,exports){
'use strict';

var paper = require('paper');
var React = require('react');

module.exports = function(data) {

    console.log(data);

    var transformPoints = function () {
            var points = data.selectedPoints;

            console.log(points);
            console.log(points.length);

            if(points.length !== 4) {
                console.log("Not the right no of selected points");
                return;
            }

            console.log("Going strong!");


            var testPath = new paper.Path();
            testPath.strokeColor = 'red';

            /* ------ Get initial vars ------ */

            // console.log(points);

            var midPoint = points[0].getMid(points[2]);

            // Show mid circle
            var circle = new paper.Path.Circle(midPoint, res / 2);
            circle.strokeColor = 'black'

            /* ------ First triangulation ------ */

            // Hypothesis to midpoint
            var t1_hyp = points[2].getDistance(midPoint);

            // Adj 
            var t1_adj = res / 2;

            var t1_phi = 90 - trigUtil.radToDeg(Math.acos( t1_adj / t1_hyp));

            // var vec = new paper.Point(points[2]);
            var vec = new paper.Point();

            vec.angle = (90 - trigUtil.radToDeg( trigUtil.getAngle(points[0], points[2]))) - t1_phi;

            var side = trigUtil.getSize(null, t1_adj, t1_hyp);

            vec.length = side;

            var tangentPoint = points[2].subtract(vec);

            testPath.moveTo(points[2]);
            testPath.lineTo(tangentPoint);

            /* ------ Second triangulation ------ */

            var otherPoint = new paper.Point(points[0].x, points[2].y);

            // Distance between points[2] and 0 on y axis
            var t2_adj = otherPoint.getDistance(points[2]);

            var t2_hyp = t2_adj / Math.cos( trigUtil.degToRad(vec.angle) );

            // New length for vector (reflects distance to new point[3]
            vec.length = Math.abs(t2_hyp) - vec.length;

            // var newPoint = points[2].subtract(finalVector.length);

            var newPoint3 = tangentPoint.subtract(vec);

            testPath.lineTo(newPoint3);

            // var newPoint3 = otherPoint.subtract(finalVector);

            var finalMeasure = points[0].getDistance(newPoint3);

            console.log("Distance" + finalMeasure);

            // points[3].y = points[0].y + finalMeasure;
            // points[1].y = points[2].y - finalMeasure;

            // app.tablet.getactiveRune().letter.transforms = {};

            // app.tablet.getactiveRune().letter.transforms[originalPoints[3]] = [-90, -finalMeasure];
            // app.tablet.getactiveRune().letter.transforms[originalPoints[1]] = [90, finalMeasure];

            // return newPoints;
    }

    return {
        title: 'Weight Transform',
        icon: '',
        panel: React.createClass({displayName: "panel",
            getInitialState : function() {
                return {data: data.gridOptions };
            },
            triggerTransform: function() {
                console.log("Doing the 4pt");
                transformPoints();
            },
            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("button", {onClick: this.triggerTransform}, "4pt Transform")
                    )
                );
            }
        })
    }
}

},{"paper":"paper","react":"react"}],25:[function(require,module,exports){
'use strict';

var React = require('react');
var Events = require('../global/Events');

module.exports = function(data) {
    return {
        title: 'Grid',
        panel: React.createClass({displayName: "panel",
            getInitialState : function() {
                return {data: data.gridOptions };
            },
            updateData: function(e) {
                var x = this.refs.resX.getDOMNode().value;
                var y = this.refs.resY.getDOMNode().value;
                var units = this.refs.units.getDOMNode().value;
                this.state.data.res.x = +x;
                this.state.data.res.y = +y;
                this.state.data.units = +units;
                // this.forceUpdate();
                Events.refreshCanvas.dispatch();
            },
            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("label", null, "Resolution:"), 
                        React.createElement("input", {type: "text", ref: "resX", defaultValue:  this.state.data.res.x}), 
                        React.createElement("input", {type: "text", ref: "resY", defaultValue:  this.state.data.res.y}), 
                        React.createElement("label", null, "Units"), 
                        React.createElement("input", {type: "text", ref: "units", defaultValue: this.state.data.units}), 
                        React.createElement("button", {onClick: this.updateData}, "Update")
                    )
                );
            }
        })
    };
}

},{"../global/Events":14,"react":"react"}],26:[function(require,module,exports){
'use strict';

let React = require('react');
let Events = require('../global/Events');

module.exports = function(data) {
    return {
        title: 'Inspect path',
        panel: React.createClass({displayName: "panel",
            getInitialState: function () {
                return {path: data.path};
            },
            changeHandler: function () {
                this.state.path.isClosed = !this.state.path.isClosed;
                this.setState({path: this.state.path});
                Events.redraw.dispatch();
            },
            addPath: function()  {
                console.log("Adding path");
                Events.addPath.dispatch();
            },
            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("span", {onClick: this.addPath}, "New path"), 
                        React.createElement("label", {for: "closedPath"}, 
                            this.state.path.points.map(function(p)  {return ("[" + p.x + "," + p.y + "]");}).join(' '), 
                            React.createElement("input", {
                            type: "checkbox", 
                            id: "closedPath", 
                            defaultValue: this.state.path.isClosed, 
                            checked: this.state.path.isClosed, 
                            onClick: this.changeHandler}), 
                            "Closed"
                        )
                    )
                );
            }
        })
    };
}

},{"../global/Events":14,"react":"react"}],27:[function(require,module,exports){
'use strict';

let React = require('react');
let Events = require('../global/Events');

let PointData = React.createClass({displayName: "PointData",
    getInitialState: function () {
        return {point: this.props.point};
    },
    changeHandler: function (point) {
        point.isCurve = !point.isCurve;
        point.handles = point.isCurve ? [[-132, 200], [100, -100]] : [];
        this.setState({point: point});
        Events.redraw.dispatch();
    },
    componentWillReceiveProps : function (nextProps) {
      return {point: nextProps};
    },
    render: function() {
        let x = this.props.point.x;
        let y = this.props.point.y;
        return (
            React.createElement("li", null, 
                React.createElement("small", null, "x: ", x, ", y:", y), 
                this.state.point.transforms, 
                React.createElement("label", {for: this.state.point.x+this.state.point.y}, 
                React.createElement("input", {
                    type: "checkbox", 
                    id: this.state.point.x+this.state.point.y, 
                    defaultValue: this.state.point.isCurve, 
                    checked: this.state.point.isCurve, 
                    onClick: this.changeHandler.bind(this, this.state.point)}), "isCurve"
                ), 
                
                    this.state.point.isCurve ? 
                        React.createElement("div", null, 
                            "Handle", 
                            React.createElement("input", {
                                type: "text", 
                                defaultValue: this.state.point.handles})
                        )
                    : null
                
            )
        );
    }
});


module.exports = function(data) {
    return {
        data: data.selectedPoints,
        title: 'Inspect point',
        collapsed: false,
        panel: React.createClass({displayName: "panel",
            // getInitialState : function() {
            //     let _this = this;
            //     Events.selectPoint.add(() => {
            //         this.setState(data);
            //     });
            //     return { points: data.selectedPoints };
            // },
            // getInitialState : function() {
            //     return {"data" : data};
            // },
            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("ul", null, 
                            
                                Object.keys(this.props.data).map( function(key)  {
                                    return React.createElement(PointData, {point: this.props.data[key]})
                                }.bind(this))
                            
                        )
                    )
                );
            }
        })
    };
}

},{"../global/Events":14,"react":"react"}],28:[function(require,module,exports){
'use strict';

var React = require('react');

module.exports = function(data) {
    return {
        title: 'Layers',
        panel: React.createClass({displayName: "panel",
            getInitialState : function() {
                return {layers: data.layers };
            },
            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("h4", null, "Layers"), 
                        React.createElement("ul", null, 
                            
                                this.state.layers.map(function(layer) {
                                    return React.createElement("li", null, layer.name)
                                })
                            
                        )
                    )
                );
            }
        })
    };
}

},{"react":"react"}],29:[function(require,module,exports){
'use strict';

var React = require('react');
var Keys = require('../global/Keys');

module.exports = function(exposedData) {

    Object.keys({
        'up' : Keys.key.up,
        'down' : Keys.key.down,
        'left' : Keys.key.left,
        'right' : Keys.key.right,
    }).forEach(function(key)  {
        Keys.mapKey(("shiftKey+" + Keys.key[key]), function()  {
            exposedData.addTransformToSelected(directionVectors[key]);
        });
    });

    var directionVectors = {
        'up' : [0,-1],
        'down': [0,1],
        'left' : [-1,0],
        'right' : [1,0]
    };

    var TranslateLink = React.createClass({displayName: "TranslateLink",
        translate: function () {
            exposedData.addTransformToSelected(directionVectors[this.props.direction]);
        },
        render: function() {
            return React.createElement("span", {
                onClick: this.translate, 
                "data-direction": "{this.props.direction}", 
                className: "tool"}, 
                    this.props.glyph
                )
        }
    });

    return {
        title: 'Nudge',
        icon: '',
        panel: React.createClass({displayName: "panel",
            render: function () {
                return  React.createElement("div", null, 
                            React.createElement(TranslateLink, {direction: "left", glyph: "←"}), 
                            React.createElement(TranslateLink, {direction: "right", glyph: "→"}), 
                            React.createElement(TranslateLink, {direction: "down", glyph: "↑"}), 
                            React.createElement(TranslateLink, {direction: "up", glyph: "↓"})
                        );
            }
        })
    };
};

},{"../global/Keys":15,"react":"react"}],30:[function(require,module,exports){
'use strict';

var React = require('react');

module.exports = function(exposedData) {

    return {
        title: 'Randomise points',
        icon: '',
        panel: React.createClass({displayName: "panel",
            getRandom: function() {
                return Math.floor((Math.random() * 6)) - 3;
            },
            randomise: function() {
                console.log("thing happening");
                return exposedData.addTransformToSelected([
                    this.getRandom(),
                    this.getRandom()
                ]);
            },
            render: function () {
                return React.createElement("span", {className: "tool", onClick: this.randomise}, "R");
            }
        })
    };
};

},{"react":"react"}],31:[function(require,module,exports){
'use strict';

var React = require('react');

module.exports = function(exposedData) {

    var shapes = [{},{},{}];

    return {
        title: 'Shapes',
        icon: '',
        panel: React.createClass({displayName: "panel",
            render: function () {
                return  React.createElement("div", null, 
                                shapes.map(function(entry, idx) {
                                    return React.createElement("span", {className: "tool"});
                                })
                            
                        );
            }
        })
    };
};

},{"react":"react"}],32:[function(require,module,exports){
module.exports = function(exposedData) {
    return [
    	require('./InspectPoint.jsx')(exposedData),
    	require('./InspectPath.jsx')(exposedData),
        require('./GridManager.jsx')(exposedData),
        require('./Nudge.jsx')(exposedData),
        require('./LayerManager.jsx')(exposedData),
        require('./PointRandomise.jsx')(exposedData),
        require('./Shapes.jsx')(exposedData),
        require('./FourPointWeightTransform.jsx')(exposedData)
    ];
};

},{"./FourPointWeightTransform.jsx":24,"./GridManager.jsx":25,"./InspectPath.jsx":26,"./InspectPoint.jsx":27,"./LayerManager.jsx":28,"./Nudge.jsx":29,"./PointRandomise.jsx":30,"./Shapes.jsx":31}]},{},[6]);
