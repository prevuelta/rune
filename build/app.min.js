(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/draggable');

},{"./lib/draggable":2}],2:[function(require,module,exports){
'use strict';

var React = require('react');
var emptyFunction = function(){};
var assign = require('object-assign');
var classNames = require('classnames');
var browserPrefix = require('./getPrefix')();

//
// Helpers. See Element definition below this section.
//

function createUIEvent(draggable) {
  // State changes are often (but not always!) async. We want the latest value.
  var state = draggable._pendingState || draggable.state;
  return {
    node: draggable.getDOMNode(),
    position: {
      top: state.clientY,
      left: state.clientX
    }
  };
}

function canDragX(draggable) {
  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
}

function canDragY(draggable) {
  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
}

function isFunction(func) {
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array, callback) {
  for (var i = 0, length = array.length; i < length; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}

var matchesSelectorFunc = '';
function matchesSelector(el, selector) {
  if (!matchesSelectorFunc) {
    matchesSelectorFunc = findInArray([
      'matches',
      'webkitMatchesSelector',
      'mozMatchesSelector',
      'msMatchesSelector',
      'oMatchesSelector'
    ], function(method){
      return isFunction(el[method]);
    });
  }

  return el[matchesSelectorFunc].call(el, selector);
}

/**
 * simple abstraction for dragging events names
 * */
var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    end: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    end: 'mouseup'
  }
};

// Default to mouse events
var dragEventFor = eventsFor.mouse;

/**
 * get {clientX, clientY} positions of control
 * */
function getControlPosition(e) {
  var position = (e.targetTouches && e.targetTouches[0]) || e;
  return {
    clientX: position.clientX,
    clientY: position.clientY
  };
}

function addEvent(el, event, handler) {
  if (!el) { return; }
  if (el.attachEvent) {
    el.attachEvent('on' + event, handler);
  } else if (el.addEventListener) {
    el.addEventListener(event, handler, true);
  } else {
    el['on' + event] = handler;
  }
}

function removeEvent(el, event, handler) {
  if (!el) { return; }
  if (el.detachEvent) {
    el.detachEvent('on' + event, handler);
  } else if (el.removeEventListener) {
    el.removeEventListener(event, handler, true);
  } else {
    el['on' + event] = null;
  }
}

function outerHeight(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height += int(computedStyle.borderTopWidth);
  height += int(computedStyle.borderBottomWidth);
  return height;
}

function outerWidth(node) {
  // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width += int(computedStyle.borderLeftWidth);
  width += int(computedStyle.borderRightWidth);
  return width;
}
function innerHeight(node) {
  var height = node.clientHeight;
  var computedStyle = window.getComputedStyle(node);
  height -= int(computedStyle.paddingTop);
  height -= int(computedStyle.paddingBottom);
  return height;
}

function innerWidth(node) {
  var width = node.clientWidth;
  var computedStyle = window.getComputedStyle(node);
  width -= int(computedStyle.paddingLeft);
  width -= int(computedStyle.paddingRight);
  return width;
}

function isNum(num) {
  return typeof num === 'number' && !isNaN(num);
}

function int(a) {
  return parseInt(a, 10);
}

function getBoundPosition(draggable, clientX, clientY) {
  var bounds = JSON.parse(JSON.stringify(draggable.props.bounds));
  var node = draggable.getDOMNode();
  var parent = node.parentNode;

  if (bounds === 'parent') {
    var nodeStyle = window.getComputedStyle(node);
    var parentStyle = window.getComputedStyle(parent);
    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
    bounds = {
      left: -node.offsetLeft + int(parentStyle.paddingLeft) +
            int(nodeStyle.borderLeftWidth) + int(nodeStyle.marginLeft),
      top: -node.offsetTop + int(parentStyle.paddingTop) +
            int(nodeStyle.borderTopWidth) + int(nodeStyle.marginTop),
      right: innerWidth(parent) - outerWidth(node) - node.offsetLeft,
      bottom: innerHeight(parent) - outerHeight(node) - node.offsetTop
    };
  }

  // Keep x and y below right and bottom limits...
  if (isNum(bounds.right)) clientX = Math.min(clientX, bounds.right);
  if (isNum(bounds.bottom)) clientY = Math.min(clientY, bounds.bottom);

  // But above left and top limits.
  if (isNum(bounds.left)) clientX = Math.max(clientX, bounds.left);
  if (isNum(bounds.top)) clientY = Math.max(clientY, bounds.top);

  return [clientX, clientY];
}

function snapToGrid(grid, pendingX, pendingY) {
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}

// Useful for preventing blue highlights all over everything when dragging.
var userSelectStyle = ';user-select: none;';
if (browserPrefix) {
  userSelectStyle += '-' + browserPrefix.toLowerCase() + '-user-select: none;';
}

function addUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style + userSelectStyle);
}

function removeUserSelectStyles(draggable) {
  if (!draggable.props.enableUserSelectHack) return;
  var style = document.body.getAttribute('style') || '';
  document.body.setAttribute('style', style.replace(userSelectStyle, ''));
}

function createCSSTransform(style) {
  // Replace unitless items with px
  var x = style.x + 'px';
  var y = style.y + 'px';
  var out = {transform: 'translate(' + x + ',' + y + ')'};
  // Add single prefixed property as well
  if (browserPrefix) {
    out[browserPrefix + 'Transform'] = out.transform;
  }
  return out;
}

function createSVGTransform(args) {
  return 'translate(' + args.x + ',' + args.y + ')';
}

//
// End Helpers.
//

//
// Define <Draggable>
//

module.exports = React.createClass({
  displayName: 'Draggable',

  propTypes: {
    /**
     * `axis` determines which axis the draggable can move.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     *
     * Defaults to 'both'.
     */
    axis: React.PropTypes.oneOf(['both', 'x', 'y']),

    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: React.PropTypes.oneOfType([
      React.PropTypes.shape({
        left: React.PropTypes.Number,
        right: React.PropTypes.Number,
        top: React.PropTypes.Number,
        bottom: React.PropTypes.Number
      }),
      React.PropTypes.oneOf(['parent', false])
    ]),

    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: React.PropTypes.bool,

    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: React.PropTypes.string,

    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *            <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: React.PropTypes.string,

    /**
     * `grid` specifies the x and y that dragging should snap to.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable grid={[25, 25]}>
     *                   <div>I snap to a 25 x 25 grid</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    grid: React.PropTypes.arrayOf(React.PropTypes.number),

    /**
     * `start` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      var App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable start={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    start: React.PropTypes.shape({
      x: React.PropTypes.number,
      y: React.PropTypes.number
    }),

    /**
     * `moveOnStartChange`, if true (default false) will move the element if the `start`
     * property changes.
     */
    moveOnStartChange: React.PropTypes.bool,


    /**
     * `zIndex` specifies the zIndex to use while dragging.
     *
     * Example:
     *
     * ```jsx
     *   var App = React.createClass({
     *       render: function () {
     *           return (
     *               <Draggable zIndex={100}>
     *                   <div>I have a zIndex</div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    zIndex: React.PropTypes.number,

    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStart: React.PropTypes.func,

    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onDrag: React.PropTypes.func,

    /**
     * Called when dragging stops.
     *
     * Example:
     *
     * ```js
     *  function (event, ui) {}
     * ```
     *
     * `event` is the Event that was triggered.
     * `ui` is an object:
     *
     * ```js
     *  {
     *    position: {top: 0, left: 0}
     *  }
     * ```
     */
    onStop: React.PropTypes.func,

    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (due to that there's internal use of onMouseDown)
     */
    onMouseDown: React.PropTypes.func,
  },

  componentWillReceiveProps: function(newProps) {
    // React to changes in the 'start' param.
    if (newProps.moveOnStartChange && newProps.start) {
      this.setState(this.getInitialState(newProps));
    }
  },

  componentDidMount: function() {
    // Check to see if the element passed is an instanceof SVGElement
    if( React.findDOMNode(this) instanceof SVGElement) {
        this.setState({ isElementSVG: true });
    }
  },

  componentWillUnmount: function() {
    // Remove any leftover event handlers
    removeEvent(document, dragEventFor.move, this.handleDrag);
    removeEvent(document, dragEventFor.end, this.handleDragEnd);
    removeUserSelectStyles(this);
  },

  getDefaultProps: function () {
    return {
      axis: 'both',
      bounds: false,
      handle: null,
      cancel: null,
      grid: null,
      moveOnStartChange: false,
      start: {x: 0, y: 0},
      zIndex: NaN,
      enableUserSelectHack: true,
      onStart: emptyFunction,
      onDrag: emptyFunction,
      onStop: emptyFunction,
      onMouseDown: emptyFunction
    };
  },

  getInitialState: function (props) {
    // Handle call from CWRP
    var currentState = this.state;
    props = props || this.props;
    return {
      // Whether or not we are currently dragging.
      dragging: false,

      // Offset between start top/left and mouse top/left while dragging.
      offsetX: 0, offsetY: 0,

      // Current transform x and y.
      clientX: props.start.x, clientY: props.start.y,

      // Determines if the element is an svg or not. Default to false.
      isElementSVG: currentState && currentState.isElementSVG !== undefined ?
        currentState.isElementSVG :
        false
    };
  },

  handleDragStart: function (e) {
    // Set touch identifier in component state if this is a touch event
    if(e.targetTouches){
      this.setState({touchIdentifier: e.targetTouches[0].identifier});
    }

    // Make it possible to attach event handlers on top of this one
    this.props.onMouseDown(e);

    // Short circuit if handle or cancel prop was provided and selector doesn't match
    if ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||
      (this.props.cancel && matchesSelector(e.target, this.props.cancel))) {
      return;
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldStart = this.props.onStart(e, createUIEvent(this));
    if (shouldStart === false) return;

    var dragPoint = getControlPosition(e);

    // Add a style to the body to disable user-select. This prevents text from
    // being selected all over the page.
    addUserSelectStyles(this);

    // Initiate dragging. Set the current x and y as offsets
    // so we know how much we've moved during the drag. This allows us
    // to drag elements around even if they have been moved, without issue.
    this.setState({
      dragging: true,
      offsetX: dragPoint.clientX - this.state.clientX,
      offsetY: dragPoint.clientY - this.state.clientY,
      scrollX: document.body.scrollLeft,
      scrollY: document.body.scrollTop
    });


    // Add event handlers
    addEvent(document, 'scroll', this.handleScroll);
    addEvent(document, dragEventFor.move, this.handleDrag);
    addEvent(document, dragEventFor.end, this.handleDragEnd);
  },

  handleDragEnd: function (e) {
    // Short circuit if not currently dragging
    if (!this.state.dragging) {
      return;
    }

    // Short circuit if this is not the correct touch event
    if(e.changedTouches && (e.changedTouches[0].identifier != this.state.touchIdentifier)){
     return;
    }

    removeUserSelectStyles(this);

    // Turn off dragging
    this.setState({
      dragging: false
    });

    // Call event handler
    this.props.onStop(e, createUIEvent(this));

    // Remove event handlers
    removeEvent(document, 'scroll', this.handleScroll);
    removeEvent(document, dragEventFor.move, this.handleDrag);
    removeEvent(document, dragEventFor.end, this.handleDragEnd);
  },

  handleDrag: function (e) {
    // Return if this is a touch event, but not the correct one for this element
    if(e.targetTouches && (e.targetTouches[0].identifier != this.state.touchIdentifier)){
      return;
    }
    var dragPoint = getControlPosition(e);

    // Calculate X and Y
    var clientX = dragPoint.clientX - this.state.offsetX;
    var clientY = dragPoint.clientY - this.state.offsetY;

    // Snap to grid if prop has been provided
    if (Array.isArray(this.props.grid)) {
      var coords = snapToGrid(this.props.grid, clientX, clientY);
      clientX = coords[0];
      clientY = coords[1];
    }

    if (this.props.bounds) {
      var pos = getBoundPosition(this, clientX, clientY);
      clientX = pos[0];
      clientY = pos[1];
    }

    // Call event handler. If it returns explicit false, cancel.
    var shouldUpdate = this.props.onDrag(e, createUIEvent(this));
    if (shouldUpdate === false) return this.handleDragEnd({});

    // Update transform
    this.setState({
      clientX: clientX,
      clientY: clientY
    });
  },

  handleScroll: function(e) {
    var s = this.state, x = document.body.scrollLeft, y = document.body.scrollTop;
    var offsetX = x - s.scrollX, offsetY = y - s.scrollY;
    this.setState({
      scrollX: x,
      scrollY: y,
      clientX: s.clientX + offsetX,
      clientY: s.clientY + offsetY,
      offsetX: s.offsetX - offsetX,
      offsetY: s.offsetY - offsetY
    });
  },

  onMouseDown: function(ev) {
    // Prevent 'ghost click' which happens 300ms after touchstart if the event isn't cancelled.
    // We don't cancel the event on touchstart because of #37; we might want to make a scrollable item draggable.
    // More on ghost clicks: http://ariatemplates.com/blog/2014/05/ghost-clicks-in-mobile-browsers/
    if (dragEventFor === eventsFor.touch) {
      return ev.preventDefault();
    }

    return this.handleDragStart.apply(this, arguments);
  },

  onTouchStart: function(ev) {
    // We're on a touch device now, so change the event handlers
    dragEventFor = eventsFor.touch;

    return this.handleDragStart.apply(this, arguments);
  },

  // Intended for use by a parent component. Resets internal state on this component. Useful for
  // <Resizable> and other components in case this element is manually resized and start/moveOnStartChange
  // don't work for you.
  resetState: function() {
    this.setState({
      offsetX: 0, offsetY: 0, clientX: 0, clientY: 0
    });
  },

  render: function () {
    // Create style object. We extend from existing styles so we don't
    // remove anything already set (like background, color, etc).
    var childStyle = this.props.children.props.style || {};

    // Add a CSS transform to move the element around. This allows us to move the element around
    // without worrying about whether or not it is relatively or absolutely positioned.
    // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
    // has a clean slate.
    var transform = this.state.isElementSVG ? null :
      createCSSTransform({
          // Set left if horizontal drag is enabled
          x: canDragX(this) ?
            this.state.clientX :
            this.props.start.x,

          // Set top if vertical drag is enabled
          y: canDragY(this) ?
            this.state.clientY :
            this.props.start.y
        });


    // This is primarily for IE as it ignores the CSS transform applied above
    // and only respects the real transform attribute.
    var svgTransform = !this.state.isElementSVG ? null :
        createSVGTransform({
          // Set left if horizontal drag is enabled
          x: canDragX(this) ?
            this.state.clientX :
            this.props.start.x,

          // Set top if vertical drag is enabled
          y: canDragY(this) ?
            this.state.clientY :
            this.props.start.y
        });


    // Workaround IE pointer events; see #51
    // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
    var touchHacks = {
      touchAction: 'none'
    };

    var style = assign({}, childStyle, transform, touchHacks);

    // Set zIndex if currently dragging and prop has been provided
    if (this.state.dragging && !isNaN(this.props.zIndex)) {
      style.zIndex = this.props.zIndex;
    }

    var className = classNames((this.props.children.props.className || ''), 'react-draggable', {
      'react-draggable-dragging': this.state.dragging,
      'react-draggable-dragged': this.state.dragged
    });

    // Reuse the child provided
    // This makes it flexible to use whatever element is wanted (div, ul, etc)
    return React.cloneElement(React.Children.only(this.props.children), {
      style: style,
      transform: svgTransform,
      className: className,

      onMouseDown: this.onMouseDown,
      onTouchStart: this.onTouchStart,
      onMouseUp: this.handleDragEnd,
      onTouchEnd: this.handleDragEnd
    });
  }
});

},{"./getPrefix":3,"classnames":4,"object-assign":5,"react":"react"}],3:[function(require,module,exports){
module.exports = function() {
  if (typeof window === 'undefined') return '';
  // Thanks David Walsh
  var styles = window.getComputedStyle(document.documentElement, ''),
  pre = (Array.prototype.slice
        .call(styles)
        .join('')
        .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
      )[1];
  // 'ms' is not titlecased
  if(pre === undefined || pre === null) return '';
  if (pre === 'ms') return pre;
  return pre.slice(0, 1).toUpperCase() + pre.slice(1);
};

},{}],4:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],5:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],6:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],7:[function(require,module,exports){
'use strict';

// Rune
var Events = require('./global/Events');
var Util = require('./global/Util');
var WorkSpaceController = require('./features/workspace/WorkspaceController');
var CanvasController = require('./features/canvas/CanvasController');
var DataController = require('./models/DataController');



    function App( ) {

        // Setup workspace
        this.data = new DataController(Util.getLocalData("runeData"));
        this.canvas = new CanvasController(this.data);

        this.plugins = require('./plugins')({
            gridOptions: this.data.tablet.gridOptions,
            selectedPoints: this.data.activeRune.selectedPoints,
            addTransformToSelected: function(data)  { this.data.addTransformToSelected(data); }.bind(this),
            layers: this.canvas.layerControllers
        });

        this.workspace = new WorkSpaceController(this);

    }

    Object.defineProperty(App.prototype,"save",{writable:true,configurable:true,value:function( ) {
        this.data.save();
    }});


var app = new App();

},{"./features/canvas/CanvasController":8,"./features/workspace/WorkspaceController":13,"./global/Events":15,"./global/Util":16,"./models/DataController":19,"./plugins":24}],8:[function(require,module,exports){
var GridView = require('./GridView.js');
var RuneView = require('./RuneView.js');
var Util = require('../../global/Util');
var Events = require('../../global/Events');

var paper = require('paper');

/* ========== Render Tablet ========== */


    function CanvasController(tabletModel) {"use strict";

    	// Canvas
        let _this = this;

        this.data = tabletModel;

    	this.canvas = document.getElementById('rune-canvas');

    	paper.setup(this.canvas).install(window);

        paper.settings.handleSize = 8;

    	this.layerControllers = [{
            name: 'Grid',
            layer: new paper.Layer()
        }];

        paper.view.onResize = this.resizeHandler.bind(this);

    	// Setup grid

    	this.setupGrid();

    	tabletModel.tablet.runes.forEach(function(val, idx) {
    		_this.layerControllers.push({
                name: 'Rune ' + idx,
                layer: new paper.Layer(),
                view: new RuneView(val, _this.grid)
            });
    	});

    	this.currentLayerIndex = 1;

    	this.showGrid = true;

        this.canvas.addEventListener('mousedown', function(event) {
            Events.deselectAll.dispatch();
        });

        Events.redraw.add(this.drawCanvas.bind(this));

        Events.redraw.dispatch();

    }

    Object.defineProperty(CanvasController.prototype,"displayMode",{configurable:true,set:function(displayMode) {"use strict";

        this.toggleGrid();

        var isPreview = displayMode === 'preview';

        this.layerControllers.forEach(function(layerController, index) {
            if (index) {
                console.log(layerController.layer);
                layerController.layer.children.forEach(function(child){
                    console.log(child);
                    if (child.isHandle) {
                        child.visible = !isPreview;
                    } else if (child.runePath) {
                        child.fillColor = isPreview ? 'black' : null;
                        child.strokeColor = isPreview ? null : 'red';
                        child.closed = isPreview;
                    }
                });
            }
        });

        this.$CanvasController_displayMode = displayMode;

        Events.redraw.dispatch();
    }});

    Object.defineProperty(CanvasController.prototype,"gridLayer",{configurable:true,get:function() {"use strict";
        return this.layerControllers[0].layer;
    }});


	Object.defineProperty(CanvasController.prototype,"setupGrid",{writable:true,configurable:true,value:function( ) {"use strict";
		this.grid = new GridView(this.data.tablet.gridOptions);
		this.redrawGrid();
	}});

    Object.defineProperty(CanvasController.prototype,"toggleGrid",{writable:true,configurable:true,value:function(showGrid) {"use strict";
        this.showGrid = !this.showGrid;
        this.gridLayer.visible = this.showGrid;
        Events.redraw.dispatch();
    }});

    Object.defineProperty(CanvasController.prototype,"resizeHandler",{writable:true,configurable:true,value:function( ) {"use strict";
        this.redrawAllLayers();
    }});

    Object.defineProperty(CanvasController.prototype,"redrawAllLayers",{writable:true,configurable:true,value:function( ) {"use strict";
        this.redrawGrid();
        this.layerControllers.forEach(function(ctrl)  {
            if (ctrl.view) {
                ctrl.view.draw();
            }
        });
    }});

    Object.defineProperty(CanvasController.prototype,"redrawCurrentLayer",{writable:true,configurable:true,value:function( ) {"use strict";
        // Draw active layer
        this.layerControllers[this.currentLayerIndex].layer.removeChildren();
        this.layerControllers[this.currentLayerIndex].layer.activate();
        this.layerControllers[this.currentLayerIndex].view.draw();
        // this.redraw();
    }});

	Object.defineProperty(CanvasController.prototype,"redrawGrid",{writable:true,configurable:true,value:function( ) {"use strict";

		this.gridLayer.removeChildren();
		this.gridLayer.activate();
		this.grid.draw();
		// this.redraw();

	}});

	Object.defineProperty(CanvasController.prototype,"drawCanvas",{writable:true,configurable:true,value:function( ) {"use strict";
        console.log("Redrawing canvas...");
		// paper.view.draw();
        this.redrawCurrentLayer();
	}});


module.exports = CanvasController;

},{"../../global/Events":15,"../../global/Util":16,"./GridView.js":9,"./RuneView.js":10,"paper":"paper"}],9:[function(require,module,exports){
var Util = require('../../global/util');
var constants = require('../../global/Const');
var Events = require('../../global/Events');

var paper = require('paper');


/* ========== Grid view ========== */


	function GridView(options) {"use strict";

    	this.res = options.res;
    	this.units = options.units;

    	this.points = [];

    	for(var row = -this.units / 2; row < this.units / 2; row++) {

    		this.points[row] = [];

    		for(var col = -this.units / 2; col < this.units / 2; col++) {

    			var point = [row, col];
    			this.points[row].push(point);
    		}

    		col = 0;
    	}
    }

	Object.defineProperty(GridView.prototype,"draw",{writable:true,configurable:true,value:function( ) {"use strict";

		let _this = this;

        let gridColor = new paper.Color(_this.gridColor, 100);

		for (let i = 0; i < 100; i += this.res) {
			this.vLine(paper.view.center.x + i)
			this.vLine(paper.view.center.x - i)
		}

        let midX = new paper.Path.Rectangle([0, paper.view.center.y], 2000, 1);
        midX.fillColor = constants.RED;

        this.vLine(paper.view.center.x, constants.RED);
	}});

	Object.defineProperty(GridView.prototype,"yLine",{writable:true,configurable:true,value:function(xLoc, color) {"use strict";
		let line = new paper.Path.Rectangle([xLoc, 0], 1, 2000);
		line.fillColor = color ? color : constants.BLUE;
	}});

	Object.defineProperty(GridView.prototype,"xLine",{writable:true,configurable:true,value:function(xLoc, color) {"use strict";
		let line = new paper.Path.Rectangle([xLoc, 0], 1, 2000);
		line.fillColor = color ? color : constants.BLUE;
	}});

	Object.defineProperty(GridView.prototype,"createGridPoints",{writable:true,configurable:true,value:function( ) {"use strict";
		for(var i = 0, arr; arr = grid.points[i++];) {
			for( var j = 0, point; point = arr[j++];) {
				var paperPoint = new paper.Point( this.renderPoint(point) );
				grid.createGridPoint(paperPoint, point);
			}
		}
	}});

	Object.defineProperty(GridView.prototype,"renderPoint",{writable:true,configurable:true,value:function(point) {"use strict";
		return [point[0] * this.res + (this.res / 2), point[1] * this.res + (this.res/2)];
	}});

	Object.defineProperty(GridView.prototype,"createGridPoint",{writable:true,configurable:true,value:function(point, value) {"use strict";

		var path = paper.Path.Circle(point, this.res / 2);

		path.value = value;
		path.active = false;

		var opaque = new paper.Color(255, 0, 0, 0.2);

		path.fillColor = opaque;

		path.onMouseEnter = function(e) {
			this.fillColor = 'orange';
		}

		path.onMouseLeave = function(e) {
			this.fillColor = this.active ? 'red' : opaque;
		}

		path.onMouseDown = function(e) {
			this.fillColor = 'red';
            Events.addPoint.dispatch(e.target.value);
            Events.redraw.dispatch();
		}
	}});


module.exports = GridView;

},{"../../global/Const":14,"../../global/Events":15,"../../global/util":18,"paper":"paper"}],10:[function(require,module,exports){
var Events = require('../../global/Events');
var paper = require('paper');

/* ========== Tablet ========== */


    function RuneView(runeModel, grid) {"use strict";

        this.points = [];
        this.data = runeModel;
        this.grid = grid;
    }

    Object.defineProperty(RuneView.prototype,"draw",{writable:true,configurable:true,value:function( ) {"use strict";

        var runeView = this;

        runeView.runePoints = [];
        runeView.path = new paper.Path();
        runeView.path.strokeColor = 'black';

        var testPath = new paper.Path({
            segments: runeView.data.currentPath.map(function(point, idx) {
                // var pointWithTransforms = point.reduce(function(prev, current) {
                //     return [prev[0] + current[0], prev[1] + current[1]];
                // });
                return runeView.createRuneSegment(
                    point,
                    //runeView.grid.renderPoint(pointWithTransforms),
                    idx,
                    runeView.data.selectedPoints.some(function(point)  {return point.idx === idx;}),
                    null
                );
            })
        })

        testPath.runePath = true;
        testPath.strokeColor = '#000000';

    }});
    
    Object.defineProperty(RuneView.prototype,"createRuneSegment",{writable:true,configurable:true,value:function(point, idx, isSelected, transform) {"use strict";

        let paperPoint;

        let renderedPoint = point.render(this.grid.res);

        if (point.length < 1) {
            paperPoint = new paper.Segment({
                point: renderedPoint[0],
                handleIn: renderedPoint[1],
                handleOut: renderedPoint[2]
            });
        } else {
            paperPoint = new paper.Point(renderedPoint);
        }

        let p = paperPoint.point || paperPoint;


        if(transform) {
            console.log(transform);
            p.add((function() {
                var point = new paper.Point();
                point.angle = transform[0];
                point.length = transform[1];
                return point;
            })());
        }

        let path = new paper.Path.Rectangle(p.subtract([7, 7]), 14);

        path.isHandle = true;
        path.fillColor = 'white';
        path.value = { idx: idx, point: point};
        path.isSelected = isSelected || false;
        path.strokeWidth = 4;

        path.strokeColor = path.isSelected ? 'red' : false;

        path.onMouseEnter = function(e) {
            // this.fillColor = this.selected ? 'red' : 'orange';
        }

        path.onMouseLeave = function(e) {
            // this.fillColor = 'white';
        }

        path.onMouseDown = function(e) {
            e.event.stopImmediatePropagation();
            this.isSelected = !this.isSelected;
            console.log(this);
            Events.selectPoint.dispatch(this.isSelected, e.target.value);
            Events.redraw.dispatch();
        }

        return paperPoint;
    }});


module.exports = RuneView;

},{"../../global/Events":15,"paper":"paper"}],11:[function(require,module,exports){
'use strict';

var Util = require('../../global/Util');
var React = require('react');
var Draggable = require('react-draggable');

var React = require('react');

// var getGridPanelComponent = require('./grid/GridPanelComponent.jsx');


    function PanelController(app) {
        this.app = app;
        this.init();
    }
    Object.defineProperty(PanelController.prototype,"init",{writable:true,configurable:true,value:function( ) {

        var panelController = this;

        var PanelWrapper = React.createClass({displayName: "PanelWrapper",
            handleStart: function() {

            },
            handleDrag: function() {

            },
            render: function() {
                var offsetY = this.props.offset * 50;
                var offsetX = this.props.offset * 5;
                return (
                    React.createElement("div", {className: "panel"}, 
                        React.createElement("div", {className: "handle"}, 
                             this.props.options.title
                        ), 
                        React.createElement("div", {className: "panel-content"}, 
                             this.props.children
                        )
                    )
                );
            }
        });

        var Panels = React.createClass({displayName: "Panels",
            render: function() {
                return (
                    React.createElement("div", null, 
                        
                            this.props.data.map(function(panel, idx) {
                                var Component = panel.panel;
                                return React.createElement(PanelWrapper, {offset: idx, options: {title : panel.title}}, 
                                     React.createElement(Component, {data: panel.data})
                                 );
                            })
                        
                    )
                );
            }
        });

        // Plugin panels
        React.render(
            React.createElement(Panels, {data: panelController.app.plugins}),
            document.getElementById('rune-panels')
        );


    }});

    Object.defineProperty(PanelController.prototype,"updateProperties",{writable:true,configurable:true,value:function(model) {

    }});


// <Draggable
//     start={{x: offsetX + 800, y: offsetY }}
//     onStart={this.handleStart}
//     handle=".handle"
//     >
//     <div className="panel">
//         <div className="handle">{ this.props.options.title }</div>
//         <div className="panel-content">
//             { this.props.children }
//         </div>
//     </div>
// </Draggable>


module.exports = PanelController;

},{"../../global/Util":16,"react":"react","react-draggable":1}],12:[function(require,module,exports){
let Events = require('../../global/Events');

var React = require('react');
var paper = require('paper');

function ActionBar(app) {

	var actionBar = this;
	actionBar.app = app;

	this.actions = [
		{
			id : "save",
			title : "Save",
			action : function(e) {
				e.preventDefault();
				// debugger;
				actionBar.app.data.save();

			}
		},
		{
			id : "clear",
			title : "Clear",
			action: function(e) {
				e.preventDefault();
				// Util.dispatchRuneEvent("clearGridPoints");
                Events.clearPoints.dispatch();
			}
		},
		{
			id: "grid",
			title: "Preview",
			action: function(e) {
				e.preventDefault();
				// util.dispatchRuneEvent("preview");
                Events.preview.dispatch();
			}
		},
		{
			id: "rune",
			title: "Add rune",
			action: function(e) {
				e.preventDefault();
				app.tablet.addRune();
			}
		},
		{
			id: "svg",
			title: "Export as SVG",
			action: function(e) {
				e.preventDefault();
                actionBar.app.canvas.displayMode = 'preview';
                console.log("here");
				var svgString = paper.project.exportSVG({asString:true, layerIndex: 1});
				var url = "data:image/svg+xml;utf8," + encodeURIComponent(svgString);
				var link = document.createElement("a");
                console.log("and here");
				link.download = 'rune_export.svg';
				link.href = url;
				link.click();
                actionBar.app.canvas.displayMode = 'working';
			}
		}
	];
	this.render();
	this.addEvents();
}

ActionBar.prototype.addEvents = function(container) {
	for (var i=0; i < this.actions.length; i++) {
		var action = this.actions[i];
		document.querySelectorAll('[data-action="' + action.id + '"]')[0].onclick = action.action;
	}
};

ActionBar.prototype.render = function() {
	console.log("this is working");

	var actions = this.actions;

	var ActionBarComponent = React.createClass({displayName: "ActionBarComponent",
	    render: function() {
	        return (
				React.createElement("ul", null, 
					
						this.props.actions.map(function(action, i) {
							return React.createElement("li", null, React.createElement("a", {className: "action", "data-action":  action.id},  action.title));
						})
					
				)
	        );
	    }
	});

	React.render(
	    React.createElement(ActionBarComponent, {actions: actions}),
	    document.getElementById('rune-actionbar')
	);
};

module.exports = ActionBar;

},{"../../global/Events":15,"paper":"paper","react":"react"}],13:[function(require,module,exports){
var ActionBar = require('./ActionBarController.jsx');
var PanelController = require('./../panels/PanelController.jsx');

function WorkSpaceController(app) {

	this.actionBar = new ActionBar(app);
	this.panels = new PanelController(app);
}

WorkSpaceController.prototype = {
	constructor: WorkSpaceController,
}

module.exports = WorkSpaceController;

},{"./../panels/PanelController.jsx":11,"./ActionBarController.jsx":12}],14:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 360,
	BLUE:  '#41d4f3',
    RED: '#ff0000'
};

},{}],15:[function(require,module,exports){
// var Util = require('./Util');

// class RuneEvents {
//     dispatch () {

//     }

//     listen (Event, callback) {

//     }
// }
    // dispatchRuneEvent: function(name, data) {
    //     var runeEvent = new CustomEvent('runeEvent', { 'detail' : { 'event' : name, 'data' :  data }});
    //     document.dispatchEvent(runeEvent);
    // },
// Event listeners
// function Events(app) {

// 	this.app = app;

// 	var events = this;

// 	this.eventHandlers = {
// 		addPoint : function (data) {
// 			events.app.data.addPoint(data);
// 			events.app.canvas.draw();
// 		},
// 		selectPoint: function (data) {
// 			if(data[0]) {
// 				events.app.data.selectPoint(data[1]);
// 			} else {
//                 events.app.data.deselectPoint(data[1]);
// 			}
//             console.log("Selected points:");
// 			console.log(app.data.activeRune.selectedPoints);
//             events.app.canvas.draw();
// 		},
// 		clearGridPoints : function (e) {
// 			events.app.data.clearRune();
// 			events.app.canvas.draw();
// 		},
// 		preview: function (e) {
// 			events.app.canvas.displayMode = 'preview';
// 		},
// 		deselectAll: function (e) {
// 			events.app.data.activeRune.selectedPoints = [];
// 			events.app.canvas.draw();
// 		},
//         refreshCanvas: function () {
//             events.app.canvas.setupGrid();
//         },
//         redraw : function () {
//             events.app.canvas.draw();
//         }
// 	}
// }

// Events.prototype = {
// 	constructor: Events,
// 	init: function() {
// 		var events = this;

// 		document.addEventListener('runeEvent', function(e) {
// 			console.log('Event received: ' + e.detail.event);
// 			events.eventHandlers[e.detail.event](e.detail.data);

// 		});

//         // Needs fixing
// 		document.addEventListener('keydown', function(e) {
//             if(e.target.tagName !== 'INPUT') {
//     			switch(e.keyCode) {
//     				case 8: //delete
//     					e.preventDefault();
//     					events.app.data.deleteSelected();
//     					events.app.canvas.draw();
//     					util.dispatchRuneEvent('deselectAll');

//     				break;
//     			}
//             }
// 		});
// 	}
// }

let signals = require('signals');

let events = [
    'addPoint',
    'selectPoint',
    'clearPoints',
    'preview',
    'deselectAll',
    'refreshCanvas',
    'redraw'
];

Events = {};

events.forEach(function(event)  {
    Events[event] = new signals.Signal();
});

module.exports = Events;

},{"signals":6}],16:[function(require,module,exports){
/* ========== Utilities ========== */

function Util(){"use strict";}
	Object.defineProperty(Util,"getIndices",{writable:true,configurable:true,value:function(points, gridPoints) {"use strict";
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	}});

	Object.defineProperty(Util,"object",{writable:true,configurable:true,value:function(o) {"use strict";
        function F() {}
        F.prototype = o;
        return new F();
    }});

    Object.defineProperty(Util,"getLocalData",{writable:true,configurable:true,value:function(ref) {"use strict";
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : null;
    }});


module.exports = Util;

},{}],17:[function(require,module,exports){
module.exports = {
	SILVER_RATIO : Math.sqrt(2),
	GOLDEN_RATIO :  (1 + Math.sqrt(5)) / 2,
	CANVAS_SIZE : 360,
	BLUE:  '#41d4f3',
    RED: '#ff0000'
};

},{}],18:[function(require,module,exports){
/* ========== Utilities ========== */

function Util(){"use strict";}
	Object.defineProperty(Util,"getIndices",{writable:true,configurable:true,value:function(points, gridPoints) {"use strict";
		return points.map(function(point) {
			return gridPoints.indexOf(point);
		});
	}});

	Object.defineProperty(Util,"object",{writable:true,configurable:true,value:function(o) {"use strict";
        function F() {}
        F.prototype = o;
        return new F();
    }});

    Object.defineProperty(Util,"getLocalData",{writable:true,configurable:true,value:function(ref) {"use strict";
    	return (localStorage[ref] && typeof localStorage[ref] === 'string') ? JSON.parse(localStorage[ref]) : null;
    }});


module.exports = Util;

},{}],19:[function(require,module,exports){
var TabletModel = require('./TabletModel');
var Events = require('../global/Events');
var _ = require('lodash');

/* ========== Data ========== */


    function DataController(tabletModel) {"use strict";

        this.tablet = new TabletModel(tabletModel);
        this.currentRune = 0;

        Events.addPoint.add(this.addPoint.bind(this));
        Events.selectPoint.add(this.selectPoint.bind(this));

    }

    Object.defineProperty(DataController.prototype,"activeRune",{configurable:true,get:function( ) {"use strict";
        return this.tablet.runes[this.currentRune];
    }});

    Object.defineProperty(DataController.prototype,"save",{writable:true,configurable:true,value:function( ) {"use strict";
        this.tablet.data.runes = this.tablet.runes;
        localStorage["runeData"] = JSON.stringify(this.tablet.data);
    }});

    Object.defineProperty(DataController.prototype,"addRune",{writable:true,configurable:true,value:function( ) {"use strict";
        this.tablet.runes.push(new RuneData(null));
    }});

    Object.defineProperty(DataController.prototype,"addPoint",{writable:true,configurable:true,value:function(gridRef) {"use strict";
        this.activeRune.addPoint(gridRef);
        Events.deselectAll.dispatch();

    }});

    Object.defineProperty(DataController.prototype,"addTransformToSelected",{writable:true,configurable:true,value:function(transform) {"use strict";
        var rune = this.activeRune;
        rune.selectedPoints.forEach(function(pointIndex) {
            rune.currentPath[pointIndex].push(transform);
        });
        Events.redraw.dispatch();
    }});

    Object.defineProperty(DataController.prototype,"clearRune",{writable:true,configurable:true,value:function() {"use strict";
        this.activeRune.clearPaths().currentPointIndex = 0;
    }});

    Object.defineProperty(DataController.prototype,"updateGrid",{writable:true,configurable:true,value:function( ) {"use strict";
        // var rune = this.getactiveRune();
        // rune.letter.gridPoints.forEach(function(entry, i) {
        // });
    }});

    Object.defineProperty(DataController.prototype,"deleteSelected",{writable:true,configurable:true,value:function( ) {"use strict";
        // FIX THIS
        // var rune = this.activeRune;
        // rune.currentPath = rune.currentPath.filter(function(value, idx) {
            // return !~rune.selectedPoints.indexOf(idx);
        // });
    }});

    Object.defineProperty(DataController.prototype,"selectPoint",{writable:true,configurable:true,value:function(isSelected, point) {"use strict";
        if(isSelected) {
            this.activeRune.selectedPoints.push(point);
            this.activeRune.currentPointIndex = point.idx;
        } else {
            this.activeRune.selectedPoints = _.reject(this.activeRune.selectedPoints, function(val)  {
                return val.idx === point.idx;
            });
        }
    }});


module.exports = DataController;

},{"../global/Events":15,"./TabletModel":22,"lodash":"lodash"}],20:[function(require,module,exports){
var RunePoint = require('./RunePoint');

/* ========== Rune Model ========== */



    function RuneModel(data) {"use strict";
        this.paths = data && data.paths || [ [] ];
        this.selectedPoints = data && data.selectedPoints || [];
        this.currentPointIndex = data && data.currentPointIndex || 0;
        this.currentPathIndex = data && data.currentPathIndex || 0;
        this.reverseAdd = false;
    }

    Object.defineProperty(RuneModel.prototype,"clearPaths",{writable:true,configurable:true,value:function( )  {"use strict";
        this.paths = [ [] ];
        return this;
    }});

    Object.defineProperty(RuneModel.prototype,"addPoint",{writable:true,configurable:true,value:function(gridRef) {"use strict";
        if (this.selectedPoints.length) {
            if (this.selectedPoints[0] == 0 ) {
                this.reverseAdd = true;
            } else if (this.selectedPoints[0] == this.currentPath.length-1) {
                this.reverseAdd = false;
            }
        }
        if(this.reverseAdd) {
            this.currentPath.unshift(new RunePoint(gridRef[0], gridRef[1]));
        } else {
            this.currentPointIndex++;
            this.currentPath.splice(this.currentPointIndex, 0, new RunePoint(gridRef[0], gridRef[1]));
        }
        return this;
    }});

    Object.defineProperty(RuneModel.prototype,"currentPath",{configurable:true,get:function() {"use strict";
        return this.paths[this.currentPathIndex];
    }});

    Object.defineProperty(RuneModel.prototype,"currentPath",{configurable:true,set:function(arr) {"use strict";
        this.paths[this.currentPathIndex] = arr;
    }});

    Object.defineProperty(RuneModel.prototype,"currentPoint",{configurable:true,get:function() {"use strict";
        return this.paths[this.currentPathIndex][this.currentPointIndex];
    }});

    Object.defineProperty(RuneModel.prototype,"currentPoint",{configurable:true,set:function(arr) {"use strict";
        this.currentPathIndex = arr[0];
        this.currentPointIndex = arr[1];
    }});


       
           
     

       
          
     


       
          
     

       
          
     

       
           
     


module.exports = RuneModel;

},{"./RunePoint":21}],21:[function(require,module,exports){
/* ========== Point Model ========== */


    function BasePoint(x, y) {"use strict";
        this.x = x;
        this.y = y;
    }

    Object.defineProperty(BasePoint.prototype,"getActual",{writable:true,configurable:true,value:function( ) {"use strict";

    }});

    Object.defineProperty(BasePoint.prototype,"getRelative",{writable:true,configurable:true,value:function( ) {"use strict";

    }});


for(var BasePoint____Key in BasePoint){if(BasePoint.hasOwnProperty(BasePoint____Key)){RunePoint[BasePoint____Key]=BasePoint[BasePoint____Key];}}var ____SuperProtoOfBasePoint=BasePoint===null?null:BasePoint.prototype;RunePoint.prototype=Object.create(____SuperProtoOfBasePoint);RunePoint.prototype.constructor=RunePoint;RunePoint.__superConstructor__=BasePoint;

    function RunePoint(x, y) {"use strict";
        if (typeof x === 'object') {
            BasePoint.call(this,x.x, x.y);
            this.transforms = x.transforms || [];
            this.handles = x.handles || [];
        } else {
            BasePoint.call(this,x, y);
            this.transforms = [];
            this.handles = [];
        }
    }

    Object.defineProperty(RunePoint.prototype,"addHandles",{writable:true,configurable:true,value:function( ) {"use strict";
        this.handles = [new BasePoint(), new BasePoint()];
    }});

    Object.defineProperty(RunePoint.prototype,"render",{writable:true,configurable:true,value:function(unit) {"use strict";
        return [this.x * unit  + (unit / 2), this.y * unit  + (unit / 2)]; 
    }});

    Object.defineProperty(RunePoint.prototype,"isCurve",{configurable:true,get:function( ) {"use strict";
        return 'maybe...';
    }});


module.exports = RunePoint;

},{}],22:[function(require,module,exports){
var constants = require('../global/const');
var RunePoint = require('./RunePoint');
var RuneModel = require('./RuneModel');

/* ========== Tablet Model ========== */


    function TabletModel(data) {"use strict";

        var defaultUnits = 10;
        var defaultRes = constants.CANVAS_SIZE / defaultUnits

        var tablet = this;

        if (data) {
            data.runes.forEach(function(rune, i, runes) {
                rune.paths.forEach(function(path, i2, paths) {
                    path.forEach(function(point, i3, points) {
                        data.runes[i].paths[i2][i3] = new RunePoint(point);
                    });
                });
            });
        }

        tablet.data = data || {
            gridOptions: {
                units: defaultUnits,
                res: defaultRes
            },
            renderedSVG: '',
            currentPathIndex: 0
        };

        tablet.runes = [];

        if(data) {
            data.runes.forEach(function(entry) {
                console.log(entry);
                tablet.runes.push(new RuneModel(entry));
            });
        } else {
            tablet.runes.push(new RuneModel(null));
        }
    }

    Object.defineProperty(TabletModel.prototype,"gridOptions",{configurable:true,get:function( ) {"use strict";
         return this.data.gridOptions;
    }});
       
          
     


module.exports = TabletModel;

},{"../global/const":17,"./RuneModel":20,"./RunePoint":21}],23:[function(require,module,exports){
'use strict';

var React = require('react');

module.exports = function(data) {
    console.log("Data", data);
    return {
        data: data.selectedPoints,
        title: 'Inspect point',
        panel: React.createClass({displayName: "panel",
            // getInitialState : function() {
                // return { points: data.selectedPoints };
            // },

            render: function() {
                return (
                    React.createElement("div", null, 
                        React.createElement("ul", null, 
                            
                                this.props.data.map(function(point) {
                                    console.log("Inspect point", point);
                                    return React.createElement("li", null, 
                                        point.point.x, ", ", point.point.y, 
                                         point.point.isCurve
                                    )
                                })
                            
                        )
                    )
                );
            }
        })
    };
}

},{"react":"react"}],24:[function(require,module,exports){
module.exports = function(exposedData) {
    return [
    	require('./InspectPoint.jsx')(exposedData)
        // require('./GridManager.jsx')(exposedData),
        // require('./PointTranslate.jsx')(exposedData),
        // require('./LayerManager.jsx')(exposedData),
        // require('./PointRandomise.jsx')(exposedData),
        // require('./Shapes.jsx')(exposedData),
        // require('./FourPointWeightTransform.jsx')(exposedData)
    ];
};

},{"./InspectPoint.jsx":23}]},{},[7]);
