(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        "use strict";
        var focusNode = require("./focusNode");
        var AutoFocusMixin = {
            componentDidMount: function() {
                if (this.props.autoFocus) {
                    focusNode(this.getDOMNode());
                }
            }
        };
        module.exports = AutoFocusMixin;
    }, {
        "./focusNode": 119
    } ],
    2: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var EventPropagators = require("./EventPropagators");
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var FallbackCompositionState = require("./FallbackCompositionState");
        var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");
        var SyntheticInputEvent = require("./SyntheticInputEvent");
        var keyOf = require("./keyOf");
        var END_KEYCODES = [ 9, 13, 27, 32 ];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && "CompositionEvent" in window;
        var documentMode = null;
        if (ExecutionEnvironment.canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
        }
        var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && "TextEvent" in window && !documentMode && !isPresto();
        var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        function isPresto() {
            var opera = window.opera;
            return typeof opera === "object" && typeof opera.version === "function" && parseInt(opera.version(), 10) <= 12;
        }
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        var topLevelTypes = EventConstants.topLevelTypes;
        var eventTypes = {
            beforeInput: {
                phasedRegistrationNames: {
                    bubbled: keyOf({
                        onBeforeInput: null
                    }),
                    captured: keyOf({
                        onBeforeInputCapture: null
                    })
                },
                dependencies: [ topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste ]
            },
            compositionEnd: {
                phasedRegistrationNames: {
                    bubbled: keyOf({
                        onCompositionEnd: null
                    }),
                    captured: keyOf({
                        onCompositionEndCapture: null
                    })
                },
                dependencies: [ topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown ]
            },
            compositionStart: {
                phasedRegistrationNames: {
                    bubbled: keyOf({
                        onCompositionStart: null
                    }),
                    captured: keyOf({
                        onCompositionStartCapture: null
                    })
                },
                dependencies: [ topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown ]
            },
            compositionUpdate: {
                phasedRegistrationNames: {
                    bubbled: keyOf({
                        onCompositionUpdate: null
                    }),
                    captured: keyOf({
                        onCompositionUpdateCapture: null
                    })
                },
                dependencies: [ topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown ]
            }
        };
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(topLevelType) {
            switch (topLevelType) {
              case topLevelTypes.topCompositionStart:
                return eventTypes.compositionStart;

              case topLevelTypes.topCompositionEnd:
                return eventTypes.compositionEnd;

              case topLevelTypes.topCompositionUpdate:
                return eventTypes.compositionUpdate;
            }
        }
        function isFallbackCompositionStart(topLevelType, nativeEvent) {
            return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(topLevelType, nativeEvent) {
            switch (topLevelType) {
              case topLevelTypes.topKeyUp:
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;

              case topLevelTypes.topKeyDown:
                return nativeEvent.keyCode !== START_KEYCODE;

              case topLevelTypes.topKeyPress:
              case topLevelTypes.topMouseDown:
              case topLevelTypes.topBlur:
                return true;

              default:
                return false;
            }
        }
        function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
                return detail.data;
            }
            return null;
        }
        var currentComposition = null;
        function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
                eventType = getCompositionEventType(topLevelType);
            } else if (!currentComposition) {
                if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
                    eventType = eventTypes.compositionStart;
                }
            } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                eventType = eventTypes.compositionEnd;
            }
            if (!eventType) {
                return null;
            }
            if (useFallbackCompositionData) {
                if (!currentComposition && eventType === eventTypes.compositionStart) {
                    currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
                } else if (eventType === eventTypes.compositionEnd) {
                    if (currentComposition) {
                        fallbackData = currentComposition.getData();
                    }
                }
            }
            var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);
            if (fallbackData) {
                event.data = fallbackData;
            } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                    event.data = customData;
                }
            }
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
        }
        function getNativeBeforeInputChars(topLevelType, nativeEvent) {
            switch (topLevelType) {
              case topLevelTypes.topCompositionEnd:
                return getDataFromCustomEvent(nativeEvent);

              case topLevelTypes.topKeyPress:
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                    return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;

              case topLevelTypes.topTextInput:
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                    return null;
                }
                return chars;

              default:
                return null;
            }
        }
        function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
            if (currentComposition) {
                if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                    var chars = currentComposition.getData();
                    FallbackCompositionState.release(currentComposition);
                    currentComposition = null;
                    return chars;
                }
                return null;
            }
            switch (topLevelType) {
              case topLevelTypes.topPaste:
                return null;

              case topLevelTypes.topKeyPress:
                if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
                    return String.fromCharCode(nativeEvent.which);
                }
                return null;

              case topLevelTypes.topCompositionEnd:
                return useFallbackCompositionData ? null : nativeEvent.data;

              default:
                return null;
            }
        }
        function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
            var chars;
            if (canUseTextInputEvent) {
                chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
            } else {
                chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
            }
            if (!chars) {
                return null;
            }
            var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);
            event.data = chars;
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
        }
        var BeforeInputEventPlugin = {
            eventTypes: eventTypes,
            extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                return [ extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) ];
            }
        };
        module.exports = BeforeInputEventPlugin;
    }, {
        "./EventConstants": 14,
        "./EventPropagators": 19,
        "./ExecutionEnvironment": 20,
        "./FallbackCompositionState": 21,
        "./SyntheticCompositionEvent": 93,
        "./SyntheticInputEvent": 97,
        "./keyOf": 141
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        var isUnitlessNumber = {
            boxFlex: true,
            boxFlexGroup: true,
            columnCount: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            strokeDashoffset: true,
            strokeOpacity: true,
            strokeWidth: true
        };
        function prefixKey(prefix, key) {
            return prefix + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = [ "Webkit", "ms", "Moz", "O" ];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix) {
                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
            });
        });
        var shorthandPropertyExpansions = {
            background: {
                backgroundImage: true,
                backgroundPosition: true,
                backgroundRepeat: true,
                backgroundColor: true
            },
            border: {
                borderWidth: true,
                borderStyle: true,
                borderColor: true
            },
            borderBottom: {
                borderBottomWidth: true,
                borderBottomStyle: true,
                borderBottomColor: true
            },
            borderLeft: {
                borderLeftWidth: true,
                borderLeftStyle: true,
                borderLeftColor: true
            },
            borderRight: {
                borderRightWidth: true,
                borderRightStyle: true,
                borderRightColor: true
            },
            borderTop: {
                borderTopWidth: true,
                borderTopStyle: true,
                borderTopColor: true
            },
            font: {
                fontStyle: true,
                fontVariant: true,
                fontWeight: true,
                fontSize: true,
                lineHeight: true,
                fontFamily: true
            }
        };
        var CSSProperty = {
            isUnitlessNumber: isUnitlessNumber,
            shorthandPropertyExpansions: shorthandPropertyExpansions
        };
        module.exports = CSSProperty;
    }, {} ],
    4: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var CSSProperty = require("./CSSProperty");
            var ExecutionEnvironment = require("./ExecutionEnvironment");
            var camelizeStyleName = require("./camelizeStyleName");
            var dangerousStyleValue = require("./dangerousStyleValue");
            var hyphenateStyleName = require("./hyphenateStyleName");
            var memoizeStringOnly = require("./memoizeStringOnly");
            var warning = require("./warning");
            var processStyleName = memoizeStringOnly(function(styleName) {
                return hyphenateStyleName(styleName);
            });
            var styleFloatAccessor = "cssFloat";
            if (ExecutionEnvironment.canUseDOM) {
                if (document.documentElement.style.cssFloat === undefined) {
                    styleFloatAccessor = "styleFloat";
                }
            }
            if ("production" !== process.env.NODE_ENV) {
                var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
                var badStyleValueWithSemicolonPattern = /;\s*$/;
                var warnedStyleNames = {};
                var warnedStyleValues = {};
                var warnHyphenatedStyleName = function(name) {
                    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                        return;
                    }
                    warnedStyleNames[name] = true;
                    "production" !== process.env.NODE_ENV ? warning(false, "Unsupported style property %s. Did you mean %s?", name, camelizeStyleName(name)) : null;
                };
                var warnBadVendoredStyleName = function(name) {
                    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                        return;
                    }
                    warnedStyleNames[name] = true;
                    "production" !== process.env.NODE_ENV ? warning(false, "Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)) : null;
                };
                var warnStyleValueWithSemicolon = function(name, value) {
                    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                        return;
                    }
                    warnedStyleValues[value] = true;
                    "production" !== process.env.NODE_ENV ? warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, "")) : null;
                };
                var warnValidStyle = function(name, value) {
                    if (name.indexOf("-") > -1) {
                        warnHyphenatedStyleName(name);
                    } else if (badVendoredStyleNamePattern.test(name)) {
                        warnBadVendoredStyleName(name);
                    } else if (badStyleValueWithSemicolonPattern.test(value)) {
                        warnStyleValueWithSemicolon(name, value);
                    }
                };
            }
            var CSSPropertyOperations = {
                createMarkupForStyles: function(styles) {
                    var serialized = "";
                    for (var styleName in styles) {
                        if (!styles.hasOwnProperty(styleName)) {
                            continue;
                        }
                        var styleValue = styles[styleName];
                        if ("production" !== process.env.NODE_ENV) {
                            warnValidStyle(styleName, styleValue);
                        }
                        if (styleValue != null) {
                            serialized += processStyleName(styleName) + ":";
                            serialized += dangerousStyleValue(styleName, styleValue) + ";";
                        }
                    }
                    return serialized || null;
                },
                setValueForStyles: function(node, styles) {
                    var style = node.style;
                    for (var styleName in styles) {
                        if (!styles.hasOwnProperty(styleName)) {
                            continue;
                        }
                        if ("production" !== process.env.NODE_ENV) {
                            warnValidStyle(styleName, styles[styleName]);
                        }
                        var styleValue = dangerousStyleValue(styleName, styles[styleName]);
                        if (styleName === "float") {
                            styleName = styleFloatAccessor;
                        }
                        if (styleValue) {
                            style[styleName] = styleValue;
                        } else {
                            var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
                            if (expansion) {
                                for (var individualStyleName in expansion) {
                                    style[individualStyleName] = "";
                                }
                            } else {
                                style[styleName] = "";
                            }
                        }
                    }
                }
            };
            module.exports = CSSPropertyOperations;
        }).call(this, require("_process"));
    }, {
        "./CSSProperty": 3,
        "./ExecutionEnvironment": 20,
        "./camelizeStyleName": 108,
        "./dangerousStyleValue": 113,
        "./hyphenateStyleName": 133,
        "./memoizeStringOnly": 143,
        "./warning": 154,
        _process: 156
    } ],
    5: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var PooledClass = require("./PooledClass");
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            function CallbackQueue() {
                this._callbacks = null;
                this._contexts = null;
            }
            assign(CallbackQueue.prototype, {
                enqueue: function(callback, context) {
                    this._callbacks = this._callbacks || [];
                    this._contexts = this._contexts || [];
                    this._callbacks.push(callback);
                    this._contexts.push(context);
                },
                notifyAll: function() {
                    var callbacks = this._callbacks;
                    var contexts = this._contexts;
                    if (callbacks) {
                        "production" !== process.env.NODE_ENV ? invariant(callbacks.length === contexts.length, "Mismatched list of contexts in callback queue") : invariant(callbacks.length === contexts.length);
                        this._callbacks = null;
                        this._contexts = null;
                        for (var i = 0, l = callbacks.length; i < l; i++) {
                            callbacks[i].call(contexts[i]);
                        }
                        callbacks.length = 0;
                        contexts.length = 0;
                    }
                },
                reset: function() {
                    this._callbacks = null;
                    this._contexts = null;
                },
                destructor: function() {
                    this.reset();
                }
            });
            PooledClass.addPoolingTo(CallbackQueue);
            module.exports = CallbackQueue;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./invariant": 135,
        _process: 156
    } ],
    6: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var EventPluginHub = require("./EventPluginHub");
        var EventPropagators = require("./EventPropagators");
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var ReactUpdates = require("./ReactUpdates");
        var SyntheticEvent = require("./SyntheticEvent");
        var isEventSupported = require("./isEventSupported");
        var isTextInputElement = require("./isTextInputElement");
        var keyOf = require("./keyOf");
        var topLevelTypes = EventConstants.topLevelTypes;
        var eventTypes = {
            change: {
                phasedRegistrationNames: {
                    bubbled: keyOf({
                        onChange: null
                    }),
                    captured: keyOf({
                        onChangeCapture: null
                    })
                },
                dependencies: [ topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange ]
            }
        };
        var activeElement = null;
        var activeElementID = null;
        var activeElementValue = null;
        var activeElementValueProp = null;
        function shouldUseChangeEvent(elem) {
            return elem.nodeName === "SELECT" || elem.nodeName === "INPUT" && elem.type === "file";
        }
        var doesChangeEventBubble = false;
        if (ExecutionEnvironment.canUseDOM) {
            doesChangeEventBubble = isEventSupported("change") && (!("documentMode" in document) || document.documentMode > 8);
        }
        function manualDispatchChangeEvent(nativeEvent) {
            var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
            EventPropagators.accumulateTwoPhaseDispatches(event);
            ReactUpdates.batchedUpdates(runEventInBatch, event);
        }
        function runEventInBatch(event) {
            EventPluginHub.enqueueEvents(event);
            EventPluginHub.processEventQueue();
        }
        function startWatchingForChangeEventIE8(target, targetID) {
            activeElement = target;
            activeElementID = targetID;
            activeElement.attachEvent("onchange", manualDispatchChangeEvent);
        }
        function stopWatchingForChangeEventIE8() {
            if (!activeElement) {
                return;
            }
            activeElement.detachEvent("onchange", manualDispatchChangeEvent);
            activeElement = null;
            activeElementID = null;
        }
        function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topChange) {
                return topLevelTargetID;
            }
        }
        function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topFocus) {
                stopWatchingForChangeEventIE8();
                startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
            } else if (topLevelType === topLevelTypes.topBlur) {
                stopWatchingForChangeEventIE8();
            }
        }
        var isInputEventSupported = false;
        if (ExecutionEnvironment.canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!("documentMode" in document) || document.documentMode > 9);
        }
        var newValueProp = {
            get: function() {
                return activeElementValueProp.get.call(this);
            },
            set: function(val) {
                activeElementValue = "" + val;
                activeElementValueProp.set.call(this, val);
            }
        };
        function startWatchingForValueChange(target, targetID) {
            activeElement = target;
            activeElementID = targetID;
            activeElementValue = target.value;
            activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, "value");
            Object.defineProperty(activeElement, "value", newValueProp);
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
            if (!activeElement) {
                return;
            }
            delete activeElement.value;
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementID = null;
            activeElementValue = null;
            activeElementValueProp = null;
        }
        function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
                return;
            }
            var value = nativeEvent.srcElement.value;
            if (value === activeElementValue) {
                return;
            }
            activeElementValue = value;
            manualDispatchChangeEvent(nativeEvent);
        }
        function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topInput) {
                return topLevelTargetID;
            }
        }
        function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topFocus) {
                stopWatchingForValueChange();
                startWatchingForValueChange(topLevelTarget, topLevelTargetID);
            } else if (topLevelType === topLevelTypes.topBlur) {
                stopWatchingForValueChange();
            }
        }
        function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
                if (activeElement && activeElement.value !== activeElementValue) {
                    activeElementValue = activeElement.value;
                    return activeElementID;
                }
            }
        }
        function shouldUseClickEvent(elem) {
            return elem.nodeName === "INPUT" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topClick) {
                return topLevelTargetID;
            }
        }
        var ChangeEventPlugin = {
            eventTypes: eventTypes,
            extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                var getTargetIDFunc, handleEventFunc;
                if (shouldUseChangeEvent(topLevelTarget)) {
                    if (doesChangeEventBubble) {
                        getTargetIDFunc = getTargetIDForChangeEvent;
                    } else {
                        handleEventFunc = handleEventsForChangeEventIE8;
                    }
                } else if (isTextInputElement(topLevelTarget)) {
                    if (isInputEventSupported) {
                        getTargetIDFunc = getTargetIDForInputEvent;
                    } else {
                        getTargetIDFunc = getTargetIDForInputEventIE;
                        handleEventFunc = handleEventsForInputEventIE;
                    }
                } else if (shouldUseClickEvent(topLevelTarget)) {
                    getTargetIDFunc = getTargetIDForClickEvent;
                }
                if (getTargetIDFunc) {
                    var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
                    if (targetID) {
                        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
                        EventPropagators.accumulateTwoPhaseDispatches(event);
                        return event;
                    }
                }
                if (handleEventFunc) {
                    handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
                }
            }
        };
        module.exports = ChangeEventPlugin;
    }, {
        "./EventConstants": 14,
        "./EventPluginHub": 16,
        "./EventPropagators": 19,
        "./ExecutionEnvironment": 20,
        "./ReactUpdates": 87,
        "./SyntheticEvent": 95,
        "./isEventSupported": 136,
        "./isTextInputElement": 138,
        "./keyOf": 141
    } ],
    7: [ function(require, module, exports) {
        "use strict";
        var nextReactRootIndex = 0;
        var ClientReactRootIndex = {
            createReactRootIndex: function() {
                return nextReactRootIndex++;
            }
        };
        module.exports = ClientReactRootIndex;
    }, {} ],
    8: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var Danger = require("./Danger");
            var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");
            var setTextContent = require("./setTextContent");
            var invariant = require("./invariant");
            function insertChildAt(parentNode, childNode, index) {
                parentNode.insertBefore(childNode, parentNode.childNodes[index] || null);
            }
            var DOMChildrenOperations = {
                dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
                updateTextContent: setTextContent,
                processUpdates: function(updates, markupList) {
                    var update;
                    var initialChildren = null;
                    var updatedChildren = null;
                    for (var i = 0; i < updates.length; i++) {
                        update = updates[i];
                        if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
                            var updatedIndex = update.fromIndex;
                            var updatedChild = update.parentNode.childNodes[updatedIndex];
                            var parentID = update.parentID;
                            "production" !== process.env.NODE_ENV ? invariant(updatedChild, "processUpdates(): Unable to find child %s of element. This " + "probably means the DOM was unexpectedly mutated (e.g., by the " + "browser), usually due to forgetting a <tbody> when using tables, " + "nesting tags like <form>, <p>, or <a>, or using non-SVG elements " + "in an <svg> parent. Try inspecting the child nodes of the element " + "with React ID `%s`.", updatedIndex, parentID) : invariant(updatedChild);
                            initialChildren = initialChildren || {};
                            initialChildren[parentID] = initialChildren[parentID] || [];
                            initialChildren[parentID][updatedIndex] = updatedChild;
                            updatedChildren = updatedChildren || [];
                            updatedChildren.push(updatedChild);
                        }
                    }
                    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
                    if (updatedChildren) {
                        for (var j = 0; j < updatedChildren.length; j++) {
                            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
                        }
                    }
                    for (var k = 0; k < updates.length; k++) {
                        update = updates[k];
                        switch (update.type) {
                          case ReactMultiChildUpdateTypes.INSERT_MARKUP:
                            insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
                            break;

                          case ReactMultiChildUpdateTypes.MOVE_EXISTING:
                            insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
                            break;

                          case ReactMultiChildUpdateTypes.TEXT_CONTENT:
                            setTextContent(update.parentNode, update.textContent);
                            break;

                          case ReactMultiChildUpdateTypes.REMOVE_NODE:
                            break;
                        }
                    }
                }
            };
            module.exports = DOMChildrenOperations;
        }).call(this, require("_process"));
    }, {
        "./Danger": 11,
        "./ReactMultiChildUpdateTypes": 72,
        "./invariant": 135,
        "./setTextContent": 149,
        _process: 156
    } ],
    9: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            function checkMask(value, bitmask) {
                return (value & bitmask) === bitmask;
            }
            var DOMPropertyInjection = {
                MUST_USE_ATTRIBUTE: 1,
                MUST_USE_PROPERTY: 2,
                HAS_SIDE_EFFECTS: 4,
                HAS_BOOLEAN_VALUE: 8,
                HAS_NUMERIC_VALUE: 16,
                HAS_POSITIVE_NUMERIC_VALUE: 32 | 16,
                HAS_OVERLOADED_BOOLEAN_VALUE: 64,
                injectDOMPropertyConfig: function(domPropertyConfig) {
                    var Properties = domPropertyConfig.Properties || {};
                    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
                    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
                    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
                    if (domPropertyConfig.isCustomAttribute) {
                        DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
                    }
                    for (var propName in Properties) {
                        "production" !== process.env.NODE_ENV ? invariant(!DOMProperty.isStandardName.hasOwnProperty(propName), "injectDOMPropertyConfig(...): You're trying to inject DOM property " + "'%s' which has already been injected. You may be accidentally " + "injecting the same DOM property config twice, or you may be " + "injecting two configs that have conflicting property names.", propName) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName));
                        DOMProperty.isStandardName[propName] = true;
                        var lowerCased = propName.toLowerCase();
                        DOMProperty.getPossibleStandardName[lowerCased] = propName;
                        if (DOMAttributeNames.hasOwnProperty(propName)) {
                            var attributeName = DOMAttributeNames[propName];
                            DOMProperty.getPossibleStandardName[attributeName] = propName;
                            DOMProperty.getAttributeName[propName] = attributeName;
                        } else {
                            DOMProperty.getAttributeName[propName] = lowerCased;
                        }
                        DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;
                        if (DOMMutationMethods.hasOwnProperty(propName)) {
                            DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
                        } else {
                            DOMProperty.getMutationMethod[propName] = null;
                        }
                        var propConfig = Properties[propName];
                        DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
                        DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
                        DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
                        DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
                        DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
                        DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
                        DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);
                        "production" !== process.env.NODE_ENV ? invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName], "DOMProperty: Cannot require using both attribute and property: %s", propName) : invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]);
                        "production" !== process.env.NODE_ENV ? invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName], "DOMProperty: Properties that have side effects must use property: %s", propName) : invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]);
                        "production" !== process.env.NODE_ENV ? invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1, "DOMProperty: Value can be one of boolean, overloaded boolean, or " + "numeric value, but not a combination: %s", propName) : invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1);
                    }
                }
            };
            var defaultValueCache = {};
            var DOMProperty = {
                ID_ATTRIBUTE_NAME: "data-reactid",
                isStandardName: {},
                getPossibleStandardName: {},
                getAttributeName: {},
                getPropertyName: {},
                getMutationMethod: {},
                mustUseAttribute: {},
                mustUseProperty: {},
                hasSideEffects: {},
                hasBooleanValue: {},
                hasNumericValue: {},
                hasPositiveNumericValue: {},
                hasOverloadedBooleanValue: {},
                _isCustomAttributeFunctions: [],
                isCustomAttribute: function(attributeName) {
                    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
                        var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
                        if (isCustomAttributeFn(attributeName)) {
                            return true;
                        }
                    }
                    return false;
                },
                getDefaultValueForProperty: function(nodeName, prop) {
                    var nodeDefaults = defaultValueCache[nodeName];
                    var testElement;
                    if (!nodeDefaults) {
                        defaultValueCache[nodeName] = nodeDefaults = {};
                    }
                    if (!(prop in nodeDefaults)) {
                        testElement = document.createElement(nodeName);
                        nodeDefaults[prop] = testElement[prop];
                    }
                    return nodeDefaults[prop];
                },
                injection: DOMPropertyInjection
            };
            module.exports = DOMProperty;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    10: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var DOMProperty = require("./DOMProperty");
            var quoteAttributeValueForBrowser = require("./quoteAttributeValueForBrowser");
            var warning = require("./warning");
            function shouldIgnoreValue(name, value) {
                return value == null || DOMProperty.hasBooleanValue[name] && !value || DOMProperty.hasNumericValue[name] && isNaN(value) || DOMProperty.hasPositiveNumericValue[name] && value < 1 || DOMProperty.hasOverloadedBooleanValue[name] && value === false;
            }
            if ("production" !== process.env.NODE_ENV) {
                var reactProps = {
                    children: true,
                    dangerouslySetInnerHTML: true,
                    key: true,
                    ref: true
                };
                var warnedProperties = {};
                var warnUnknownProperty = function(name) {
                    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
                        return;
                    }
                    warnedProperties[name] = true;
                    var lowerCasedName = name.toLowerCase();
                    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
                    "production" !== process.env.NODE_ENV ? warning(standardName == null, "Unknown DOM property %s. Did you mean %s?", name, standardName) : null;
                };
            }
            var DOMPropertyOperations = {
                createMarkupForID: function(id) {
                    return DOMProperty.ID_ATTRIBUTE_NAME + "=" + quoteAttributeValueForBrowser(id);
                },
                createMarkupForProperty: function(name, value) {
                    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
                        if (shouldIgnoreValue(name, value)) {
                            return "";
                        }
                        var attributeName = DOMProperty.getAttributeName[name];
                        if (DOMProperty.hasBooleanValue[name] || DOMProperty.hasOverloadedBooleanValue[name] && value === true) {
                            return attributeName;
                        }
                        return attributeName + "=" + quoteAttributeValueForBrowser(value);
                    } else if (DOMProperty.isCustomAttribute(name)) {
                        if (value == null) {
                            return "";
                        }
                        return name + "=" + quoteAttributeValueForBrowser(value);
                    } else if ("production" !== process.env.NODE_ENV) {
                        warnUnknownProperty(name);
                    }
                    return null;
                },
                setValueForProperty: function(node, name, value) {
                    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
                        var mutationMethod = DOMProperty.getMutationMethod[name];
                        if (mutationMethod) {
                            mutationMethod(node, value);
                        } else if (shouldIgnoreValue(name, value)) {
                            this.deleteValueForProperty(node, name);
                        } else if (DOMProperty.mustUseAttribute[name]) {
                            node.setAttribute(DOMProperty.getAttributeName[name], "" + value);
                        } else {
                            var propName = DOMProperty.getPropertyName[name];
                            if (!DOMProperty.hasSideEffects[name] || "" + node[propName] !== "" + value) {
                                node[propName] = value;
                            }
                        }
                    } else if (DOMProperty.isCustomAttribute(name)) {
                        if (value == null) {
                            node.removeAttribute(name);
                        } else {
                            node.setAttribute(name, "" + value);
                        }
                    } else if ("production" !== process.env.NODE_ENV) {
                        warnUnknownProperty(name);
                    }
                },
                deleteValueForProperty: function(node, name) {
                    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
                        var mutationMethod = DOMProperty.getMutationMethod[name];
                        if (mutationMethod) {
                            mutationMethod(node, undefined);
                        } else if (DOMProperty.mustUseAttribute[name]) {
                            node.removeAttribute(DOMProperty.getAttributeName[name]);
                        } else {
                            var propName = DOMProperty.getPropertyName[name];
                            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
                            if (!DOMProperty.hasSideEffects[name] || "" + node[propName] !== defaultValue) {
                                node[propName] = defaultValue;
                            }
                        }
                    } else if (DOMProperty.isCustomAttribute(name)) {
                        node.removeAttribute(name);
                    } else if ("production" !== process.env.NODE_ENV) {
                        warnUnknownProperty(name);
                    }
                }
            };
            module.exports = DOMPropertyOperations;
        }).call(this, require("_process"));
    }, {
        "./DOMProperty": 9,
        "./quoteAttributeValueForBrowser": 147,
        "./warning": 154,
        _process: 156
    } ],
    11: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ExecutionEnvironment = require("./ExecutionEnvironment");
            var createNodesFromMarkup = require("./createNodesFromMarkup");
            var emptyFunction = require("./emptyFunction");
            var getMarkupWrap = require("./getMarkupWrap");
            var invariant = require("./invariant");
            var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
            var RESULT_INDEX_ATTR = "data-danger-index";
            function getNodeName(markup) {
                return markup.substring(1, markup.indexOf(" "));
            }
            var Danger = {
                dangerouslyRenderMarkup: function(markupList) {
                    "production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, "dangerouslyRenderMarkup(...): Cannot render markup in a worker " + "thread. Make sure `window` and `document` are available globally " + "before requiring React when unit testing or use " + "React.renderToString for server rendering.") : invariant(ExecutionEnvironment.canUseDOM);
                    var nodeName;
                    var markupByNodeName = {};
                    for (var i = 0; i < markupList.length; i++) {
                        "production" !== process.env.NODE_ENV ? invariant(markupList[i], "dangerouslyRenderMarkup(...): Missing markup.") : invariant(markupList[i]);
                        nodeName = getNodeName(markupList[i]);
                        nodeName = getMarkupWrap(nodeName) ? nodeName : "*";
                        markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
                        markupByNodeName[nodeName][i] = markupList[i];
                    }
                    var resultList = [];
                    var resultListAssignmentCount = 0;
                    for (nodeName in markupByNodeName) {
                        if (!markupByNodeName.hasOwnProperty(nodeName)) {
                            continue;
                        }
                        var markupListByNodeName = markupByNodeName[nodeName];
                        var resultIndex;
                        for (resultIndex in markupListByNodeName) {
                            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
                                var markup = markupListByNodeName[resultIndex];
                                markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, "$1 " + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
                            }
                        }
                        var renderNodes = createNodesFromMarkup(markupListByNodeName.join(""), emptyFunction);
                        for (var j = 0; j < renderNodes.length; ++j) {
                            var renderNode = renderNodes[j];
                            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
                                resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
                                renderNode.removeAttribute(RESULT_INDEX_ATTR);
                                "production" !== process.env.NODE_ENV ? invariant(!resultList.hasOwnProperty(resultIndex), "Danger: Assigning to an already-occupied result index.") : invariant(!resultList.hasOwnProperty(resultIndex));
                                resultList[resultIndex] = renderNode;
                                resultListAssignmentCount += 1;
                            } else if ("production" !== process.env.NODE_ENV) {
                                console.error("Danger: Discarding unexpected node:", renderNode);
                            }
                        }
                    }
                    "production" !== process.env.NODE_ENV ? invariant(resultListAssignmentCount === resultList.length, "Danger: Did not assign to every index of resultList.") : invariant(resultListAssignmentCount === resultList.length);
                    "production" !== process.env.NODE_ENV ? invariant(resultList.length === markupList.length, "Danger: Expected markup to render %s nodes, but rendered %s.", markupList.length, resultList.length) : invariant(resultList.length === markupList.length);
                    return resultList;
                },
                dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
                    "production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, "dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a " + "worker thread. Make sure `window` and `document` are available " + "globally before requiring React when unit testing or use " + "React.renderToString for server rendering.") : invariant(ExecutionEnvironment.canUseDOM);
                    "production" !== process.env.NODE_ENV ? invariant(markup, "dangerouslyReplaceNodeWithMarkup(...): Missing markup.") : invariant(markup);
                    "production" !== process.env.NODE_ENV ? invariant(oldChild.tagName.toLowerCase() !== "html", "dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the " + "<html> node. This is because browser quirks make this unreliable " + "and/or slow. If you want to render to the root you must use " + "server rendering. See React.renderToString().") : invariant(oldChild.tagName.toLowerCase() !== "html");
                    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
                    oldChild.parentNode.replaceChild(newChild, oldChild);
                }
            };
            module.exports = Danger;
        }).call(this, require("_process"));
    }, {
        "./ExecutionEnvironment": 20,
        "./createNodesFromMarkup": 112,
        "./emptyFunction": 114,
        "./getMarkupWrap": 127,
        "./invariant": 135,
        _process: 156
    } ],
    12: [ function(require, module, exports) {
        "use strict";
        var keyOf = require("./keyOf");
        var DefaultEventPluginOrder = [ keyOf({
            ResponderEventPlugin: null
        }), keyOf({
            SimpleEventPlugin: null
        }), keyOf({
            TapEventPlugin: null
        }), keyOf({
            EnterLeaveEventPlugin: null
        }), keyOf({
            ChangeEventPlugin: null
        }), keyOf({
            SelectEventPlugin: null
        }), keyOf({
            BeforeInputEventPlugin: null
        }), keyOf({
            AnalyticsEventPlugin: null
        }), keyOf({
            MobileSafariClickEventPlugin: null
        }) ];
        module.exports = DefaultEventPluginOrder;
    }, {
        "./keyOf": 141
    } ],
    13: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var EventPropagators = require("./EventPropagators");
        var SyntheticMouseEvent = require("./SyntheticMouseEvent");
        var ReactMount = require("./ReactMount");
        var keyOf = require("./keyOf");
        var topLevelTypes = EventConstants.topLevelTypes;
        var getFirstReactDOM = ReactMount.getFirstReactDOM;
        var eventTypes = {
            mouseEnter: {
                registrationName: keyOf({
                    onMouseEnter: null
                }),
                dependencies: [ topLevelTypes.topMouseOut, topLevelTypes.topMouseOver ]
            },
            mouseLeave: {
                registrationName: keyOf({
                    onMouseLeave: null
                }),
                dependencies: [ topLevelTypes.topMouseOut, topLevelTypes.topMouseOver ]
            }
        };
        var extractedEvents = [ null, null ];
        var EnterLeaveEventPlugin = {
            eventTypes: eventTypes,
            extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
                    return null;
                }
                if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
                    return null;
                }
                var win;
                if (topLevelTarget.window === topLevelTarget) {
                    win = topLevelTarget;
                } else {
                    var doc = topLevelTarget.ownerDocument;
                    if (doc) {
                        win = doc.defaultView || doc.parentWindow;
                    } else {
                        win = window;
                    }
                }
                var from, to;
                if (topLevelType === topLevelTypes.topMouseOut) {
                    from = topLevelTarget;
                    to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
                } else {
                    from = win;
                    to = topLevelTarget;
                }
                if (from === to) {
                    return null;
                }
                var fromID = from ? ReactMount.getID(from) : "";
                var toID = to ? ReactMount.getID(to) : "";
                var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
                leave.type = "mouseleave";
                leave.target = from;
                leave.relatedTarget = to;
                var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
                enter.type = "mouseenter";
                enter.target = to;
                enter.relatedTarget = from;
                EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
                extractedEvents[0] = leave;
                extractedEvents[1] = enter;
                return extractedEvents;
            }
        };
        module.exports = EnterLeaveEventPlugin;
    }, {
        "./EventConstants": 14,
        "./EventPropagators": 19,
        "./ReactMount": 70,
        "./SyntheticMouseEvent": 99,
        "./keyOf": 141
    } ],
    14: [ function(require, module, exports) {
        "use strict";
        var keyMirror = require("./keyMirror");
        var PropagationPhases = keyMirror({
            bubbled: null,
            captured: null
        });
        var topLevelTypes = keyMirror({
            topBlur: null,
            topChange: null,
            topClick: null,
            topCompositionEnd: null,
            topCompositionStart: null,
            topCompositionUpdate: null,
            topContextMenu: null,
            topCopy: null,
            topCut: null,
            topDoubleClick: null,
            topDrag: null,
            topDragEnd: null,
            topDragEnter: null,
            topDragExit: null,
            topDragLeave: null,
            topDragOver: null,
            topDragStart: null,
            topDrop: null,
            topError: null,
            topFocus: null,
            topInput: null,
            topKeyDown: null,
            topKeyPress: null,
            topKeyUp: null,
            topLoad: null,
            topMouseDown: null,
            topMouseMove: null,
            topMouseOut: null,
            topMouseOver: null,
            topMouseUp: null,
            topPaste: null,
            topReset: null,
            topScroll: null,
            topSelectionChange: null,
            topSubmit: null,
            topTextInput: null,
            topTouchCancel: null,
            topTouchEnd: null,
            topTouchMove: null,
            topTouchStart: null,
            topWheel: null
        });
        var EventConstants = {
            topLevelTypes: topLevelTypes,
            PropagationPhases: PropagationPhases
        };
        module.exports = EventConstants;
    }, {
        "./keyMirror": 140
    } ],
    15: [ function(require, module, exports) {
        (function(process) {
            var emptyFunction = require("./emptyFunction");
            var EventListener = {
                listen: function(target, eventType, callback) {
                    if (target.addEventListener) {
                        target.addEventListener(eventType, callback, false);
                        return {
                            remove: function() {
                                target.removeEventListener(eventType, callback, false);
                            }
                        };
                    } else if (target.attachEvent) {
                        target.attachEvent("on" + eventType, callback);
                        return {
                            remove: function() {
                                target.detachEvent("on" + eventType, callback);
                            }
                        };
                    }
                },
                capture: function(target, eventType, callback) {
                    if (!target.addEventListener) {
                        if ("production" !== process.env.NODE_ENV) {
                            console.error("Attempted to listen to events during the capture phase on a " + "browser that does not support the capture phase. Your application " + "will not receive some events.");
                        }
                        return {
                            remove: emptyFunction
                        };
                    } else {
                        target.addEventListener(eventType, callback, true);
                        return {
                            remove: function() {
                                target.removeEventListener(eventType, callback, true);
                            }
                        };
                    }
                },
                registerDefault: function() {}
            };
            module.exports = EventListener;
        }).call(this, require("_process"));
    }, {
        "./emptyFunction": 114,
        _process: 156
    } ],
    16: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var EventPluginRegistry = require("./EventPluginRegistry");
            var EventPluginUtils = require("./EventPluginUtils");
            var accumulateInto = require("./accumulateInto");
            var forEachAccumulated = require("./forEachAccumulated");
            var invariant = require("./invariant");
            var listenerBank = {};
            var eventQueue = null;
            var executeDispatchesAndRelease = function(event) {
                if (event) {
                    var executeDispatch = EventPluginUtils.executeDispatch;
                    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
                    if (PluginModule && PluginModule.executeDispatch) {
                        executeDispatch = PluginModule.executeDispatch;
                    }
                    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
                    if (!event.isPersistent()) {
                        event.constructor.release(event);
                    }
                }
            };
            var InstanceHandle = null;
            function validateInstanceHandle() {
                var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
                "production" !== process.env.NODE_ENV ? invariant(valid, "InstanceHandle not injected before use!") : invariant(valid);
            }
            var EventPluginHub = {
                injection: {
                    injectMount: EventPluginUtils.injection.injectMount,
                    injectInstanceHandle: function(InjectedInstanceHandle) {
                        InstanceHandle = InjectedInstanceHandle;
                        if ("production" !== process.env.NODE_ENV) {
                            validateInstanceHandle();
                        }
                    },
                    getInstanceHandle: function() {
                        if ("production" !== process.env.NODE_ENV) {
                            validateInstanceHandle();
                        }
                        return InstanceHandle;
                    },
                    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
                    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
                },
                eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
                registrationNameModules: EventPluginRegistry.registrationNameModules,
                putListener: function(id, registrationName, listener) {
                    "production" !== process.env.NODE_ENV ? invariant(!listener || typeof listener === "function", "Expected %s listener to be a function, instead got type %s", registrationName, typeof listener) : invariant(!listener || typeof listener === "function");
                    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
                    bankForRegistrationName[id] = listener;
                },
                getListener: function(id, registrationName) {
                    var bankForRegistrationName = listenerBank[registrationName];
                    return bankForRegistrationName && bankForRegistrationName[id];
                },
                deleteListener: function(id, registrationName) {
                    var bankForRegistrationName = listenerBank[registrationName];
                    if (bankForRegistrationName) {
                        delete bankForRegistrationName[id];
                    }
                },
                deleteAllListeners: function(id) {
                    for (var registrationName in listenerBank) {
                        delete listenerBank[registrationName][id];
                    }
                },
                extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                    var events;
                    var plugins = EventPluginRegistry.plugins;
                    for (var i = 0, l = plugins.length; i < l; i++) {
                        var possiblePlugin = plugins[i];
                        if (possiblePlugin) {
                            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
                            if (extractedEvents) {
                                events = accumulateInto(events, extractedEvents);
                            }
                        }
                    }
                    return events;
                },
                enqueueEvents: function(events) {
                    if (events) {
                        eventQueue = accumulateInto(eventQueue, events);
                    }
                },
                processEventQueue: function() {
                    var processingEventQueue = eventQueue;
                    eventQueue = null;
                    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
                    "production" !== process.env.NODE_ENV ? invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.") : invariant(!eventQueue);
                },
                __purge: function() {
                    listenerBank = {};
                },
                __getListenerBank: function() {
                    return listenerBank;
                }
            };
            module.exports = EventPluginHub;
        }).call(this, require("_process"));
    }, {
        "./EventPluginRegistry": 17,
        "./EventPluginUtils": 18,
        "./accumulateInto": 105,
        "./forEachAccumulated": 120,
        "./invariant": 135,
        _process: 156
    } ],
    17: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            var EventPluginOrder = null;
            var namesToPlugins = {};
            function recomputePluginOrdering() {
                if (!EventPluginOrder) {
                    return;
                }
                for (var pluginName in namesToPlugins) {
                    var PluginModule = namesToPlugins[pluginName];
                    var pluginIndex = EventPluginOrder.indexOf(pluginName);
                    "production" !== process.env.NODE_ENV ? invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName) : invariant(pluginIndex > -1);
                    if (EventPluginRegistry.plugins[pluginIndex]) {
                        continue;
                    }
                    "production" !== process.env.NODE_ENV ? invariant(PluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName) : invariant(PluginModule.extractEvents);
                    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
                    var publishedEvents = PluginModule.eventTypes;
                    for (var eventName in publishedEvents) {
                        "production" !== process.env.NODE_ENV ? invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName) : invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName));
                    }
                }
            }
            function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
                "production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName));
                EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
                var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
                if (phasedRegistrationNames) {
                    for (var phaseName in phasedRegistrationNames) {
                        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                            var phasedRegistrationName = phasedRegistrationNames[phaseName];
                            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
                        }
                    }
                    return true;
                } else if (dispatchConfig.registrationName) {
                    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
                    return true;
                }
                return false;
            }
            function publishRegistrationName(registrationName, PluginModule, eventName) {
                "production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]);
                EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
                EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
            }
            var EventPluginRegistry = {
                plugins: [],
                eventNameDispatchConfigs: {},
                registrationNameModules: {},
                registrationNameDependencies: {},
                injectEventPluginOrder: function(InjectedEventPluginOrder) {
                    "production" !== process.env.NODE_ENV ? invariant(!EventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.") : invariant(!EventPluginOrder);
                    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
                    recomputePluginOrdering();
                },
                injectEventPluginsByName: function(injectedNamesToPlugins) {
                    var isOrderingDirty = false;
                    for (var pluginName in injectedNamesToPlugins) {
                        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                            continue;
                        }
                        var PluginModule = injectedNamesToPlugins[pluginName];
                        if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
                            "production" !== process.env.NODE_ENV ? invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName) : invariant(!namesToPlugins[pluginName]);
                            namesToPlugins[pluginName] = PluginModule;
                            isOrderingDirty = true;
                        }
                    }
                    if (isOrderingDirty) {
                        recomputePluginOrdering();
                    }
                },
                getPluginModuleForEvent: function(event) {
                    var dispatchConfig = event.dispatchConfig;
                    if (dispatchConfig.registrationName) {
                        return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
                    }
                    for (var phase in dispatchConfig.phasedRegistrationNames) {
                        if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
                            continue;
                        }
                        var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
                        if (PluginModule) {
                            return PluginModule;
                        }
                    }
                    return null;
                },
                _resetEventPlugins: function() {
                    EventPluginOrder = null;
                    for (var pluginName in namesToPlugins) {
                        if (namesToPlugins.hasOwnProperty(pluginName)) {
                            delete namesToPlugins[pluginName];
                        }
                    }
                    EventPluginRegistry.plugins.length = 0;
                    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
                    for (var eventName in eventNameDispatchConfigs) {
                        if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
                            delete eventNameDispatchConfigs[eventName];
                        }
                    }
                    var registrationNameModules = EventPluginRegistry.registrationNameModules;
                    for (var registrationName in registrationNameModules) {
                        if (registrationNameModules.hasOwnProperty(registrationName)) {
                            delete registrationNameModules[registrationName];
                        }
                    }
                }
            };
            module.exports = EventPluginRegistry;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    18: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var EventConstants = require("./EventConstants");
            var invariant = require("./invariant");
            var injection = {
                Mount: null,
                injectMount: function(InjectedMount) {
                    injection.Mount = InjectedMount;
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? invariant(InjectedMount && InjectedMount.getNode, "EventPluginUtils.injection.injectMount(...): Injected Mount module " + "is missing getNode.") : invariant(InjectedMount && InjectedMount.getNode);
                    }
                }
            };
            var topLevelTypes = EventConstants.topLevelTypes;
            function isEndish(topLevelType) {
                return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
            }
            function isMoveish(topLevelType) {
                return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
            }
            function isStartish(topLevelType) {
                return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
            }
            var validateEventDispatches;
            if ("production" !== process.env.NODE_ENV) {
                validateEventDispatches = function(event) {
                    var dispatchListeners = event._dispatchListeners;
                    var dispatchIDs = event._dispatchIDs;
                    var listenersIsArr = Array.isArray(dispatchListeners);
                    var idsIsArr = Array.isArray(dispatchIDs);
                    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
                    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
                    "production" !== process.env.NODE_ENV ? invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen, "EventPluginUtils: Invalid `event`.") : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen);
                };
            }
            function forEachEventDispatch(event, cb) {
                var dispatchListeners = event._dispatchListeners;
                var dispatchIDs = event._dispatchIDs;
                if ("production" !== process.env.NODE_ENV) {
                    validateEventDispatches(event);
                }
                if (Array.isArray(dispatchListeners)) {
                    for (var i = 0; i < dispatchListeners.length; i++) {
                        if (event.isPropagationStopped()) {
                            break;
                        }
                        cb(event, dispatchListeners[i], dispatchIDs[i]);
                    }
                } else if (dispatchListeners) {
                    cb(event, dispatchListeners, dispatchIDs);
                }
            }
            function executeDispatch(event, listener, domID) {
                event.currentTarget = injection.Mount.getNode(domID);
                var returnValue = listener(event, domID);
                event.currentTarget = null;
                return returnValue;
            }
            function executeDispatchesInOrder(event, cb) {
                forEachEventDispatch(event, cb);
                event._dispatchListeners = null;
                event._dispatchIDs = null;
            }
            function executeDispatchesInOrderStopAtTrueImpl(event) {
                var dispatchListeners = event._dispatchListeners;
                var dispatchIDs = event._dispatchIDs;
                if ("production" !== process.env.NODE_ENV) {
                    validateEventDispatches(event);
                }
                if (Array.isArray(dispatchListeners)) {
                    for (var i = 0; i < dispatchListeners.length; i++) {
                        if (event.isPropagationStopped()) {
                            break;
                        }
                        if (dispatchListeners[i](event, dispatchIDs[i])) {
                            return dispatchIDs[i];
                        }
                    }
                } else if (dispatchListeners) {
                    if (dispatchListeners(event, dispatchIDs)) {
                        return dispatchIDs;
                    }
                }
                return null;
            }
            function executeDispatchesInOrderStopAtTrue(event) {
                var ret = executeDispatchesInOrderStopAtTrueImpl(event);
                event._dispatchIDs = null;
                event._dispatchListeners = null;
                return ret;
            }
            function executeDirectDispatch(event) {
                if ("production" !== process.env.NODE_ENV) {
                    validateEventDispatches(event);
                }
                var dispatchListener = event._dispatchListeners;
                var dispatchID = event._dispatchIDs;
                "production" !== process.env.NODE_ENV ? invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.") : invariant(!Array.isArray(dispatchListener));
                var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
                event._dispatchListeners = null;
                event._dispatchIDs = null;
                return res;
            }
            function hasDispatches(event) {
                return !!event._dispatchListeners;
            }
            var EventPluginUtils = {
                isEndish: isEndish,
                isMoveish: isMoveish,
                isStartish: isStartish,
                executeDirectDispatch: executeDirectDispatch,
                executeDispatch: executeDispatch,
                executeDispatchesInOrder: executeDispatchesInOrder,
                executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
                hasDispatches: hasDispatches,
                injection: injection,
                useTouchEvents: false
            };
            module.exports = EventPluginUtils;
        }).call(this, require("_process"));
    }, {
        "./EventConstants": 14,
        "./invariant": 135,
        _process: 156
    } ],
    19: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var EventConstants = require("./EventConstants");
            var EventPluginHub = require("./EventPluginHub");
            var accumulateInto = require("./accumulateInto");
            var forEachAccumulated = require("./forEachAccumulated");
            var PropagationPhases = EventConstants.PropagationPhases;
            var getListener = EventPluginHub.getListener;
            function listenerAtPhase(id, event, propagationPhase) {
                var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
                return getListener(id, registrationName);
            }
            function accumulateDirectionalDispatches(domID, upwards, event) {
                if ("production" !== process.env.NODE_ENV) {
                    if (!domID) {
                        throw new Error("Dispatching id must not be null");
                    }
                }
                var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
                var listener = listenerAtPhase(domID, event, phase);
                if (listener) {
                    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
                }
            }
            function accumulateTwoPhaseDispatchesSingle(event) {
                if (event && event.dispatchConfig.phasedRegistrationNames) {
                    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
                }
            }
            function accumulateDispatches(id, ignoredDirection, event) {
                if (event && event.dispatchConfig.registrationName) {
                    var registrationName = event.dispatchConfig.registrationName;
                    var listener = getListener(id, registrationName);
                    if (listener) {
                        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                        event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
                    }
                }
            }
            function accumulateDirectDispatchesSingle(event) {
                if (event && event.dispatchConfig.registrationName) {
                    accumulateDispatches(event.dispatchMarker, null, event);
                }
            }
            function accumulateTwoPhaseDispatches(events) {
                forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
            }
            function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
                EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
            }
            function accumulateDirectDispatches(events) {
                forEachAccumulated(events, accumulateDirectDispatchesSingle);
            }
            var EventPropagators = {
                accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
                accumulateDirectDispatches: accumulateDirectDispatches,
                accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
            };
            module.exports = EventPropagators;
        }).call(this, require("_process"));
    }, {
        "./EventConstants": 14,
        "./EventPluginHub": 16,
        "./accumulateInto": 105,
        "./forEachAccumulated": 120,
        _process: 156
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
        var ExecutionEnvironment = {
            canUseDOM: canUseDOM,
            canUseWorkers: typeof Worker !== "undefined",
            canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
            canUseViewport: canUseDOM && !!window.screen,
            isInWorker: !canUseDOM
        };
        module.exports = ExecutionEnvironment;
    }, {} ],
    21: [ function(require, module, exports) {
        "use strict";
        var PooledClass = require("./PooledClass");
        var assign = require("./Object.assign");
        var getTextContentAccessor = require("./getTextContentAccessor");
        function FallbackCompositionState(root) {
            this._root = root;
            this._startText = this.getText();
            this._fallbackText = null;
        }
        assign(FallbackCompositionState.prototype, {
            getText: function() {
                if ("value" in this._root) {
                    return this._root.value;
                }
                return this._root[getTextContentAccessor()];
            },
            getData: function() {
                if (this._fallbackText) {
                    return this._fallbackText;
                }
                var start;
                var startValue = this._startText;
                var startLength = startValue.length;
                var end;
                var endValue = this.getText();
                var endLength = endValue.length;
                for (start = 0; start < startLength; start++) {
                    if (startValue[start] !== endValue[start]) {
                        break;
                    }
                }
                var minEnd = startLength - start;
                for (end = 1; end <= minEnd; end++) {
                    if (startValue[startLength - end] !== endValue[endLength - end]) {
                        break;
                    }
                }
                var sliceTail = end > 1 ? 1 - end : undefined;
                this._fallbackText = endValue.slice(start, sliceTail);
                return this._fallbackText;
            }
        });
        PooledClass.addPoolingTo(FallbackCompositionState);
        module.exports = FallbackCompositionState;
    }, {
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./getTextContentAccessor": 130
    } ],
    22: [ function(require, module, exports) {
        "use strict";
        var DOMProperty = require("./DOMProperty");
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
        var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
        var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
        var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
        var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
        var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
        var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
        var hasSVG;
        if (ExecutionEnvironment.canUseDOM) {
            var implementation = document.implementation;
            hasSVG = implementation && implementation.hasFeature && implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
        }
        var HTMLDOMPropertyConfig = {
            isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
            Properties: {
                accept: null,
                acceptCharset: null,
                accessKey: null,
                action: null,
                allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                allowTransparency: MUST_USE_ATTRIBUTE,
                alt: null,
                async: HAS_BOOLEAN_VALUE,
                autoComplete: null,
                autoPlay: HAS_BOOLEAN_VALUE,
                cellPadding: null,
                cellSpacing: null,
                charSet: MUST_USE_ATTRIBUTE,
                checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                classID: MUST_USE_ATTRIBUTE,
                className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
                cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
                colSpan: null,
                content: null,
                contentEditable: null,
                contextMenu: MUST_USE_ATTRIBUTE,
                controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                coords: null,
                crossOrigin: null,
                data: null,
                dateTime: MUST_USE_ATTRIBUTE,
                defer: HAS_BOOLEAN_VALUE,
                dir: null,
                disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                download: HAS_OVERLOADED_BOOLEAN_VALUE,
                draggable: null,
                encType: null,
                form: MUST_USE_ATTRIBUTE,
                formAction: MUST_USE_ATTRIBUTE,
                formEncType: MUST_USE_ATTRIBUTE,
                formMethod: MUST_USE_ATTRIBUTE,
                formNoValidate: HAS_BOOLEAN_VALUE,
                formTarget: MUST_USE_ATTRIBUTE,
                frameBorder: MUST_USE_ATTRIBUTE,
                headers: null,
                height: MUST_USE_ATTRIBUTE,
                hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                high: null,
                href: null,
                hrefLang: null,
                htmlFor: null,
                httpEquiv: null,
                icon: null,
                id: MUST_USE_PROPERTY,
                label: null,
                lang: null,
                list: MUST_USE_ATTRIBUTE,
                loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                low: null,
                manifest: MUST_USE_ATTRIBUTE,
                marginHeight: null,
                marginWidth: null,
                max: null,
                maxLength: MUST_USE_ATTRIBUTE,
                media: MUST_USE_ATTRIBUTE,
                mediaGroup: null,
                method: null,
                min: null,
                multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                name: null,
                noValidate: HAS_BOOLEAN_VALUE,
                open: HAS_BOOLEAN_VALUE,
                optimum: null,
                pattern: null,
                placeholder: null,
                poster: null,
                preload: null,
                radioGroup: null,
                readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                rel: null,
                required: HAS_BOOLEAN_VALUE,
                role: MUST_USE_ATTRIBUTE,
                rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
                rowSpan: null,
                sandbox: null,
                scope: null,
                scoped: HAS_BOOLEAN_VALUE,
                scrolling: null,
                seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                shape: null,
                size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
                sizes: MUST_USE_ATTRIBUTE,
                span: HAS_POSITIVE_NUMERIC_VALUE,
                spellCheck: null,
                src: null,
                srcDoc: MUST_USE_PROPERTY,
                srcSet: MUST_USE_ATTRIBUTE,
                start: HAS_NUMERIC_VALUE,
                step: null,
                style: null,
                tabIndex: null,
                target: null,
                title: null,
                type: null,
                useMap: null,
                value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
                width: MUST_USE_ATTRIBUTE,
                wmode: MUST_USE_ATTRIBUTE,
                autoCapitalize: null,
                autoCorrect: null,
                itemProp: MUST_USE_ATTRIBUTE,
                itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                itemType: MUST_USE_ATTRIBUTE,
                itemID: MUST_USE_ATTRIBUTE,
                itemRef: MUST_USE_ATTRIBUTE,
                property: null,
                unselectable: MUST_USE_ATTRIBUTE
            },
            DOMAttributeNames: {
                acceptCharset: "accept-charset",
                className: "class",
                htmlFor: "for",
                httpEquiv: "http-equiv"
            },
            DOMPropertyNames: {
                autoCapitalize: "autocapitalize",
                autoComplete: "autocomplete",
                autoCorrect: "autocorrect",
                autoFocus: "autofocus",
                autoPlay: "autoplay",
                encType: "encoding",
                hrefLang: "hreflang",
                radioGroup: "radiogroup",
                spellCheck: "spellcheck",
                srcDoc: "srcdoc",
                srcSet: "srcset"
            }
        };
        module.exports = HTMLDOMPropertyConfig;
    }, {
        "./DOMProperty": 9,
        "./ExecutionEnvironment": 20
    } ],
    23: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactPropTypes = require("./ReactPropTypes");
            var invariant = require("./invariant");
            var hasReadOnlyValue = {
                button: true,
                checkbox: true,
                image: true,
                hidden: true,
                radio: true,
                reset: true,
                submit: true
            };
            function _assertSingleLink(input) {
                "production" !== process.env.NODE_ENV ? invariant(input.props.checkedLink == null || input.props.valueLink == null, "Cannot provide a checkedLink and a valueLink. If you want to use " + "checkedLink, you probably don't want to use valueLink and vice versa.") : invariant(input.props.checkedLink == null || input.props.valueLink == null);
            }
            function _assertValueLink(input) {
                _assertSingleLink(input);
                "production" !== process.env.NODE_ENV ? invariant(input.props.value == null && input.props.onChange == null, "Cannot provide a valueLink and a value or onChange event. If you want " + "to use value or onChange, you probably don't want to use valueLink.") : invariant(input.props.value == null && input.props.onChange == null);
            }
            function _assertCheckedLink(input) {
                _assertSingleLink(input);
                "production" !== process.env.NODE_ENV ? invariant(input.props.checked == null && input.props.onChange == null, "Cannot provide a checkedLink and a checked property or onChange event. " + "If you want to use checked or onChange, you probably don't want to " + "use checkedLink") : invariant(input.props.checked == null && input.props.onChange == null);
            }
            function _handleLinkedValueChange(e) {
                this.props.valueLink.requestChange(e.target.value);
            }
            function _handleLinkedCheckChange(e) {
                this.props.checkedLink.requestChange(e.target.checked);
            }
            var LinkedValueUtils = {
                Mixin: {
                    propTypes: {
                        value: function(props, propName, componentName) {
                            if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
                                return null;
                            }
                            return new Error("You provided a `value` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultValue`. Otherwise, " + "set either `onChange` or `readOnly`.");
                        },
                        checked: function(props, propName, componentName) {
                            if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
                                return null;
                            }
                            return new Error("You provided a `checked` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultChecked`. Otherwise, " + "set either `onChange` or `readOnly`.");
                        },
                        onChange: ReactPropTypes.func
                    }
                },
                getValue: function(input) {
                    if (input.props.valueLink) {
                        _assertValueLink(input);
                        return input.props.valueLink.value;
                    }
                    return input.props.value;
                },
                getChecked: function(input) {
                    if (input.props.checkedLink) {
                        _assertCheckedLink(input);
                        return input.props.checkedLink.value;
                    }
                    return input.props.checked;
                },
                getOnChange: function(input) {
                    if (input.props.valueLink) {
                        _assertValueLink(input);
                        return _handleLinkedValueChange;
                    } else if (input.props.checkedLink) {
                        _assertCheckedLink(input);
                        return _handleLinkedCheckChange;
                    }
                    return input.props.onChange;
                }
            };
            module.exports = LinkedValueUtils;
        }).call(this, require("_process"));
    }, {
        "./ReactPropTypes": 78,
        "./invariant": 135,
        _process: 156
    } ],
    24: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
            var accumulateInto = require("./accumulateInto");
            var forEachAccumulated = require("./forEachAccumulated");
            var invariant = require("./invariant");
            function remove(event) {
                event.remove();
            }
            var LocalEventTrapMixin = {
                trapBubbledEvent: function(topLevelType, handlerBaseName) {
                    "production" !== process.env.NODE_ENV ? invariant(this.isMounted(), "Must be mounted to trap events") : invariant(this.isMounted());
                    var node = this.getDOMNode();
                    "production" !== process.env.NODE_ENV ? invariant(node, "LocalEventTrapMixin.trapBubbledEvent(...): Requires node to be rendered.") : invariant(node);
                    var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, node);
                    this._localEventListeners = accumulateInto(this._localEventListeners, listener);
                },
                componentWillUnmount: function() {
                    if (this._localEventListeners) {
                        forEachAccumulated(this._localEventListeners, remove);
                    }
                }
            };
            module.exports = LocalEventTrapMixin;
        }).call(this, require("_process"));
    }, {
        "./ReactBrowserEventEmitter": 30,
        "./accumulateInto": 105,
        "./forEachAccumulated": 120,
        "./invariant": 135,
        _process: 156
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var emptyFunction = require("./emptyFunction");
        var topLevelTypes = EventConstants.topLevelTypes;
        var MobileSafariClickEventPlugin = {
            eventTypes: null,
            extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                if (topLevelType === topLevelTypes.topTouchStart) {
                    var target = nativeEvent.target;
                    if (target && !target.onclick) {
                        target.onclick = emptyFunction;
                    }
                }
            }
        };
        module.exports = MobileSafariClickEventPlugin;
    }, {
        "./EventConstants": 14,
        "./emptyFunction": 114
    } ],
    26: [ function(require, module, exports) {
        "use strict";
        function assign(target, sources) {
            if (target == null) {
                throw new TypeError("Object.assign target cannot be null or undefined");
            }
            var to = Object(target);
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
                var nextSource = arguments[nextIndex];
                if (nextSource == null) {
                    continue;
                }
                var from = Object(nextSource);
                for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }
            }
            return to;
        }
        module.exports = assign;
    }, {} ],
    27: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            var oneArgumentPooler = function(copyFieldsFrom) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, copyFieldsFrom);
                    return instance;
                } else {
                    return new Klass(copyFieldsFrom);
                }
            };
            var twoArgumentPooler = function(a1, a2) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, a1, a2);
                    return instance;
                } else {
                    return new Klass(a1, a2);
                }
            };
            var threeArgumentPooler = function(a1, a2, a3) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, a1, a2, a3);
                    return instance;
                } else {
                    return new Klass(a1, a2, a3);
                }
            };
            var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, a1, a2, a3, a4, a5);
                    return instance;
                } else {
                    return new Klass(a1, a2, a3, a4, a5);
                }
            };
            var standardReleaser = function(instance) {
                var Klass = this;
                "production" !== process.env.NODE_ENV ? invariant(instance instanceof Klass, "Trying to release an instance into a pool of a different type.") : invariant(instance instanceof Klass);
                if (instance.destructor) {
                    instance.destructor();
                }
                if (Klass.instancePool.length < Klass.poolSize) {
                    Klass.instancePool.push(instance);
                }
            };
            var DEFAULT_POOL_SIZE = 10;
            var DEFAULT_POOLER = oneArgumentPooler;
            var addPoolingTo = function(CopyConstructor, pooler) {
                var NewKlass = CopyConstructor;
                NewKlass.instancePool = [];
                NewKlass.getPooled = pooler || DEFAULT_POOLER;
                if (!NewKlass.poolSize) {
                    NewKlass.poolSize = DEFAULT_POOL_SIZE;
                }
                NewKlass.release = standardReleaser;
                return NewKlass;
            };
            var PooledClass = {
                addPoolingTo: addPoolingTo,
                oneArgumentPooler: oneArgumentPooler,
                twoArgumentPooler: twoArgumentPooler,
                threeArgumentPooler: threeArgumentPooler,
                fiveArgumentPooler: fiveArgumentPooler
            };
            module.exports = PooledClass;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    28: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var EventPluginUtils = require("./EventPluginUtils");
            var ReactChildren = require("./ReactChildren");
            var ReactComponent = require("./ReactComponent");
            var ReactClass = require("./ReactClass");
            var ReactContext = require("./ReactContext");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactElement = require("./ReactElement");
            var ReactElementValidator = require("./ReactElementValidator");
            var ReactDOM = require("./ReactDOM");
            var ReactDOMTextComponent = require("./ReactDOMTextComponent");
            var ReactDefaultInjection = require("./ReactDefaultInjection");
            var ReactInstanceHandles = require("./ReactInstanceHandles");
            var ReactMount = require("./ReactMount");
            var ReactPerf = require("./ReactPerf");
            var ReactPropTypes = require("./ReactPropTypes");
            var ReactReconciler = require("./ReactReconciler");
            var ReactServerRendering = require("./ReactServerRendering");
            var assign = require("./Object.assign");
            var findDOMNode = require("./findDOMNode");
            var onlyChild = require("./onlyChild");
            ReactDefaultInjection.inject();
            var createElement = ReactElement.createElement;
            var createFactory = ReactElement.createFactory;
            var cloneElement = ReactElement.cloneElement;
            if ("production" !== process.env.NODE_ENV) {
                createElement = ReactElementValidator.createElement;
                createFactory = ReactElementValidator.createFactory;
                cloneElement = ReactElementValidator.cloneElement;
            }
            var render = ReactPerf.measure("React", "render", ReactMount.render);
            var React = {
                Children: {
                    map: ReactChildren.map,
                    forEach: ReactChildren.forEach,
                    count: ReactChildren.count,
                    only: onlyChild
                },
                Component: ReactComponent,
                DOM: ReactDOM,
                PropTypes: ReactPropTypes,
                initializeTouchEvents: function(shouldUseTouch) {
                    EventPluginUtils.useTouchEvents = shouldUseTouch;
                },
                createClass: ReactClass.createClass,
                createElement: createElement,
                cloneElement: cloneElement,
                createFactory: createFactory,
                createMixin: function(mixin) {
                    return mixin;
                },
                constructAndRenderComponent: ReactMount.constructAndRenderComponent,
                constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
                findDOMNode: findDOMNode,
                render: render,
                renderToString: ReactServerRendering.renderToString,
                renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
                unmountComponentAtNode: ReactMount.unmountComponentAtNode,
                isValidElement: ReactElement.isValidElement,
                withContext: ReactContext.withContext,
                __spread: assign
            };
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === "function") {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
                    CurrentOwner: ReactCurrentOwner,
                    InstanceHandles: ReactInstanceHandles,
                    Mount: ReactMount,
                    Reconciler: ReactReconciler,
                    TextComponent: ReactDOMTextComponent
                });
            }
            if ("production" !== process.env.NODE_ENV) {
                var ExecutionEnvironment = require("./ExecutionEnvironment");
                if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
                    if (navigator.userAgent.indexOf("Chrome") > -1) {
                        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
                            console.debug("Download the React DevTools for a better development experience: " + "https://fb.me/react-devtools");
                        }
                    }
                    var expectedFeatures = [ Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze ];
                    for (var i = 0; i < expectedFeatures.length; i++) {
                        if (!expectedFeatures[i]) {
                            console.error("One or more ES5 shim/shams expected by React are not available: " + "https://fb.me/react-warning-polyfills");
                            break;
                        }
                    }
                }
            }
            React.version = "0.13.3";
            module.exports = React;
        }).call(this, require("_process"));
    }, {
        "./EventPluginUtils": 18,
        "./ExecutionEnvironment": 20,
        "./Object.assign": 26,
        "./ReactChildren": 32,
        "./ReactClass": 33,
        "./ReactComponent": 34,
        "./ReactContext": 38,
        "./ReactCurrentOwner": 39,
        "./ReactDOM": 40,
        "./ReactDOMTextComponent": 51,
        "./ReactDefaultInjection": 54,
        "./ReactElement": 57,
        "./ReactElementValidator": 58,
        "./ReactInstanceHandles": 66,
        "./ReactMount": 70,
        "./ReactPerf": 75,
        "./ReactPropTypes": 78,
        "./ReactReconciler": 81,
        "./ReactServerRendering": 84,
        "./findDOMNode": 117,
        "./onlyChild": 144,
        _process: 156
    } ],
    29: [ function(require, module, exports) {
        "use strict";
        var findDOMNode = require("./findDOMNode");
        var ReactBrowserComponentMixin = {
            getDOMNode: function() {
                return findDOMNode(this);
            }
        };
        module.exports = ReactBrowserComponentMixin;
    }, {
        "./findDOMNode": 117
    } ],
    30: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var EventPluginHub = require("./EventPluginHub");
        var EventPluginRegistry = require("./EventPluginRegistry");
        var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
        var ViewportMetrics = require("./ViewportMetrics");
        var assign = require("./Object.assign");
        var isEventSupported = require("./isEventSupported");
        var alreadyListeningTo = {};
        var isMonitoringScrollValue = false;
        var reactTopListenersCounter = 0;
        var topEventMapping = {
            topBlur: "blur",
            topChange: "change",
            topClick: "click",
            topCompositionEnd: "compositionend",
            topCompositionStart: "compositionstart",
            topCompositionUpdate: "compositionupdate",
            topContextMenu: "contextmenu",
            topCopy: "copy",
            topCut: "cut",
            topDoubleClick: "dblclick",
            topDrag: "drag",
            topDragEnd: "dragend",
            topDragEnter: "dragenter",
            topDragExit: "dragexit",
            topDragLeave: "dragleave",
            topDragOver: "dragover",
            topDragStart: "dragstart",
            topDrop: "drop",
            topFocus: "focus",
            topInput: "input",
            topKeyDown: "keydown",
            topKeyPress: "keypress",
            topKeyUp: "keyup",
            topMouseDown: "mousedown",
            topMouseMove: "mousemove",
            topMouseOut: "mouseout",
            topMouseOver: "mouseover",
            topMouseUp: "mouseup",
            topPaste: "paste",
            topScroll: "scroll",
            topSelectionChange: "selectionchange",
            topTextInput: "textInput",
            topTouchCancel: "touchcancel",
            topTouchEnd: "touchend",
            topTouchMove: "touchmove",
            topTouchStart: "touchstart",
            topWheel: "wheel"
        };
        var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);
        function getListeningForDocument(mountAt) {
            if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
                mountAt[topListenersIDKey] = reactTopListenersCounter++;
                alreadyListeningTo[mountAt[topListenersIDKey]] = {};
            }
            return alreadyListeningTo[mountAt[topListenersIDKey]];
        }
        var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
            ReactEventListener: null,
            injection: {
                injectReactEventListener: function(ReactEventListener) {
                    ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
                    ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
                }
            },
            setEnabled: function(enabled) {
                if (ReactBrowserEventEmitter.ReactEventListener) {
                    ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
                }
            },
            isEnabled: function() {
                return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
            },
            listenTo: function(registrationName, contentDocumentHandle) {
                var mountAt = contentDocumentHandle;
                var isListening = getListeningForDocument(mountAt);
                var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
                var topLevelTypes = EventConstants.topLevelTypes;
                for (var i = 0, l = dependencies.length; i < l; i++) {
                    var dependency = dependencies[i];
                    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
                        if (dependency === topLevelTypes.topWheel) {
                            if (isEventSupported("wheel")) {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "wheel", mountAt);
                            } else if (isEventSupported("mousewheel")) {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "mousewheel", mountAt);
                            } else {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "DOMMouseScroll", mountAt);
                            }
                        } else if (dependency === topLevelTypes.topScroll) {
                            if (isEventSupported("scroll", true)) {
                                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, "scroll", mountAt);
                            } else {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, "scroll", ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
                            }
                        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
                            if (isEventSupported("focus", true)) {
                                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, "focus", mountAt);
                                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, "blur", mountAt);
                            } else if (isEventSupported("focusin")) {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, "focusin", mountAt);
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, "focusout", mountAt);
                            }
                            isListening[topLevelTypes.topBlur] = true;
                            isListening[topLevelTypes.topFocus] = true;
                        } else if (topEventMapping.hasOwnProperty(dependency)) {
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
                        }
                        isListening[dependency] = true;
                    }
                }
            },
            trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
                return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
            },
            trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
                return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
            },
            ensureScrollValueMonitoring: function() {
                if (!isMonitoringScrollValue) {
                    var refresh = ViewportMetrics.refreshScrollValues;
                    ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
                    isMonitoringScrollValue = true;
                }
            },
            eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
            registrationNameModules: EventPluginHub.registrationNameModules,
            putListener: EventPluginHub.putListener,
            getListener: EventPluginHub.getListener,
            deleteListener: EventPluginHub.deleteListener,
            deleteAllListeners: EventPluginHub.deleteAllListeners
        });
        module.exports = ReactBrowserEventEmitter;
    }, {
        "./EventConstants": 14,
        "./EventPluginHub": 16,
        "./EventPluginRegistry": 17,
        "./Object.assign": 26,
        "./ReactEventEmitterMixin": 61,
        "./ViewportMetrics": 104,
        "./isEventSupported": 136
    } ],
    31: [ function(require, module, exports) {
        "use strict";
        var ReactReconciler = require("./ReactReconciler");
        var flattenChildren = require("./flattenChildren");
        var instantiateReactComponent = require("./instantiateReactComponent");
        var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
        var ReactChildReconciler = {
            instantiateChildren: function(nestedChildNodes, transaction, context) {
                var children = flattenChildren(nestedChildNodes);
                for (var name in children) {
                    if (children.hasOwnProperty(name)) {
                        var child = children[name];
                        var childInstance = instantiateReactComponent(child, null);
                        children[name] = childInstance;
                    }
                }
                return children;
            },
            updateChildren: function(prevChildren, nextNestedChildNodes, transaction, context) {
                var nextChildren = flattenChildren(nextNestedChildNodes);
                if (!nextChildren && !prevChildren) {
                    return null;
                }
                var name;
                for (name in nextChildren) {
                    if (!nextChildren.hasOwnProperty(name)) {
                        continue;
                    }
                    var prevChild = prevChildren && prevChildren[name];
                    var prevElement = prevChild && prevChild._currentElement;
                    var nextElement = nextChildren[name];
                    if (shouldUpdateReactComponent(prevElement, nextElement)) {
                        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
                        nextChildren[name] = prevChild;
                    } else {
                        if (prevChild) {
                            ReactReconciler.unmountComponent(prevChild, name);
                        }
                        var nextChildInstance = instantiateReactComponent(nextElement, null);
                        nextChildren[name] = nextChildInstance;
                    }
                }
                for (name in prevChildren) {
                    if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
                        ReactReconciler.unmountComponent(prevChildren[name]);
                    }
                }
                return nextChildren;
            },
            unmountChildren: function(renderedChildren) {
                for (var name in renderedChildren) {
                    var renderedChild = renderedChildren[name];
                    ReactReconciler.unmountComponent(renderedChild);
                }
            }
        };
        module.exports = ReactChildReconciler;
    }, {
        "./ReactReconciler": 81,
        "./flattenChildren": 118,
        "./instantiateReactComponent": 134,
        "./shouldUpdateReactComponent": 151
    } ],
    32: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var PooledClass = require("./PooledClass");
            var ReactFragment = require("./ReactFragment");
            var traverseAllChildren = require("./traverseAllChildren");
            var warning = require("./warning");
            var twoArgumentPooler = PooledClass.twoArgumentPooler;
            var threeArgumentPooler = PooledClass.threeArgumentPooler;
            function ForEachBookKeeping(forEachFunction, forEachContext) {
                this.forEachFunction = forEachFunction;
                this.forEachContext = forEachContext;
            }
            PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
            function forEachSingleChild(traverseContext, child, name, i) {
                var forEachBookKeeping = traverseContext;
                forEachBookKeeping.forEachFunction.call(forEachBookKeeping.forEachContext, child, i);
            }
            function forEachChildren(children, forEachFunc, forEachContext) {
                if (children == null) {
                    return children;
                }
                var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
                traverseAllChildren(children, forEachSingleChild, traverseContext);
                ForEachBookKeeping.release(traverseContext);
            }
            function MapBookKeeping(mapResult, mapFunction, mapContext) {
                this.mapResult = mapResult;
                this.mapFunction = mapFunction;
                this.mapContext = mapContext;
            }
            PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
            function mapSingleChildIntoContext(traverseContext, child, name, i) {
                var mapBookKeeping = traverseContext;
                var mapResult = mapBookKeeping.mapResult;
                var keyUnique = !mapResult.hasOwnProperty(name);
                if ("production" !== process.env.NODE_ENV) {
                    "production" !== process.env.NODE_ENV ? warning(keyUnique, "ReactChildren.map(...): Encountered two children with the same key, " + "`%s`. Child keys must be unique; when two children share a key, only " + "the first child will be used.", name) : null;
                }
                if (keyUnique) {
                    var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
                    mapResult[name] = mappedChild;
                }
            }
            function mapChildren(children, func, context) {
                if (children == null) {
                    return children;
                }
                var mapResult = {};
                var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
                traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
                MapBookKeeping.release(traverseContext);
                return ReactFragment.create(mapResult);
            }
            function forEachSingleChildDummy(traverseContext, child, name, i) {
                return null;
            }
            function countChildren(children, context) {
                return traverseAllChildren(children, forEachSingleChildDummy, null);
            }
            var ReactChildren = {
                forEach: forEachChildren,
                map: mapChildren,
                count: countChildren
            };
            module.exports = ReactChildren;
        }).call(this, require("_process"));
    }, {
        "./PooledClass": 27,
        "./ReactFragment": 63,
        "./traverseAllChildren": 153,
        "./warning": 154,
        _process: 156
    } ],
    33: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactComponent = require("./ReactComponent");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactElement = require("./ReactElement");
            var ReactErrorUtils = require("./ReactErrorUtils");
            var ReactInstanceMap = require("./ReactInstanceMap");
            var ReactLifeCycle = require("./ReactLifeCycle");
            var ReactPropTypeLocations = require("./ReactPropTypeLocations");
            var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
            var ReactUpdateQueue = require("./ReactUpdateQueue");
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            var keyMirror = require("./keyMirror");
            var keyOf = require("./keyOf");
            var warning = require("./warning");
            var MIXINS_KEY = keyOf({
                mixins: null
            });
            var SpecPolicy = keyMirror({
                DEFINE_ONCE: null,
                DEFINE_MANY: null,
                OVERRIDE_BASE: null,
                DEFINE_MANY_MERGED: null
            });
            var injectedMixins = [];
            var ReactClassInterface = {
                mixins: SpecPolicy.DEFINE_MANY,
                statics: SpecPolicy.DEFINE_MANY,
                propTypes: SpecPolicy.DEFINE_MANY,
                contextTypes: SpecPolicy.DEFINE_MANY,
                childContextTypes: SpecPolicy.DEFINE_MANY,
                getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
                getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
                getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
                render: SpecPolicy.DEFINE_ONCE,
                componentWillMount: SpecPolicy.DEFINE_MANY,
                componentDidMount: SpecPolicy.DEFINE_MANY,
                componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
                shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
                componentWillUpdate: SpecPolicy.DEFINE_MANY,
                componentDidUpdate: SpecPolicy.DEFINE_MANY,
                componentWillUnmount: SpecPolicy.DEFINE_MANY,
                updateComponent: SpecPolicy.OVERRIDE_BASE
            };
            var RESERVED_SPEC_KEYS = {
                displayName: function(Constructor, displayName) {
                    Constructor.displayName = displayName;
                },
                mixins: function(Constructor, mixins) {
                    if (mixins) {
                        for (var i = 0; i < mixins.length; i++) {
                            mixSpecIntoComponent(Constructor, mixins[i]);
                        }
                    }
                },
                childContextTypes: function(Constructor, childContextTypes) {
                    if ("production" !== process.env.NODE_ENV) {
                        validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
                    }
                    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
                },
                contextTypes: function(Constructor, contextTypes) {
                    if ("production" !== process.env.NODE_ENV) {
                        validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
                    }
                    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
                },
                getDefaultProps: function(Constructor, getDefaultProps) {
                    if (Constructor.getDefaultProps) {
                        Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
                    } else {
                        Constructor.getDefaultProps = getDefaultProps;
                    }
                },
                propTypes: function(Constructor, propTypes) {
                    if ("production" !== process.env.NODE_ENV) {
                        validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
                    }
                    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
                },
                statics: function(Constructor, statics) {
                    mixStaticSpecIntoComponent(Constructor, statics);
                }
            };
            function validateTypeDef(Constructor, typeDef, location) {
                for (var propName in typeDef) {
                    if (typeDef.hasOwnProperty(propName)) {
                        "production" !== process.env.NODE_ENV ? warning(typeof typeDef[propName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from " + "React.PropTypes.", Constructor.displayName || "ReactClass", ReactPropTypeLocationNames[location], propName) : null;
                    }
                }
            }
            function validateMethodOverride(proto, name) {
                var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
                if (ReactClassMixin.hasOwnProperty(name)) {
                    "production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, "ReactClassInterface: You are attempting to override " + "`%s` from your class specification. Ensure that your method names " + "do not overlap with React methods.", name) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE);
                }
                if (proto.hasOwnProperty(name)) {
                    "production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, "ReactClassInterface: You are attempting to define " + "`%s` on your component more than once. This conflict may be due " + "to a mixin.", name) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED);
                }
            }
            function mixSpecIntoComponent(Constructor, spec) {
                if (!spec) {
                    return;
                }
                "production" !== process.env.NODE_ENV ? invariant(typeof spec !== "function", "ReactClass: You're attempting to " + "use a component class as a mixin. Instead, just use a regular object.") : invariant(typeof spec !== "function");
                "production" !== process.env.NODE_ENV ? invariant(!ReactElement.isValidElement(spec), "ReactClass: You're attempting to " + "use a component as a mixin. Instead, just use a regular object.") : invariant(!ReactElement.isValidElement(spec));
                var proto = Constructor.prototype;
                if (spec.hasOwnProperty(MIXINS_KEY)) {
                    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
                }
                for (var name in spec) {
                    if (!spec.hasOwnProperty(name)) {
                        continue;
                    }
                    if (name === MIXINS_KEY) {
                        continue;
                    }
                    var property = spec[name];
                    validateMethodOverride(proto, name);
                    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
                        RESERVED_SPEC_KEYS[name](Constructor, property);
                    } else {
                        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
                        var isAlreadyDefined = proto.hasOwnProperty(name);
                        var markedDontBind = property && property.__reactDontBind;
                        var isFunction = typeof property === "function";
                        var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && !markedDontBind;
                        if (shouldAutoBind) {
                            if (!proto.__reactAutoBindMap) {
                                proto.__reactAutoBindMap = {};
                            }
                            proto.__reactAutoBindMap[name] = property;
                            proto[name] = property;
                        } else {
                            if (isAlreadyDefined) {
                                var specPolicy = ReactClassInterface[name];
                                "production" !== process.env.NODE_ENV ? invariant(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY), "ReactClass: Unexpected spec policy %s for key %s " + "when mixing in component specs.", specPolicy, name) : invariant(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY));
                                if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                                    proto[name] = createMergedResultFunction(proto[name], property);
                                } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                                    proto[name] = createChainedFunction(proto[name], property);
                                }
                            } else {
                                proto[name] = property;
                                if ("production" !== process.env.NODE_ENV) {
                                    if (typeof property === "function" && spec.displayName) {
                                        proto[name].displayName = spec.displayName + "_" + name;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            function mixStaticSpecIntoComponent(Constructor, statics) {
                if (!statics) {
                    return;
                }
                for (var name in statics) {
                    var property = statics[name];
                    if (!statics.hasOwnProperty(name)) {
                        continue;
                    }
                    var isReserved = name in RESERVED_SPEC_KEYS;
                    "production" !== process.env.NODE_ENV ? invariant(!isReserved, "ReactClass: You are attempting to define a reserved " + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + "as an instance property instead; it will still be accessible on the " + "constructor.", name) : invariant(!isReserved);
                    var isInherited = name in Constructor;
                    "production" !== process.env.NODE_ENV ? invariant(!isInherited, "ReactClass: You are attempting to define " + "`%s` on your component more than once. This conflict may be " + "due to a mixin.", name) : invariant(!isInherited);
                    Constructor[name] = property;
                }
            }
            function mergeIntoWithNoDuplicateKeys(one, two) {
                "production" !== process.env.NODE_ENV ? invariant(one && two && typeof one === "object" && typeof two === "object", "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.") : invariant(one && two && typeof one === "object" && typeof two === "object");
                for (var key in two) {
                    if (two.hasOwnProperty(key)) {
                        "production" !== process.env.NODE_ENV ? invariant(one[key] === undefined, "mergeIntoWithNoDuplicateKeys(): " + "Tried to merge two objects with the same key: `%s`. This conflict " + "may be due to a mixin; in particular, this may be caused by two " + "getInitialState() or getDefaultProps() methods returning objects " + "with clashing keys.", key) : invariant(one[key] === undefined);
                        one[key] = two[key];
                    }
                }
                return one;
            }
            function createMergedResultFunction(one, two) {
                return function mergedResult() {
                    var a = one.apply(this, arguments);
                    var b = two.apply(this, arguments);
                    if (a == null) {
                        return b;
                    } else if (b == null) {
                        return a;
                    }
                    var c = {};
                    mergeIntoWithNoDuplicateKeys(c, a);
                    mergeIntoWithNoDuplicateKeys(c, b);
                    return c;
                };
            }
            function createChainedFunction(one, two) {
                return function chainedFunction() {
                    one.apply(this, arguments);
                    two.apply(this, arguments);
                };
            }
            function bindAutoBindMethod(component, method) {
                var boundMethod = method.bind(component);
                if ("production" !== process.env.NODE_ENV) {
                    boundMethod.__reactBoundContext = component;
                    boundMethod.__reactBoundMethod = method;
                    boundMethod.__reactBoundArguments = null;
                    var componentName = component.constructor.displayName;
                    var _bind = boundMethod.bind;
                    boundMethod.bind = function(newThis) {
                        for (var args = [], $__0 = 1, $__1 = arguments.length; $__0 < $__1; $__0++) args.push(arguments[$__0]);
                        if (newThis !== component && newThis !== null) {
                            "production" !== process.env.NODE_ENV ? warning(false, "bind(): React component methods may only be bound to the " + "component instance. See %s", componentName) : null;
                        } else if (!args.length) {
                            "production" !== process.env.NODE_ENV ? warning(false, "bind(): You are binding a component method to the component. " + "React does this for you automatically in a high-performance " + "way, so you can safely remove this call. See %s", componentName) : null;
                            return boundMethod;
                        }
                        var reboundMethod = _bind.apply(boundMethod, arguments);
                        reboundMethod.__reactBoundContext = component;
                        reboundMethod.__reactBoundMethod = method;
                        reboundMethod.__reactBoundArguments = args;
                        return reboundMethod;
                    };
                }
                return boundMethod;
            }
            function bindAutoBindMethods(component) {
                for (var autoBindKey in component.__reactAutoBindMap) {
                    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
                        var method = component.__reactAutoBindMap[autoBindKey];
                        component[autoBindKey] = bindAutoBindMethod(component, ReactErrorUtils.guard(method, component.constructor.displayName + "." + autoBindKey));
                    }
                }
            }
            var typeDeprecationDescriptor = {
                enumerable: false,
                get: function() {
                    var displayName = this.displayName || this.name || "Component";
                    "production" !== process.env.NODE_ENV ? warning(false, "%s.type is deprecated. Use %s directly to access the class.", displayName, displayName) : null;
                    Object.defineProperty(this, "type", {
                        value: this
                    });
                    return this;
                }
            };
            var ReactClassMixin = {
                replaceState: function(newState, callback) {
                    ReactUpdateQueue.enqueueReplaceState(this, newState);
                    if (callback) {
                        ReactUpdateQueue.enqueueCallback(this, callback);
                    }
                },
                isMounted: function() {
                    if ("production" !== process.env.NODE_ENV) {
                        var owner = ReactCurrentOwner.current;
                        if (owner !== null) {
                            "production" !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", owner.getName() || "A component") : null;
                            owner._warnedAboutRefsInRender = true;
                        }
                    }
                    var internalInstance = ReactInstanceMap.get(this);
                    return internalInstance && internalInstance !== ReactLifeCycle.currentlyMountingInstance;
                },
                setProps: function(partialProps, callback) {
                    ReactUpdateQueue.enqueueSetProps(this, partialProps);
                    if (callback) {
                        ReactUpdateQueue.enqueueCallback(this, callback);
                    }
                },
                replaceProps: function(newProps, callback) {
                    ReactUpdateQueue.enqueueReplaceProps(this, newProps);
                    if (callback) {
                        ReactUpdateQueue.enqueueCallback(this, callback);
                    }
                }
            };
            var ReactClassComponent = function() {};
            assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
            var ReactClass = {
                createClass: function(spec) {
                    var Constructor = function(props, context) {
                        if ("production" !== process.env.NODE_ENV) {
                            "production" !== process.env.NODE_ENV ? warning(this instanceof Constructor, "Something is calling a React component directly. Use a factory or " + "JSX instead. See: https://fb.me/react-legacyfactory") : null;
                        }
                        if (this.__reactAutoBindMap) {
                            bindAutoBindMethods(this);
                        }
                        this.props = props;
                        this.context = context;
                        this.state = null;
                        var initialState = this.getInitialState ? this.getInitialState() : null;
                        if ("production" !== process.env.NODE_ENV) {
                            if (typeof initialState === "undefined" && this.getInitialState._isMockFunction) {
                                initialState = null;
                            }
                        }
                        "production" !== process.env.NODE_ENV ? invariant(typeof initialState === "object" && !Array.isArray(initialState), "%s.getInitialState(): must return an object or null", Constructor.displayName || "ReactCompositeComponent") : invariant(typeof initialState === "object" && !Array.isArray(initialState));
                        this.state = initialState;
                    };
                    Constructor.prototype = new ReactClassComponent();
                    Constructor.prototype.constructor = Constructor;
                    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
                    mixSpecIntoComponent(Constructor, spec);
                    if (Constructor.getDefaultProps) {
                        Constructor.defaultProps = Constructor.getDefaultProps();
                    }
                    if ("production" !== process.env.NODE_ENV) {
                        if (Constructor.getDefaultProps) {
                            Constructor.getDefaultProps.isReactClassApproved = {};
                        }
                        if (Constructor.prototype.getInitialState) {
                            Constructor.prototype.getInitialState.isReactClassApproved = {};
                        }
                    }
                    "production" !== process.env.NODE_ENV ? invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method.") : invariant(Constructor.prototype.render);
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(!Constructor.prototype.componentShouldUpdate, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", spec.displayName || "A component") : null;
                    }
                    for (var methodName in ReactClassInterface) {
                        if (!Constructor.prototype[methodName]) {
                            Constructor.prototype[methodName] = null;
                        }
                    }
                    Constructor.type = Constructor;
                    if ("production" !== process.env.NODE_ENV) {
                        try {
                            Object.defineProperty(Constructor, "type", typeDeprecationDescriptor);
                        } catch (x) {}
                    }
                    return Constructor;
                },
                injection: {
                    injectMixin: function(mixin) {
                        injectedMixins.push(mixin);
                    }
                }
            };
            module.exports = ReactClass;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./ReactComponent": 34,
        "./ReactCurrentOwner": 39,
        "./ReactElement": 57,
        "./ReactErrorUtils": 60,
        "./ReactInstanceMap": 67,
        "./ReactLifeCycle": 68,
        "./ReactPropTypeLocationNames": 76,
        "./ReactPropTypeLocations": 77,
        "./ReactUpdateQueue": 86,
        "./invariant": 135,
        "./keyMirror": 140,
        "./keyOf": 141,
        "./warning": 154,
        _process: 156
    } ],
    34: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactUpdateQueue = require("./ReactUpdateQueue");
            var invariant = require("./invariant");
            var warning = require("./warning");
            function ReactComponent(props, context) {
                this.props = props;
                this.context = context;
            }
            ReactComponent.prototype.setState = function(partialState, callback) {
                "production" !== process.env.NODE_ENV ? invariant(typeof partialState === "object" || typeof partialState === "function" || partialState == null, "setState(...): takes an object of state variables to update or a " + "function which returns an object of state variables.") : invariant(typeof partialState === "object" || typeof partialState === "function" || partialState == null);
                if ("production" !== process.env.NODE_ENV) {
                    "production" !== process.env.NODE_ENV ? warning(partialState != null, "setState(...): You passed an undefined or null state object; " + "instead, use forceUpdate().") : null;
                }
                ReactUpdateQueue.enqueueSetState(this, partialState);
                if (callback) {
                    ReactUpdateQueue.enqueueCallback(this, callback);
                }
            };
            ReactComponent.prototype.forceUpdate = function(callback) {
                ReactUpdateQueue.enqueueForceUpdate(this);
                if (callback) {
                    ReactUpdateQueue.enqueueCallback(this, callback);
                }
            };
            if ("production" !== process.env.NODE_ENV) {
                var deprecatedAPIs = {
                    getDOMNode: [ "getDOMNode", "Use React.findDOMNode(component) instead." ],
                    isMounted: [ "isMounted", "Instead, make sure to clean up subscriptions and pending requests in " + "componentWillUnmount to prevent memory leaks." ],
                    replaceProps: [ "replaceProps", "Instead, call React.render again at the top level." ],
                    replaceState: [ "replaceState", "Refactor your code to use setState instead (see " + "https://github.com/facebook/react/issues/3236)." ],
                    setProps: [ "setProps", "Instead, call React.render again at the top level." ]
                };
                var defineDeprecationWarning = function(methodName, info) {
                    try {
                        Object.defineProperty(ReactComponent.prototype, methodName, {
                            get: function() {
                                "production" !== process.env.NODE_ENV ? warning(false, "%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]) : null;
                                return undefined;
                            }
                        });
                    } catch (x) {}
                };
                for (var fnName in deprecatedAPIs) {
                    if (deprecatedAPIs.hasOwnProperty(fnName)) {
                        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                    }
                }
            }
            module.exports = ReactComponent;
        }).call(this, require("_process"));
    }, {
        "./ReactUpdateQueue": 86,
        "./invariant": 135,
        "./warning": 154,
        _process: 156
    } ],
    35: [ function(require, module, exports) {
        "use strict";
        var ReactDOMIDOperations = require("./ReactDOMIDOperations");
        var ReactMount = require("./ReactMount");
        var ReactComponentBrowserEnvironment = {
            processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
            replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
            unmountIDFromEnvironment: function(rootNodeID) {
                ReactMount.purgeID(rootNodeID);
            }
        };
        module.exports = ReactComponentBrowserEnvironment;
    }, {
        "./ReactDOMIDOperations": 44,
        "./ReactMount": 70
    } ],
    36: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            var injected = false;
            var ReactComponentEnvironment = {
                unmountIDFromEnvironment: null,
                replaceNodeWithMarkupByID: null,
                processChildrenUpdates: null,
                injection: {
                    injectEnvironment: function(environment) {
                        "production" !== process.env.NODE_ENV ? invariant(!injected, "ReactCompositeComponent: injectEnvironment() can only be called once.") : invariant(!injected);
                        ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
                        ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
                        ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
                        injected = true;
                    }
                }
            };
            module.exports = ReactComponentEnvironment;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    37: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactComponentEnvironment = require("./ReactComponentEnvironment");
            var ReactContext = require("./ReactContext");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactElement = require("./ReactElement");
            var ReactElementValidator = require("./ReactElementValidator");
            var ReactInstanceMap = require("./ReactInstanceMap");
            var ReactLifeCycle = require("./ReactLifeCycle");
            var ReactNativeComponent = require("./ReactNativeComponent");
            var ReactPerf = require("./ReactPerf");
            var ReactPropTypeLocations = require("./ReactPropTypeLocations");
            var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
            var ReactReconciler = require("./ReactReconciler");
            var ReactUpdates = require("./ReactUpdates");
            var assign = require("./Object.assign");
            var emptyObject = require("./emptyObject");
            var invariant = require("./invariant");
            var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
            var warning = require("./warning");
            function getDeclarationErrorAddendum(component) {
                var owner = component._currentElement._owner || null;
                if (owner) {
                    var name = owner.getName();
                    if (name) {
                        return " Check the render method of `" + name + "`.";
                    }
                }
                return "";
            }
            var nextMountID = 1;
            var ReactCompositeComponentMixin = {
                construct: function(element) {
                    this._currentElement = element;
                    this._rootNodeID = null;
                    this._instance = null;
                    this._pendingElement = null;
                    this._pendingStateQueue = null;
                    this._pendingReplaceState = false;
                    this._pendingForceUpdate = false;
                    this._renderedComponent = null;
                    this._context = null;
                    this._mountOrder = 0;
                    this._isTopLevel = false;
                    this._pendingCallbacks = null;
                },
                mountComponent: function(rootID, transaction, context) {
                    this._context = context;
                    this._mountOrder = nextMountID++;
                    this._rootNodeID = rootID;
                    var publicProps = this._processProps(this._currentElement.props);
                    var publicContext = this._processContext(this._currentElement._context);
                    var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
                    var inst = new Component(publicProps, publicContext);
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(inst.render != null, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render` in your " + "component or you may have accidentally tried to render an element " + "whose type is a function that isn't a React component.", Component.displayName || Component.name || "Component") : null;
                    }
                    inst.props = publicProps;
                    inst.context = publicContext;
                    inst.refs = emptyObject;
                    this._instance = inst;
                    ReactInstanceMap.set(inst, this);
                    if ("production" !== process.env.NODE_ENV) {
                        this._warnIfContextsDiffer(this._currentElement._context, context);
                    }
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", this.getName() || "a component") : null;
                        "production" !== process.env.NODE_ENV ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", this.getName() || "a component") : null;
                        "production" !== process.env.NODE_ENV ? warning(!inst.propTypes, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", this.getName() || "a component") : null;
                        "production" !== process.env.NODE_ENV ? warning(!inst.contextTypes, "contextTypes was defined as an instance property on %s. Use a " + "static property to define contextTypes instead.", this.getName() || "a component") : null;
                        "production" !== process.env.NODE_ENV ? warning(typeof inst.componentShouldUpdate !== "function", "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", this.getName() || "A component") : null;
                    }
                    var initialState = inst.state;
                    if (initialState === undefined) {
                        inst.state = initialState = null;
                    }
                    "production" !== process.env.NODE_ENV ? invariant(typeof initialState === "object" && !Array.isArray(initialState), "%s.state: must be set to an object or null", this.getName() || "ReactCompositeComponent") : invariant(typeof initialState === "object" && !Array.isArray(initialState));
                    this._pendingStateQueue = null;
                    this._pendingReplaceState = false;
                    this._pendingForceUpdate = false;
                    var childContext;
                    var renderedElement;
                    var previouslyMounting = ReactLifeCycle.currentlyMountingInstance;
                    ReactLifeCycle.currentlyMountingInstance = this;
                    try {
                        if (inst.componentWillMount) {
                            inst.componentWillMount();
                            if (this._pendingStateQueue) {
                                inst.state = this._processPendingState(inst.props, inst.context);
                            }
                        }
                        childContext = this._getValidatedChildContext(context);
                        renderedElement = this._renderValidatedComponent(childContext);
                    } finally {
                        ReactLifeCycle.currentlyMountingInstance = previouslyMounting;
                    }
                    this._renderedComponent = this._instantiateReactComponent(renderedElement, this._currentElement.type);
                    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._mergeChildContext(context, childContext));
                    if (inst.componentDidMount) {
                        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
                    }
                    return markup;
                },
                unmountComponent: function() {
                    var inst = this._instance;
                    if (inst.componentWillUnmount) {
                        var previouslyUnmounting = ReactLifeCycle.currentlyUnmountingInstance;
                        ReactLifeCycle.currentlyUnmountingInstance = this;
                        try {
                            inst.componentWillUnmount();
                        } finally {
                            ReactLifeCycle.currentlyUnmountingInstance = previouslyUnmounting;
                        }
                    }
                    ReactReconciler.unmountComponent(this._renderedComponent);
                    this._renderedComponent = null;
                    this._pendingStateQueue = null;
                    this._pendingReplaceState = false;
                    this._pendingForceUpdate = false;
                    this._pendingCallbacks = null;
                    this._pendingElement = null;
                    this._context = null;
                    this._rootNodeID = null;
                    ReactInstanceMap.remove(inst);
                },
                _setPropsInternal: function(partialProps, callback) {
                    var element = this._pendingElement || this._currentElement;
                    this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
                    ReactUpdates.enqueueUpdate(this, callback);
                },
                _maskContext: function(context) {
                    var maskedContext = null;
                    if (typeof this._currentElement.type === "string") {
                        return emptyObject;
                    }
                    var contextTypes = this._currentElement.type.contextTypes;
                    if (!contextTypes) {
                        return emptyObject;
                    }
                    maskedContext = {};
                    for (var contextName in contextTypes) {
                        maskedContext[contextName] = context[contextName];
                    }
                    return maskedContext;
                },
                _processContext: function(context) {
                    var maskedContext = this._maskContext(context);
                    if ("production" !== process.env.NODE_ENV) {
                        var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
                        if (Component.contextTypes) {
                            this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
                        }
                    }
                    return maskedContext;
                },
                _getValidatedChildContext: function(currentContext) {
                    var inst = this._instance;
                    var childContext = inst.getChildContext && inst.getChildContext();
                    if (childContext) {
                        "production" !== process.env.NODE_ENV ? invariant(typeof inst.constructor.childContextTypes === "object", "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", this.getName() || "ReactCompositeComponent") : invariant(typeof inst.constructor.childContextTypes === "object");
                        if ("production" !== process.env.NODE_ENV) {
                            this._checkPropTypes(inst.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
                        }
                        for (var name in childContext) {
                            "production" !== process.env.NODE_ENV ? invariant(name in inst.constructor.childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || "ReactCompositeComponent", name) : invariant(name in inst.constructor.childContextTypes);
                        }
                        return childContext;
                    }
                    return null;
                },
                _mergeChildContext: function(currentContext, childContext) {
                    if (childContext) {
                        return assign({}, currentContext, childContext);
                    }
                    return currentContext;
                },
                _processProps: function(newProps) {
                    if ("production" !== process.env.NODE_ENV) {
                        var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
                        if (Component.propTypes) {
                            this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
                        }
                    }
                    return newProps;
                },
                _checkPropTypes: function(propTypes, props, location) {
                    var componentName = this.getName();
                    for (var propName in propTypes) {
                        if (propTypes.hasOwnProperty(propName)) {
                            var error;
                            try {
                                "production" !== process.env.NODE_ENV ? invariant(typeof propTypes[propName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually " + "from React.PropTypes.", componentName || "React class", ReactPropTypeLocationNames[location], propName) : invariant(typeof propTypes[propName] === "function");
                                error = propTypes[propName](props, propName, componentName, location);
                            } catch (ex) {
                                error = ex;
                            }
                            if (error instanceof Error) {
                                var addendum = getDeclarationErrorAddendum(this);
                                if (location === ReactPropTypeLocations.prop) {
                                    "production" !== process.env.NODE_ENV ? warning(false, "Failed Composite propType: %s%s", error.message, addendum) : null;
                                } else {
                                    "production" !== process.env.NODE_ENV ? warning(false, "Failed Context Types: %s%s", error.message, addendum) : null;
                                }
                            }
                        }
                    }
                },
                receiveComponent: function(nextElement, transaction, nextContext) {
                    var prevElement = this._currentElement;
                    var prevContext = this._context;
                    this._pendingElement = null;
                    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
                },
                performUpdateIfNecessary: function(transaction) {
                    if (this._pendingElement != null) {
                        ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
                    }
                    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
                        if ("production" !== process.env.NODE_ENV) {
                            ReactElementValidator.checkAndWarnForMutatedProps(this._currentElement);
                        }
                        this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
                    }
                },
                _warnIfContextsDiffer: function(ownerBasedContext, parentBasedContext) {
                    ownerBasedContext = this._maskContext(ownerBasedContext);
                    parentBasedContext = this._maskContext(parentBasedContext);
                    var parentKeys = Object.keys(parentBasedContext).sort();
                    var displayName = this.getName() || "ReactCompositeComponent";
                    for (var i = 0; i < parentKeys.length; i++) {
                        var key = parentKeys[i];
                        "production" !== process.env.NODE_ENV ? warning(ownerBasedContext[key] === parentBasedContext[key], "owner-based and parent-based contexts differ " + "(values: `%s` vs `%s`) for key (%s) while mounting %s " + "(see: http://fb.me/react-context-by-parent)", ownerBasedContext[key], parentBasedContext[key], key, displayName) : null;
                    }
                },
                updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
                    var inst = this._instance;
                    var nextContext = inst.context;
                    var nextProps = inst.props;
                    if (prevParentElement !== nextParentElement) {
                        nextContext = this._processContext(nextParentElement._context);
                        nextProps = this._processProps(nextParentElement.props);
                        if ("production" !== process.env.NODE_ENV) {
                            if (nextUnmaskedContext != null) {
                                this._warnIfContextsDiffer(nextParentElement._context, nextUnmaskedContext);
                            }
                        }
                        if (inst.componentWillReceiveProps) {
                            inst.componentWillReceiveProps(nextProps, nextContext);
                        }
                    }
                    var nextState = this._processPendingState(nextProps, nextContext);
                    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(typeof shouldUpdate !== "undefined", "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", this.getName() || "ReactCompositeComponent") : null;
                    }
                    if (shouldUpdate) {
                        this._pendingForceUpdate = false;
                        this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
                    } else {
                        this._currentElement = nextParentElement;
                        this._context = nextUnmaskedContext;
                        inst.props = nextProps;
                        inst.state = nextState;
                        inst.context = nextContext;
                    }
                },
                _processPendingState: function(props, context) {
                    var inst = this._instance;
                    var queue = this._pendingStateQueue;
                    var replace = this._pendingReplaceState;
                    this._pendingReplaceState = false;
                    this._pendingStateQueue = null;
                    if (!queue) {
                        return inst.state;
                    }
                    if (replace && queue.length === 1) {
                        return queue[0];
                    }
                    var nextState = assign({}, replace ? queue[0] : inst.state);
                    for (var i = replace ? 1 : 0; i < queue.length; i++) {
                        var partial = queue[i];
                        assign(nextState, typeof partial === "function" ? partial.call(inst, nextState, props, context) : partial);
                    }
                    return nextState;
                },
                _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
                    var inst = this._instance;
                    var prevProps = inst.props;
                    var prevState = inst.state;
                    var prevContext = inst.context;
                    if (inst.componentWillUpdate) {
                        inst.componentWillUpdate(nextProps, nextState, nextContext);
                    }
                    this._currentElement = nextElement;
                    this._context = unmaskedContext;
                    inst.props = nextProps;
                    inst.state = nextState;
                    inst.context = nextContext;
                    this._updateRenderedComponent(transaction, unmaskedContext);
                    if (inst.componentDidUpdate) {
                        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
                    }
                },
                _updateRenderedComponent: function(transaction, context) {
                    var prevComponentInstance = this._renderedComponent;
                    var prevRenderedElement = prevComponentInstance._currentElement;
                    var childContext = this._getValidatedChildContext();
                    var nextRenderedElement = this._renderValidatedComponent(childContext);
                    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
                        ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._mergeChildContext(context, childContext));
                    } else {
                        var thisID = this._rootNodeID;
                        var prevComponentID = prevComponentInstance._rootNodeID;
                        ReactReconciler.unmountComponent(prevComponentInstance);
                        this._renderedComponent = this._instantiateReactComponent(nextRenderedElement, this._currentElement.type);
                        var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._mergeChildContext(context, childContext));
                        this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
                    }
                },
                _replaceNodeWithMarkupByID: function(prevComponentID, nextMarkup) {
                    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
                },
                _renderValidatedComponentWithoutOwnerOrContext: function() {
                    var inst = this._instance;
                    var renderedComponent = inst.render();
                    if ("production" !== process.env.NODE_ENV) {
                        if (typeof renderedComponent === "undefined" && inst.render._isMockFunction) {
                            renderedComponent = null;
                        }
                    }
                    return renderedComponent;
                },
                _renderValidatedComponent: function(childContext) {
                    var renderedComponent;
                    var previousContext = ReactContext.current;
                    ReactContext.current = this._mergeChildContext(this._currentElement._context, childContext);
                    ReactCurrentOwner.current = this;
                    try {
                        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
                    } finally {
                        ReactContext.current = previousContext;
                        ReactCurrentOwner.current = null;
                    }
                    "production" !== process.env.NODE_ENV ? invariant(renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent), "%s.render(): A valid ReactComponent must be returned. You may have " + "returned undefined, an array or some other invalid object.", this.getName() || "ReactCompositeComponent") : invariant(renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent));
                    return renderedComponent;
                },
                attachRef: function(ref, component) {
                    var inst = this.getPublicInstance();
                    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
                    refs[ref] = component.getPublicInstance();
                },
                detachRef: function(ref) {
                    var refs = this.getPublicInstance().refs;
                    delete refs[ref];
                },
                getName: function() {
                    var type = this._currentElement.type;
                    var constructor = this._instance && this._instance.constructor;
                    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
                },
                getPublicInstance: function() {
                    return this._instance;
                },
                _instantiateReactComponent: null
            };
            ReactPerf.measureMethods(ReactCompositeComponentMixin, "ReactCompositeComponent", {
                mountComponent: "mountComponent",
                updateComponent: "updateComponent",
                _renderValidatedComponent: "_renderValidatedComponent"
            });
            var ReactCompositeComponent = {
                Mixin: ReactCompositeComponentMixin
            };
            module.exports = ReactCompositeComponent;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./ReactComponentEnvironment": 36,
        "./ReactContext": 38,
        "./ReactCurrentOwner": 39,
        "./ReactElement": 57,
        "./ReactElementValidator": 58,
        "./ReactInstanceMap": 67,
        "./ReactLifeCycle": 68,
        "./ReactNativeComponent": 73,
        "./ReactPerf": 75,
        "./ReactPropTypeLocationNames": 76,
        "./ReactPropTypeLocations": 77,
        "./ReactReconciler": 81,
        "./ReactUpdates": 87,
        "./emptyObject": 115,
        "./invariant": 135,
        "./shouldUpdateReactComponent": 151,
        "./warning": 154,
        _process: 156
    } ],
    38: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var assign = require("./Object.assign");
            var emptyObject = require("./emptyObject");
            var warning = require("./warning");
            var didWarn = false;
            var ReactContext = {
                current: emptyObject,
                withContext: function(newContext, scopedCallback) {
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(didWarn, "withContext is deprecated and will be removed in a future version. " + "Use a wrapper component with getChildContext instead.") : null;
                        didWarn = true;
                    }
                    var result;
                    var previousContext = ReactContext.current;
                    ReactContext.current = assign({}, previousContext, newContext);
                    try {
                        result = scopedCallback();
                    } finally {
                        ReactContext.current = previousContext;
                    }
                    return result;
                }
            };
            module.exports = ReactContext;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./emptyObject": 115,
        "./warning": 154,
        _process: 156
    } ],
    39: [ function(require, module, exports) {
        "use strict";
        var ReactCurrentOwner = {
            current: null
        };
        module.exports = ReactCurrentOwner;
    }, {} ],
    40: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactElement = require("./ReactElement");
            var ReactElementValidator = require("./ReactElementValidator");
            var mapObject = require("./mapObject");
            function createDOMFactory(tag) {
                if ("production" !== process.env.NODE_ENV) {
                    return ReactElementValidator.createFactory(tag);
                }
                return ReactElement.createFactory(tag);
            }
            var ReactDOM = mapObject({
                a: "a",
                abbr: "abbr",
                address: "address",
                area: "area",
                article: "article",
                aside: "aside",
                audio: "audio",
                b: "b",
                base: "base",
                bdi: "bdi",
                bdo: "bdo",
                big: "big",
                blockquote: "blockquote",
                body: "body",
                br: "br",
                button: "button",
                canvas: "canvas",
                caption: "caption",
                cite: "cite",
                code: "code",
                col: "col",
                colgroup: "colgroup",
                data: "data",
                datalist: "datalist",
                dd: "dd",
                del: "del",
                details: "details",
                dfn: "dfn",
                dialog: "dialog",
                div: "div",
                dl: "dl",
                dt: "dt",
                em: "em",
                embed: "embed",
                fieldset: "fieldset",
                figcaption: "figcaption",
                figure: "figure",
                footer: "footer",
                form: "form",
                h1: "h1",
                h2: "h2",
                h3: "h3",
                h4: "h4",
                h5: "h5",
                h6: "h6",
                head: "head",
                header: "header",
                hr: "hr",
                html: "html",
                i: "i",
                iframe: "iframe",
                img: "img",
                input: "input",
                ins: "ins",
                kbd: "kbd",
                keygen: "keygen",
                label: "label",
                legend: "legend",
                li: "li",
                link: "link",
                main: "main",
                map: "map",
                mark: "mark",
                menu: "menu",
                menuitem: "menuitem",
                meta: "meta",
                meter: "meter",
                nav: "nav",
                noscript: "noscript",
                object: "object",
                ol: "ol",
                optgroup: "optgroup",
                option: "option",
                output: "output",
                p: "p",
                param: "param",
                picture: "picture",
                pre: "pre",
                progress: "progress",
                q: "q",
                rp: "rp",
                rt: "rt",
                ruby: "ruby",
                s: "s",
                samp: "samp",
                script: "script",
                section: "section",
                select: "select",
                small: "small",
                source: "source",
                span: "span",
                strong: "strong",
                style: "style",
                sub: "sub",
                summary: "summary",
                sup: "sup",
                table: "table",
                tbody: "tbody",
                td: "td",
                textarea: "textarea",
                tfoot: "tfoot",
                th: "th",
                thead: "thead",
                time: "time",
                title: "title",
                tr: "tr",
                track: "track",
                u: "u",
                ul: "ul",
                "var": "var",
                video: "video",
                wbr: "wbr",
                circle: "circle",
                clipPath: "clipPath",
                defs: "defs",
                ellipse: "ellipse",
                g: "g",
                line: "line",
                linearGradient: "linearGradient",
                mask: "mask",
                path: "path",
                pattern: "pattern",
                polygon: "polygon",
                polyline: "polyline",
                radialGradient: "radialGradient",
                rect: "rect",
                stop: "stop",
                svg: "svg",
                text: "text",
                tspan: "tspan"
            }, createDOMFactory);
            module.exports = ReactDOM;
        }).call(this, require("_process"));
    }, {
        "./ReactElement": 57,
        "./ReactElementValidator": 58,
        "./mapObject": 142,
        _process: 156
    } ],
    41: [ function(require, module, exports) {
        "use strict";
        var AutoFocusMixin = require("./AutoFocusMixin");
        var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
        var ReactClass = require("./ReactClass");
        var ReactElement = require("./ReactElement");
        var keyMirror = require("./keyMirror");
        var button = ReactElement.createFactory("button");
        var mouseListenerNames = keyMirror({
            onClick: true,
            onDoubleClick: true,
            onMouseDown: true,
            onMouseMove: true,
            onMouseUp: true,
            onClickCapture: true,
            onDoubleClickCapture: true,
            onMouseDownCapture: true,
            onMouseMoveCapture: true,
            onMouseUpCapture: true
        });
        var ReactDOMButton = ReactClass.createClass({
            displayName: "ReactDOMButton",
            tagName: "BUTTON",
            mixins: [ AutoFocusMixin, ReactBrowserComponentMixin ],
            render: function() {
                var props = {};
                for (var key in this.props) {
                    if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
                        props[key] = this.props[key];
                    }
                }
                return button(props, this.props.children);
            }
        });
        module.exports = ReactDOMButton;
    }, {
        "./AutoFocusMixin": 1,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57,
        "./keyMirror": 140
    } ],
    42: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var CSSPropertyOperations = require("./CSSPropertyOperations");
            var DOMProperty = require("./DOMProperty");
            var DOMPropertyOperations = require("./DOMPropertyOperations");
            var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
            var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
            var ReactMount = require("./ReactMount");
            var ReactMultiChild = require("./ReactMultiChild");
            var ReactPerf = require("./ReactPerf");
            var assign = require("./Object.assign");
            var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
            var invariant = require("./invariant");
            var isEventSupported = require("./isEventSupported");
            var keyOf = require("./keyOf");
            var warning = require("./warning");
            var deleteListener = ReactBrowserEventEmitter.deleteListener;
            var listenTo = ReactBrowserEventEmitter.listenTo;
            var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
            var CONTENT_TYPES = {
                string: true,
                number: true
            };
            var STYLE = keyOf({
                style: null
            });
            var ELEMENT_NODE_TYPE = 1;
            var BackendIDOperations = null;
            function assertValidProps(props) {
                if (!props) {
                    return;
                }
                if (props.dangerouslySetInnerHTML != null) {
                    "production" !== process.env.NODE_ENV ? invariant(props.children == null, "Can only set one of `children` or `props.dangerouslySetInnerHTML`.") : invariant(props.children == null);
                    "production" !== process.env.NODE_ENV ? invariant(typeof props.dangerouslySetInnerHTML === "object" && "__html" in props.dangerouslySetInnerHTML, "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. " + "Please visit https://fb.me/react-invariant-dangerously-set-inner-html " + "for more information.") : invariant(typeof props.dangerouslySetInnerHTML === "object" && "__html" in props.dangerouslySetInnerHTML);
                }
                if ("production" !== process.env.NODE_ENV) {
                    "production" !== process.env.NODE_ENV ? warning(props.innerHTML == null, "Directly setting property `innerHTML` is not permitted. " + "For more information, lookup documentation on `dangerouslySetInnerHTML`.") : null;
                    "production" !== process.env.NODE_ENV ? warning(!props.contentEditable || props.children == null, "A component is `contentEditable` and contains `children` managed by " + "React. It is now your responsibility to guarantee that none of " + "those nodes are unexpectedly modified or duplicated. This is " + "probably not intentional.") : null;
                }
                "production" !== process.env.NODE_ENV ? invariant(props.style == null || typeof props.style === "object", "The `style` prop expects a mapping from style properties to values, " + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + "using JSX.") : invariant(props.style == null || typeof props.style === "object");
            }
            function putListener(id, registrationName, listener, transaction) {
                if ("production" !== process.env.NODE_ENV) {
                    "production" !== process.env.NODE_ENV ? warning(registrationName !== "onScroll" || isEventSupported("scroll", true), "This browser doesn't support the `onScroll` event") : null;
                }
                var container = ReactMount.findReactContainerForID(id);
                if (container) {
                    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
                    listenTo(registrationName, doc);
                }
                transaction.getPutListenerQueue().enqueuePutListener(id, registrationName, listener);
            }
            var omittedCloseTags = {
                area: true,
                base: true,
                br: true,
                col: true,
                embed: true,
                hr: true,
                img: true,
                input: true,
                keygen: true,
                link: true,
                meta: true,
                param: true,
                source: true,
                track: true,
                wbr: true
            };
            var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
            var validatedTagCache = {};
            var hasOwnProperty = {}.hasOwnProperty;
            function validateDangerousTag(tag) {
                if (!hasOwnProperty.call(validatedTagCache, tag)) {
                    "production" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), "Invalid tag: %s", tag) : invariant(VALID_TAG_REGEX.test(tag));
                    validatedTagCache[tag] = true;
                }
            }
            function ReactDOMComponent(tag) {
                validateDangerousTag(tag);
                this._tag = tag;
                this._renderedChildren = null;
                this._previousStyleCopy = null;
                this._rootNodeID = null;
            }
            ReactDOMComponent.displayName = "ReactDOMComponent";
            ReactDOMComponent.Mixin = {
                construct: function(element) {
                    this._currentElement = element;
                },
                mountComponent: function(rootID, transaction, context) {
                    this._rootNodeID = rootID;
                    assertValidProps(this._currentElement.props);
                    var closeTag = omittedCloseTags[this._tag] ? "" : "</" + this._tag + ">";
                    return this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction, context) + closeTag;
                },
                _createOpenTagMarkupAndPutListeners: function(transaction) {
                    var props = this._currentElement.props;
                    var ret = "<" + this._tag;
                    for (var propKey in props) {
                        if (!props.hasOwnProperty(propKey)) {
                            continue;
                        }
                        var propValue = props[propKey];
                        if (propValue == null) {
                            continue;
                        }
                        if (registrationNameModules.hasOwnProperty(propKey)) {
                            putListener(this._rootNodeID, propKey, propValue, transaction);
                        } else {
                            if (propKey === STYLE) {
                                if (propValue) {
                                    propValue = this._previousStyleCopy = assign({}, props.style);
                                }
                                propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
                            }
                            var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
                            if (markup) {
                                ret += " " + markup;
                            }
                        }
                    }
                    if (transaction.renderToStaticMarkup) {
                        return ret + ">";
                    }
                    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
                    return ret + " " + markupForID + ">";
                },
                _createContentMarkup: function(transaction, context) {
                    var prefix = "";
                    if (this._tag === "listing" || this._tag === "pre" || this._tag === "textarea") {
                        prefix = "\n";
                    }
                    var props = this._currentElement.props;
                    var innerHTML = props.dangerouslySetInnerHTML;
                    if (innerHTML != null) {
                        if (innerHTML.__html != null) {
                            return prefix + innerHTML.__html;
                        }
                    } else {
                        var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
                        var childrenToUse = contentToUse != null ? null : props.children;
                        if (contentToUse != null) {
                            return prefix + escapeTextContentForBrowser(contentToUse);
                        } else if (childrenToUse != null) {
                            var mountImages = this.mountChildren(childrenToUse, transaction, context);
                            return prefix + mountImages.join("");
                        }
                    }
                    return prefix;
                },
                receiveComponent: function(nextElement, transaction, context) {
                    var prevElement = this._currentElement;
                    this._currentElement = nextElement;
                    this.updateComponent(transaction, prevElement, nextElement, context);
                },
                updateComponent: function(transaction, prevElement, nextElement, context) {
                    assertValidProps(this._currentElement.props);
                    this._updateDOMProperties(prevElement.props, transaction);
                    this._updateDOMChildren(prevElement.props, transaction, context);
                },
                _updateDOMProperties: function(lastProps, transaction) {
                    var nextProps = this._currentElement.props;
                    var propKey;
                    var styleName;
                    var styleUpdates;
                    for (propKey in lastProps) {
                        if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
                            continue;
                        }
                        if (propKey === STYLE) {
                            var lastStyle = this._previousStyleCopy;
                            for (styleName in lastStyle) {
                                if (lastStyle.hasOwnProperty(styleName)) {
                                    styleUpdates = styleUpdates || {};
                                    styleUpdates[styleName] = "";
                                }
                            }
                            this._previousStyleCopy = null;
                        } else if (registrationNameModules.hasOwnProperty(propKey)) {
                            deleteListener(this._rootNodeID, propKey);
                        } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                            BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
                        }
                    }
                    for (propKey in nextProps) {
                        var nextProp = nextProps[propKey];
                        var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
                        if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
                            continue;
                        }
                        if (propKey === STYLE) {
                            if (nextProp) {
                                nextProp = this._previousStyleCopy = assign({}, nextProp);
                            } else {
                                this._previousStyleCopy = null;
                            }
                            if (lastProp) {
                                for (styleName in lastProp) {
                                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                                        styleUpdates = styleUpdates || {};
                                        styleUpdates[styleName] = "";
                                    }
                                }
                                for (styleName in nextProp) {
                                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                                        styleUpdates = styleUpdates || {};
                                        styleUpdates[styleName] = nextProp[styleName];
                                    }
                                }
                            } else {
                                styleUpdates = nextProp;
                            }
                        } else if (registrationNameModules.hasOwnProperty(propKey)) {
                            putListener(this._rootNodeID, propKey, nextProp, transaction);
                        } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                            BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
                        }
                    }
                    if (styleUpdates) {
                        BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
                    }
                },
                _updateDOMChildren: function(lastProps, transaction, context) {
                    var nextProps = this._currentElement.props;
                    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
                    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
                    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
                    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
                    var lastChildren = lastContent != null ? null : lastProps.children;
                    var nextChildren = nextContent != null ? null : nextProps.children;
                    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
                    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
                    if (lastChildren != null && nextChildren == null) {
                        this.updateChildren(null, transaction, context);
                    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
                        this.updateTextContent("");
                    }
                    if (nextContent != null) {
                        if (lastContent !== nextContent) {
                            this.updateTextContent("" + nextContent);
                        }
                    } else if (nextHtml != null) {
                        if (lastHtml !== nextHtml) {
                            BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml);
                        }
                    } else if (nextChildren != null) {
                        this.updateChildren(nextChildren, transaction, context);
                    }
                },
                unmountComponent: function() {
                    this.unmountChildren();
                    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
                    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
                    this._rootNodeID = null;
                }
            };
            ReactPerf.measureMethods(ReactDOMComponent, "ReactDOMComponent", {
                mountComponent: "mountComponent",
                updateComponent: "updateComponent"
            });
            assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
            ReactDOMComponent.injection = {
                injectIDOperations: function(IDOperations) {
                    ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations;
                }
            };
            module.exports = ReactDOMComponent;
        }).call(this, require("_process"));
    }, {
        "./CSSPropertyOperations": 4,
        "./DOMProperty": 9,
        "./DOMPropertyOperations": 10,
        "./Object.assign": 26,
        "./ReactBrowserEventEmitter": 30,
        "./ReactComponentBrowserEnvironment": 35,
        "./ReactMount": 70,
        "./ReactMultiChild": 71,
        "./ReactPerf": 75,
        "./escapeTextContentForBrowser": 116,
        "./invariant": 135,
        "./isEventSupported": 136,
        "./keyOf": 141,
        "./warning": 154,
        _process: 156
    } ],
    43: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var LocalEventTrapMixin = require("./LocalEventTrapMixin");
        var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
        var ReactClass = require("./ReactClass");
        var ReactElement = require("./ReactElement");
        var form = ReactElement.createFactory("form");
        var ReactDOMForm = ReactClass.createClass({
            displayName: "ReactDOMForm",
            tagName: "FORM",
            mixins: [ ReactBrowserComponentMixin, LocalEventTrapMixin ],
            render: function() {
                return form(this.props);
            },
            componentDidMount: function() {
                this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, "reset");
                this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, "submit");
            }
        });
        module.exports = ReactDOMForm;
    }, {
        "./EventConstants": 14,
        "./LocalEventTrapMixin": 24,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57
    } ],
    44: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var CSSPropertyOperations = require("./CSSPropertyOperations");
            var DOMChildrenOperations = require("./DOMChildrenOperations");
            var DOMPropertyOperations = require("./DOMPropertyOperations");
            var ReactMount = require("./ReactMount");
            var ReactPerf = require("./ReactPerf");
            var invariant = require("./invariant");
            var setInnerHTML = require("./setInnerHTML");
            var INVALID_PROPERTY_ERRORS = {
                dangerouslySetInnerHTML: "`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.",
                style: "`style` must be set using `updateStylesByID()`."
            };
            var ReactDOMIDOperations = {
                updatePropertyByID: function(id, name, value) {
                    var node = ReactMount.getNode(id);
                    "production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), "updatePropertyByID(...): %s", INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name));
                    if (value != null) {
                        DOMPropertyOperations.setValueForProperty(node, name, value);
                    } else {
                        DOMPropertyOperations.deleteValueForProperty(node, name);
                    }
                },
                deletePropertyByID: function(id, name, value) {
                    var node = ReactMount.getNode(id);
                    "production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), "updatePropertyByID(...): %s", INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name));
                    DOMPropertyOperations.deleteValueForProperty(node, name, value);
                },
                updateStylesByID: function(id, styles) {
                    var node = ReactMount.getNode(id);
                    CSSPropertyOperations.setValueForStyles(node, styles);
                },
                updateInnerHTMLByID: function(id, html) {
                    var node = ReactMount.getNode(id);
                    setInnerHTML(node, html);
                },
                updateTextContentByID: function(id, content) {
                    var node = ReactMount.getNode(id);
                    DOMChildrenOperations.updateTextContent(node, content);
                },
                dangerouslyReplaceNodeWithMarkupByID: function(id, markup) {
                    var node = ReactMount.getNode(id);
                    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
                },
                dangerouslyProcessChildrenUpdates: function(updates, markup) {
                    for (var i = 0; i < updates.length; i++) {
                        updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
                    }
                    DOMChildrenOperations.processUpdates(updates, markup);
                }
            };
            ReactPerf.measureMethods(ReactDOMIDOperations, "ReactDOMIDOperations", {
                updatePropertyByID: "updatePropertyByID",
                deletePropertyByID: "deletePropertyByID",
                updateStylesByID: "updateStylesByID",
                updateInnerHTMLByID: "updateInnerHTMLByID",
                updateTextContentByID: "updateTextContentByID",
                dangerouslyReplaceNodeWithMarkupByID: "dangerouslyReplaceNodeWithMarkupByID",
                dangerouslyProcessChildrenUpdates: "dangerouslyProcessChildrenUpdates"
            });
            module.exports = ReactDOMIDOperations;
        }).call(this, require("_process"));
    }, {
        "./CSSPropertyOperations": 4,
        "./DOMChildrenOperations": 8,
        "./DOMPropertyOperations": 10,
        "./ReactMount": 70,
        "./ReactPerf": 75,
        "./invariant": 135,
        "./setInnerHTML": 148,
        _process: 156
    } ],
    45: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var LocalEventTrapMixin = require("./LocalEventTrapMixin");
        var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
        var ReactClass = require("./ReactClass");
        var ReactElement = require("./ReactElement");
        var iframe = ReactElement.createFactory("iframe");
        var ReactDOMIframe = ReactClass.createClass({
            displayName: "ReactDOMIframe",
            tagName: "IFRAME",
            mixins: [ ReactBrowserComponentMixin, LocalEventTrapMixin ],
            render: function() {
                return iframe(this.props);
            },
            componentDidMount: function() {
                this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, "load");
            }
        });
        module.exports = ReactDOMIframe;
    }, {
        "./EventConstants": 14,
        "./LocalEventTrapMixin": 24,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57
    } ],
    46: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var LocalEventTrapMixin = require("./LocalEventTrapMixin");
        var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
        var ReactClass = require("./ReactClass");
        var ReactElement = require("./ReactElement");
        var img = ReactElement.createFactory("img");
        var ReactDOMImg = ReactClass.createClass({
            displayName: "ReactDOMImg",
            tagName: "IMG",
            mixins: [ ReactBrowserComponentMixin, LocalEventTrapMixin ],
            render: function() {
                return img(this.props);
            },
            componentDidMount: function() {
                this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, "load");
                this.trapBubbledEvent(EventConstants.topLevelTypes.topError, "error");
            }
        });
        module.exports = ReactDOMImg;
    }, {
        "./EventConstants": 14,
        "./LocalEventTrapMixin": 24,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57
    } ],
    47: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var AutoFocusMixin = require("./AutoFocusMixin");
            var DOMPropertyOperations = require("./DOMPropertyOperations");
            var LinkedValueUtils = require("./LinkedValueUtils");
            var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
            var ReactClass = require("./ReactClass");
            var ReactElement = require("./ReactElement");
            var ReactMount = require("./ReactMount");
            var ReactUpdates = require("./ReactUpdates");
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            var input = ReactElement.createFactory("input");
            var instancesByReactID = {};
            function forceUpdateIfMounted() {
                if (this.isMounted()) {
                    this.forceUpdate();
                }
            }
            var ReactDOMInput = ReactClass.createClass({
                displayName: "ReactDOMInput",
                tagName: "INPUT",
                mixins: [ AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin ],
                getInitialState: function() {
                    var defaultValue = this.props.defaultValue;
                    return {
                        initialChecked: this.props.defaultChecked || false,
                        initialValue: defaultValue != null ? defaultValue : null
                    };
                },
                render: function() {
                    var props = assign({}, this.props);
                    props.defaultChecked = null;
                    props.defaultValue = null;
                    var value = LinkedValueUtils.getValue(this);
                    props.value = value != null ? value : this.state.initialValue;
                    var checked = LinkedValueUtils.getChecked(this);
                    props.checked = checked != null ? checked : this.state.initialChecked;
                    props.onChange = this._handleChange;
                    return input(props, this.props.children);
                },
                componentDidMount: function() {
                    var id = ReactMount.getID(this.getDOMNode());
                    instancesByReactID[id] = this;
                },
                componentWillUnmount: function() {
                    var rootNode = this.getDOMNode();
                    var id = ReactMount.getID(rootNode);
                    delete instancesByReactID[id];
                },
                componentDidUpdate: function(prevProps, prevState, prevContext) {
                    var rootNode = this.getDOMNode();
                    if (this.props.checked != null) {
                        DOMPropertyOperations.setValueForProperty(rootNode, "checked", this.props.checked || false);
                    }
                    var value = LinkedValueUtils.getValue(this);
                    if (value != null) {
                        DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value);
                    }
                },
                _handleChange: function(event) {
                    var returnValue;
                    var onChange = LinkedValueUtils.getOnChange(this);
                    if (onChange) {
                        returnValue = onChange.call(this, event);
                    }
                    ReactUpdates.asap(forceUpdateIfMounted, this);
                    var name = this.props.name;
                    if (this.props.type === "radio" && name != null) {
                        var rootNode = this.getDOMNode();
                        var queryRoot = rootNode;
                        while (queryRoot.parentNode) {
                            queryRoot = queryRoot.parentNode;
                        }
                        var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
                        for (var i = 0, groupLen = group.length; i < groupLen; i++) {
                            var otherNode = group[i];
                            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                                continue;
                            }
                            var otherID = ReactMount.getID(otherNode);
                            "production" !== process.env.NODE_ENV ? invariant(otherID, "ReactDOMInput: Mixing React and non-React radio inputs with the " + "same `name` is not supported.") : invariant(otherID);
                            var otherInstance = instancesByReactID[otherID];
                            "production" !== process.env.NODE_ENV ? invariant(otherInstance, "ReactDOMInput: Unknown radio button ID %s.", otherID) : invariant(otherInstance);
                            ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
                        }
                    }
                    return returnValue;
                }
            });
            module.exports = ReactDOMInput;
        }).call(this, require("_process"));
    }, {
        "./AutoFocusMixin": 1,
        "./DOMPropertyOperations": 10,
        "./LinkedValueUtils": 23,
        "./Object.assign": 26,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57,
        "./ReactMount": 70,
        "./ReactUpdates": 87,
        "./invariant": 135,
        _process: 156
    } ],
    48: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
            var ReactClass = require("./ReactClass");
            var ReactElement = require("./ReactElement");
            var warning = require("./warning");
            var option = ReactElement.createFactory("option");
            var ReactDOMOption = ReactClass.createClass({
                displayName: "ReactDOMOption",
                tagName: "OPTION",
                mixins: [ ReactBrowserComponentMixin ],
                componentWillMount: function() {
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(this.props.selected == null, "Use the `defaultValue` or `value` props on <select> instead of " + "setting `selected` on <option>.") : null;
                    }
                },
                render: function() {
                    return option(this.props, this.props.children);
                }
            });
            module.exports = ReactDOMOption;
        }).call(this, require("_process"));
    }, {
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57,
        "./warning": 154,
        _process: 156
    } ],
    49: [ function(require, module, exports) {
        "use strict";
        var AutoFocusMixin = require("./AutoFocusMixin");
        var LinkedValueUtils = require("./LinkedValueUtils");
        var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
        var ReactClass = require("./ReactClass");
        var ReactElement = require("./ReactElement");
        var ReactUpdates = require("./ReactUpdates");
        var assign = require("./Object.assign");
        var select = ReactElement.createFactory("select");
        function updateOptionsIfPendingUpdateAndMounted() {
            if (this._pendingUpdate) {
                this._pendingUpdate = false;
                var value = LinkedValueUtils.getValue(this);
                if (value != null && this.isMounted()) {
                    updateOptions(this, value);
                }
            }
        }
        function selectValueType(props, propName, componentName) {
            if (props[propName] == null) {
                return null;
            }
            if (props.multiple) {
                if (!Array.isArray(props[propName])) {
                    return new Error("The `" + propName + "` prop supplied to <select> must be an array if " + "`multiple` is true.");
                }
            } else {
                if (Array.isArray(props[propName])) {
                    return new Error("The `" + propName + "` prop supplied to <select> must be a scalar " + "value if `multiple` is false.");
                }
            }
        }
        function updateOptions(component, propValue) {
            var selectedValue, i, l;
            var options = component.getDOMNode().options;
            if (component.props.multiple) {
                selectedValue = {};
                for (i = 0, l = propValue.length; i < l; i++) {
                    selectedValue["" + propValue[i]] = true;
                }
                for (i = 0, l = options.length; i < l; i++) {
                    var selected = selectedValue.hasOwnProperty(options[i].value);
                    if (options[i].selected !== selected) {
                        options[i].selected = selected;
                    }
                }
            } else {
                selectedValue = "" + propValue;
                for (i = 0, l = options.length; i < l; i++) {
                    if (options[i].value === selectedValue) {
                        options[i].selected = true;
                        return;
                    }
                }
                if (options.length) {
                    options[0].selected = true;
                }
            }
        }
        var ReactDOMSelect = ReactClass.createClass({
            displayName: "ReactDOMSelect",
            tagName: "SELECT",
            mixins: [ AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin ],
            propTypes: {
                defaultValue: selectValueType,
                value: selectValueType
            },
            render: function() {
                var props = assign({}, this.props);
                props.onChange = this._handleChange;
                props.value = null;
                return select(props, this.props.children);
            },
            componentWillMount: function() {
                this._pendingUpdate = false;
            },
            componentDidMount: function() {
                var value = LinkedValueUtils.getValue(this);
                if (value != null) {
                    updateOptions(this, value);
                } else if (this.props.defaultValue != null) {
                    updateOptions(this, this.props.defaultValue);
                }
            },
            componentDidUpdate: function(prevProps) {
                var value = LinkedValueUtils.getValue(this);
                if (value != null) {
                    this._pendingUpdate = false;
                    updateOptions(this, value);
                } else if (!prevProps.multiple !== !this.props.multiple) {
                    if (this.props.defaultValue != null) {
                        updateOptions(this, this.props.defaultValue);
                    } else {
                        updateOptions(this, this.props.multiple ? [] : "");
                    }
                }
            },
            _handleChange: function(event) {
                var returnValue;
                var onChange = LinkedValueUtils.getOnChange(this);
                if (onChange) {
                    returnValue = onChange.call(this, event);
                }
                this._pendingUpdate = true;
                ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
                return returnValue;
            }
        });
        module.exports = ReactDOMSelect;
    }, {
        "./AutoFocusMixin": 1,
        "./LinkedValueUtils": 23,
        "./Object.assign": 26,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57,
        "./ReactUpdates": 87
    } ],
    50: [ function(require, module, exports) {
        "use strict";
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
        var getTextContentAccessor = require("./getTextContentAccessor");
        function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
            return anchorNode === focusNode && anchorOffset === focusOffset;
        }
        function getIEOffsets(node) {
            var selection = document.selection;
            var selectedRange = selection.createRange();
            var selectedLength = selectedRange.text.length;
            var fromStart = selectedRange.duplicate();
            fromStart.moveToElementText(node);
            fromStart.setEndPoint("EndToStart", selectedRange);
            var startOffset = fromStart.text.length;
            var endOffset = startOffset + selectedLength;
            return {
                start: startOffset,
                end: endOffset
            };
        }
        function getModernOffsets(node) {
            var selection = window.getSelection && window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                return null;
            }
            var anchorNode = selection.anchorNode;
            var anchorOffset = selection.anchorOffset;
            var focusNode = selection.focusNode;
            var focusOffset = selection.focusOffset;
            var currentRange = selection.getRangeAt(0);
            var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
            var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
            var tempRange = currentRange.cloneRange();
            tempRange.selectNodeContents(node);
            tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
            var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
            var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
            var end = start + rangeLength;
            var detectionRange = document.createRange();
            detectionRange.setStart(anchorNode, anchorOffset);
            detectionRange.setEnd(focusNode, focusOffset);
            var isBackward = detectionRange.collapsed;
            return {
                start: isBackward ? end : start,
                end: isBackward ? start : end
            };
        }
        function setIEOffsets(node, offsets) {
            var range = document.selection.createRange().duplicate();
            var start, end;
            if (typeof offsets.end === "undefined") {
                start = offsets.start;
                end = start;
            } else if (offsets.start > offsets.end) {
                start = offsets.end;
                end = offsets.start;
            } else {
                start = offsets.start;
                end = offsets.end;
            }
            range.moveToElementText(node);
            range.moveStart("character", start);
            range.setEndPoint("EndToStart", range);
            range.moveEnd("character", end - start);
            range.select();
        }
        function setModernOffsets(node, offsets) {
            if (!window.getSelection) {
                return;
            }
            var selection = window.getSelection();
            var length = node[getTextContentAccessor()].length;
            var start = Math.min(offsets.start, length);
            var end = typeof offsets.end === "undefined" ? start : Math.min(offsets.end, length);
            if (!selection.extend && start > end) {
                var temp = end;
                end = start;
                start = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
                var range = document.createRange();
                range.setStart(startMarker.node, startMarker.offset);
                selection.removeAllRanges();
                if (start > end) {
                    selection.addRange(range);
                    selection.extend(endMarker.node, endMarker.offset);
                } else {
                    range.setEnd(endMarker.node, endMarker.offset);
                    selection.addRange(range);
                }
            }
        }
        var useIEOffsets = ExecutionEnvironment.canUseDOM && "selection" in document && !("getSelection" in window);
        var ReactDOMSelection = {
            getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
            setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
        };
        module.exports = ReactDOMSelection;
    }, {
        "./ExecutionEnvironment": 20,
        "./getNodeForCharacterOffset": 128,
        "./getTextContentAccessor": 130
    } ],
    51: [ function(require, module, exports) {
        "use strict";
        var DOMPropertyOperations = require("./DOMPropertyOperations");
        var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
        var ReactDOMComponent = require("./ReactDOMComponent");
        var assign = require("./Object.assign");
        var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
        var ReactDOMTextComponent = function(props) {};
        assign(ReactDOMTextComponent.prototype, {
            construct: function(text) {
                this._currentElement = text;
                this._stringText = "" + text;
                this._rootNodeID = null;
                this._mountIndex = 0;
            },
            mountComponent: function(rootID, transaction, context) {
                this._rootNodeID = rootID;
                var escapedText = escapeTextContentForBrowser(this._stringText);
                if (transaction.renderToStaticMarkup) {
                    return escapedText;
                }
                return "<span " + DOMPropertyOperations.createMarkupForID(rootID) + ">" + escapedText + "</span>";
            },
            receiveComponent: function(nextText, transaction) {
                if (nextText !== this._currentElement) {
                    this._currentElement = nextText;
                    var nextStringText = "" + nextText;
                    if (nextStringText !== this._stringText) {
                        this._stringText = nextStringText;
                        ReactDOMComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextStringText);
                    }
                }
            },
            unmountComponent: function() {
                ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
            }
        });
        module.exports = ReactDOMTextComponent;
    }, {
        "./DOMPropertyOperations": 10,
        "./Object.assign": 26,
        "./ReactComponentBrowserEnvironment": 35,
        "./ReactDOMComponent": 42,
        "./escapeTextContentForBrowser": 116
    } ],
    52: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var AutoFocusMixin = require("./AutoFocusMixin");
            var DOMPropertyOperations = require("./DOMPropertyOperations");
            var LinkedValueUtils = require("./LinkedValueUtils");
            var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
            var ReactClass = require("./ReactClass");
            var ReactElement = require("./ReactElement");
            var ReactUpdates = require("./ReactUpdates");
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            var warning = require("./warning");
            var textarea = ReactElement.createFactory("textarea");
            function forceUpdateIfMounted() {
                if (this.isMounted()) {
                    this.forceUpdate();
                }
            }
            var ReactDOMTextarea = ReactClass.createClass({
                displayName: "ReactDOMTextarea",
                tagName: "TEXTAREA",
                mixins: [ AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin ],
                getInitialState: function() {
                    var defaultValue = this.props.defaultValue;
                    var children = this.props.children;
                    if (children != null) {
                        if ("production" !== process.env.NODE_ENV) {
                            "production" !== process.env.NODE_ENV ? warning(false, "Use the `defaultValue` or `value` props instead of setting " + "children on <textarea>.") : null;
                        }
                        "production" !== process.env.NODE_ENV ? invariant(defaultValue == null, "If you supply `defaultValue` on a <textarea>, do not pass children.") : invariant(defaultValue == null);
                        if (Array.isArray(children)) {
                            "production" !== process.env.NODE_ENV ? invariant(children.length <= 1, "<textarea> can only have at most one child.") : invariant(children.length <= 1);
                            children = children[0];
                        }
                        defaultValue = "" + children;
                    }
                    if (defaultValue == null) {
                        defaultValue = "";
                    }
                    var value = LinkedValueUtils.getValue(this);
                    return {
                        initialValue: "" + (value != null ? value : defaultValue)
                    };
                },
                render: function() {
                    var props = assign({}, this.props);
                    "production" !== process.env.NODE_ENV ? invariant(props.dangerouslySetInnerHTML == null, "`dangerouslySetInnerHTML` does not make sense on <textarea>.") : invariant(props.dangerouslySetInnerHTML == null);
                    props.defaultValue = null;
                    props.value = null;
                    props.onChange = this._handleChange;
                    return textarea(props, this.state.initialValue);
                },
                componentDidUpdate: function(prevProps, prevState, prevContext) {
                    var value = LinkedValueUtils.getValue(this);
                    if (value != null) {
                        var rootNode = this.getDOMNode();
                        DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value);
                    }
                },
                _handleChange: function(event) {
                    var returnValue;
                    var onChange = LinkedValueUtils.getOnChange(this);
                    if (onChange) {
                        returnValue = onChange.call(this, event);
                    }
                    ReactUpdates.asap(forceUpdateIfMounted, this);
                    return returnValue;
                }
            });
            module.exports = ReactDOMTextarea;
        }).call(this, require("_process"));
    }, {
        "./AutoFocusMixin": 1,
        "./DOMPropertyOperations": 10,
        "./LinkedValueUtils": 23,
        "./Object.assign": 26,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactElement": 57,
        "./ReactUpdates": 87,
        "./invariant": 135,
        "./warning": 154,
        _process: 156
    } ],
    53: [ function(require, module, exports) {
        "use strict";
        var ReactUpdates = require("./ReactUpdates");
        var Transaction = require("./Transaction");
        var assign = require("./Object.assign");
        var emptyFunction = require("./emptyFunction");
        var RESET_BATCHED_UPDATES = {
            initialize: emptyFunction,
            close: function() {
                ReactDefaultBatchingStrategy.isBatchingUpdates = false;
            }
        };
        var FLUSH_BATCHED_UPDATES = {
            initialize: emptyFunction,
            close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
        };
        var TRANSACTION_WRAPPERS = [ FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES ];
        function ReactDefaultBatchingStrategyTransaction() {
            this.reinitializeTransaction();
        }
        assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
            getTransactionWrappers: function() {
                return TRANSACTION_WRAPPERS;
            }
        });
        var transaction = new ReactDefaultBatchingStrategyTransaction();
        var ReactDefaultBatchingStrategy = {
            isBatchingUpdates: false,
            batchedUpdates: function(callback, a, b, c, d) {
                var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
                ReactDefaultBatchingStrategy.isBatchingUpdates = true;
                if (alreadyBatchingUpdates) {
                    callback(a, b, c, d);
                } else {
                    transaction.perform(callback, null, a, b, c, d);
                }
            }
        };
        module.exports = ReactDefaultBatchingStrategy;
    }, {
        "./Object.assign": 26,
        "./ReactUpdates": 87,
        "./Transaction": 103,
        "./emptyFunction": 114
    } ],
    54: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
            var ChangeEventPlugin = require("./ChangeEventPlugin");
            var ClientReactRootIndex = require("./ClientReactRootIndex");
            var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
            var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
            var ExecutionEnvironment = require("./ExecutionEnvironment");
            var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
            var MobileSafariClickEventPlugin = require("./MobileSafariClickEventPlugin");
            var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
            var ReactClass = require("./ReactClass");
            var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
            var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
            var ReactDOMComponent = require("./ReactDOMComponent");
            var ReactDOMButton = require("./ReactDOMButton");
            var ReactDOMForm = require("./ReactDOMForm");
            var ReactDOMImg = require("./ReactDOMImg");
            var ReactDOMIDOperations = require("./ReactDOMIDOperations");
            var ReactDOMIframe = require("./ReactDOMIframe");
            var ReactDOMInput = require("./ReactDOMInput");
            var ReactDOMOption = require("./ReactDOMOption");
            var ReactDOMSelect = require("./ReactDOMSelect");
            var ReactDOMTextarea = require("./ReactDOMTextarea");
            var ReactDOMTextComponent = require("./ReactDOMTextComponent");
            var ReactElement = require("./ReactElement");
            var ReactEventListener = require("./ReactEventListener");
            var ReactInjection = require("./ReactInjection");
            var ReactInstanceHandles = require("./ReactInstanceHandles");
            var ReactMount = require("./ReactMount");
            var ReactReconcileTransaction = require("./ReactReconcileTransaction");
            var SelectEventPlugin = require("./SelectEventPlugin");
            var ServerReactRootIndex = require("./ServerReactRootIndex");
            var SimpleEventPlugin = require("./SimpleEventPlugin");
            var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");
            var createFullPageComponent = require("./createFullPageComponent");
            function autoGenerateWrapperClass(type) {
                return ReactClass.createClass({
                    tagName: type.toUpperCase(),
                    render: function() {
                        return new ReactElement(type, null, null, null, null, this.props);
                    }
                });
            }
            function inject() {
                ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
                ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
                ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
                ReactInjection.EventPluginHub.injectMount(ReactMount);
                ReactInjection.EventPluginHub.injectEventPluginsByName({
                    SimpleEventPlugin: SimpleEventPlugin,
                    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
                    ChangeEventPlugin: ChangeEventPlugin,
                    MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
                    SelectEventPlugin: SelectEventPlugin,
                    BeforeInputEventPlugin: BeforeInputEventPlugin
                });
                ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
                ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
                ReactInjection.NativeComponent.injectAutoWrapper(autoGenerateWrapperClass);
                ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
                ReactInjection.NativeComponent.injectComponentClasses({
                    button: ReactDOMButton,
                    form: ReactDOMForm,
                    iframe: ReactDOMIframe,
                    img: ReactDOMImg,
                    input: ReactDOMInput,
                    option: ReactDOMOption,
                    select: ReactDOMSelect,
                    textarea: ReactDOMTextarea,
                    html: createFullPageComponent("html"),
                    head: createFullPageComponent("head"),
                    body: createFullPageComponent("body")
                });
                ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
                ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
                ReactInjection.EmptyComponent.injectEmptyComponent("noscript");
                ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
                ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
                ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
                ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
                ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);
                if ("production" !== process.env.NODE_ENV) {
                    var url = ExecutionEnvironment.canUseDOM && window.location.href || "";
                    if (/[?&]react_perf\b/.test(url)) {
                        var ReactDefaultPerf = require("./ReactDefaultPerf");
                        ReactDefaultPerf.start();
                    }
                }
            }
            module.exports = {
                inject: inject
            };
        }).call(this, require("_process"));
    }, {
        "./BeforeInputEventPlugin": 2,
        "./ChangeEventPlugin": 6,
        "./ClientReactRootIndex": 7,
        "./DefaultEventPluginOrder": 12,
        "./EnterLeaveEventPlugin": 13,
        "./ExecutionEnvironment": 20,
        "./HTMLDOMPropertyConfig": 22,
        "./MobileSafariClickEventPlugin": 25,
        "./ReactBrowserComponentMixin": 29,
        "./ReactClass": 33,
        "./ReactComponentBrowserEnvironment": 35,
        "./ReactDOMButton": 41,
        "./ReactDOMComponent": 42,
        "./ReactDOMForm": 43,
        "./ReactDOMIDOperations": 44,
        "./ReactDOMIframe": 45,
        "./ReactDOMImg": 46,
        "./ReactDOMInput": 47,
        "./ReactDOMOption": 48,
        "./ReactDOMSelect": 49,
        "./ReactDOMTextComponent": 51,
        "./ReactDOMTextarea": 52,
        "./ReactDefaultBatchingStrategy": 53,
        "./ReactDefaultPerf": 55,
        "./ReactElement": 57,
        "./ReactEventListener": 62,
        "./ReactInjection": 64,
        "./ReactInstanceHandles": 66,
        "./ReactMount": 70,
        "./ReactReconcileTransaction": 80,
        "./SVGDOMPropertyConfig": 88,
        "./SelectEventPlugin": 89,
        "./ServerReactRootIndex": 90,
        "./SimpleEventPlugin": 91,
        "./createFullPageComponent": 111,
        _process: 156
    } ],
    55: [ function(require, module, exports) {
        "use strict";
        var DOMProperty = require("./DOMProperty");
        var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
        var ReactMount = require("./ReactMount");
        var ReactPerf = require("./ReactPerf");
        var performanceNow = require("./performanceNow");
        function roundFloat(val) {
            return Math.floor(val * 100) / 100;
        }
        function addValue(obj, key, val) {
            obj[key] = (obj[key] || 0) + val;
        }
        var ReactDefaultPerf = {
            _allMeasurements: [],
            _mountStack: [ 0 ],
            _injected: false,
            start: function() {
                if (!ReactDefaultPerf._injected) {
                    ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
                }
                ReactDefaultPerf._allMeasurements.length = 0;
                ReactPerf.enableMeasure = true;
            },
            stop: function() {
                ReactPerf.enableMeasure = false;
            },
            getLastMeasurements: function() {
                return ReactDefaultPerf._allMeasurements;
            },
            printExclusive: function(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
                console.table(summary.map(function(item) {
                    return {
                        "Component class name": item.componentName,
                        "Total inclusive time (ms)": roundFloat(item.inclusive),
                        "Exclusive mount time (ms)": roundFloat(item.exclusive),
                        "Exclusive render time (ms)": roundFloat(item.render),
                        "Mount time per instance (ms)": roundFloat(item.exclusive / item.count),
                        "Render time per instance (ms)": roundFloat(item.render / item.count),
                        Instances: item.count
                    };
                }));
            },
            printInclusive: function(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
                console.table(summary.map(function(item) {
                    return {
                        "Owner > component": item.componentName,
                        "Inclusive time (ms)": roundFloat(item.time),
                        Instances: item.count
                    };
                }));
                console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms");
            },
            getMeasurementsSummaryMap: function(measurements) {
                var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
                return summary.map(function(item) {
                    return {
                        "Owner > component": item.componentName,
                        "Wasted time (ms)": item.time,
                        Instances: item.count
                    };
                });
            },
            printWasted: function(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
                console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms");
            },
            printDOM: function(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
                console.table(summary.map(function(item) {
                    var result = {};
                    result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
                    result["type"] = item.type;
                    result["args"] = JSON.stringify(item.args);
                    return result;
                }));
                console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms");
            },
            _recordWrite: function(id, fnName, totalTime, args) {
                var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
                writes[id] = writes[id] || [];
                writes[id].push({
                    type: fnName,
                    time: totalTime,
                    args: args
                });
            },
            measure: function(moduleName, fnName, func) {
                return function() {
                    for (var args = [], $__0 = 0, $__1 = arguments.length; $__0 < $__1; $__0++) args.push(arguments[$__0]);
                    var totalTime;
                    var rv;
                    var start;
                    if (fnName === "_renderNewRootComponent" || fnName === "flushBatchedUpdates") {
                        ReactDefaultPerf._allMeasurements.push({
                            exclusive: {},
                            inclusive: {},
                            render: {},
                            counts: {},
                            writes: {},
                            displayNames: {},
                            totalTime: 0
                        });
                        start = performanceNow();
                        rv = func.apply(this, args);
                        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
                        return rv;
                    } else if (fnName === "_mountImageIntoNode" || moduleName === "ReactDOMIDOperations") {
                        start = performanceNow();
                        rv = func.apply(this, args);
                        totalTime = performanceNow() - start;
                        if (fnName === "_mountImageIntoNode") {
                            var mountID = ReactMount.getID(args[1]);
                            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
                        } else if (fnName === "dangerouslyProcessChildrenUpdates") {
                            args[0].forEach(function(update) {
                                var writeArgs = {};
                                if (update.fromIndex !== null) {
                                    writeArgs.fromIndex = update.fromIndex;
                                }
                                if (update.toIndex !== null) {
                                    writeArgs.toIndex = update.toIndex;
                                }
                                if (update.textContent !== null) {
                                    writeArgs.textContent = update.textContent;
                                }
                                if (update.markupIndex !== null) {
                                    writeArgs.markup = args[1][update.markupIndex];
                                }
                                ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
                            });
                        } else {
                            ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
                        }
                        return rv;
                    } else if (moduleName === "ReactCompositeComponent" && (fnName === "mountComponent" || fnName === "updateComponent" || fnName === "_renderValidatedComponent")) {
                        if (typeof this._currentElement.type === "string") {
                            return func.apply(this, args);
                        }
                        var rootNodeID = fnName === "mountComponent" ? args[0] : this._rootNodeID;
                        var isRender = fnName === "_renderValidatedComponent";
                        var isMount = fnName === "mountComponent";
                        var mountStack = ReactDefaultPerf._mountStack;
                        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
                        if (isRender) {
                            addValue(entry.counts, rootNodeID, 1);
                        } else if (isMount) {
                            mountStack.push(0);
                        }
                        start = performanceNow();
                        rv = func.apply(this, args);
                        totalTime = performanceNow() - start;
                        if (isRender) {
                            addValue(entry.render, rootNodeID, totalTime);
                        } else if (isMount) {
                            var subMountTime = mountStack.pop();
                            mountStack[mountStack.length - 1] += totalTime;
                            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
                            addValue(entry.inclusive, rootNodeID, totalTime);
                        } else {
                            addValue(entry.inclusive, rootNodeID, totalTime);
                        }
                        entry.displayNames[rootNodeID] = {
                            current: this.getName(),
                            owner: this._currentElement._owner ? this._currentElement._owner.getName() : "<root>"
                        };
                        return rv;
                    } else {
                        return func.apply(this, args);
                    }
                };
            }
        };
        module.exports = ReactDefaultPerf;
    }, {
        "./DOMProperty": 9,
        "./ReactDefaultPerfAnalysis": 56,
        "./ReactMount": 70,
        "./ReactPerf": 75,
        "./performanceNow": 146
    } ],
    56: [ function(require, module, exports) {
        var assign = require("./Object.assign");
        var DONT_CARE_THRESHOLD = 1.2;
        var DOM_OPERATION_TYPES = {
            _mountImageIntoNode: "set innerHTML",
            INSERT_MARKUP: "set innerHTML",
            MOVE_EXISTING: "move",
            REMOVE_NODE: "remove",
            TEXT_CONTENT: "set textContent",
            updatePropertyByID: "update attribute",
            deletePropertyByID: "delete attribute",
            updateStylesByID: "update styles",
            updateInnerHTMLByID: "set innerHTML",
            dangerouslyReplaceNodeWithMarkupByID: "replace"
        };
        function getTotalTime(measurements) {
            var totalTime = 0;
            for (var i = 0; i < measurements.length; i++) {
                var measurement = measurements[i];
                totalTime += measurement.totalTime;
            }
            return totalTime;
        }
        function getDOMSummary(measurements) {
            var items = [];
            for (var i = 0; i < measurements.length; i++) {
                var measurement = measurements[i];
                var id;
                for (id in measurement.writes) {
                    measurement.writes[id].forEach(function(write) {
                        items.push({
                            id: id,
                            type: DOM_OPERATION_TYPES[write.type] || write.type,
                            args: write.args
                        });
                    });
                }
            }
            return items;
        }
        function getExclusiveSummary(measurements) {
            var candidates = {};
            var displayName;
            for (var i = 0; i < measurements.length; i++) {
                var measurement = measurements[i];
                var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
                for (var id in allIDs) {
                    displayName = measurement.displayNames[id].current;
                    candidates[displayName] = candidates[displayName] || {
                        componentName: displayName,
                        inclusive: 0,
                        exclusive: 0,
                        render: 0,
                        count: 0
                    };
                    if (measurement.render[id]) {
                        candidates[displayName].render += measurement.render[id];
                    }
                    if (measurement.exclusive[id]) {
                        candidates[displayName].exclusive += measurement.exclusive[id];
                    }
                    if (measurement.inclusive[id]) {
                        candidates[displayName].inclusive += measurement.inclusive[id];
                    }
                    if (measurement.counts[id]) {
                        candidates[displayName].count += measurement.counts[id];
                    }
                }
            }
            var arr = [];
            for (displayName in candidates) {
                if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
                    arr.push(candidates[displayName]);
                }
            }
            arr.sort(function(a, b) {
                return b.exclusive - a.exclusive;
            });
            return arr;
        }
        function getInclusiveSummary(measurements, onlyClean) {
            var candidates = {};
            var inclusiveKey;
            for (var i = 0; i < measurements.length; i++) {
                var measurement = measurements[i];
                var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
                var cleanComponents;
                if (onlyClean) {
                    cleanComponents = getUnchangedComponents(measurement);
                }
                for (var id in allIDs) {
                    if (onlyClean && !cleanComponents[id]) {
                        continue;
                    }
                    var displayName = measurement.displayNames[id];
                    inclusiveKey = displayName.owner + " > " + displayName.current;
                    candidates[inclusiveKey] = candidates[inclusiveKey] || {
                        componentName: inclusiveKey,
                        time: 0,
                        count: 0
                    };
                    if (measurement.inclusive[id]) {
                        candidates[inclusiveKey].time += measurement.inclusive[id];
                    }
                    if (measurement.counts[id]) {
                        candidates[inclusiveKey].count += measurement.counts[id];
                    }
                }
            }
            var arr = [];
            for (inclusiveKey in candidates) {
                if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
                    arr.push(candidates[inclusiveKey]);
                }
            }
            arr.sort(function(a, b) {
                return b.time - a.time;
            });
            return arr;
        }
        function getUnchangedComponents(measurement) {
            var cleanComponents = {};
            var dirtyLeafIDs = Object.keys(measurement.writes);
            var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
            for (var id in allIDs) {
                var isDirty = false;
                for (var i = 0; i < dirtyLeafIDs.length; i++) {
                    if (dirtyLeafIDs[i].indexOf(id) === 0) {
                        isDirty = true;
                        break;
                    }
                }
                if (!isDirty && measurement.counts[id] > 0) {
                    cleanComponents[id] = true;
                }
            }
            return cleanComponents;
        }
        var ReactDefaultPerfAnalysis = {
            getExclusiveSummary: getExclusiveSummary,
            getInclusiveSummary: getInclusiveSummary,
            getDOMSummary: getDOMSummary,
            getTotalTime: getTotalTime
        };
        module.exports = ReactDefaultPerfAnalysis;
    }, {
        "./Object.assign": 26
    } ],
    57: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactContext = require("./ReactContext");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var assign = require("./Object.assign");
            var warning = require("./warning");
            var RESERVED_PROPS = {
                key: true,
                ref: true
            };
            function defineWarningProperty(object, key) {
                Object.defineProperty(object, key, {
                    configurable: false,
                    enumerable: true,
                    get: function() {
                        if (!this._store) {
                            return null;
                        }
                        return this._store[key];
                    },
                    set: function(value) {
                        "production" !== process.env.NODE_ENV ? warning(false, "Don't set the %s property of the React element. Instead, " + "specify the correct value when initially creating the element.", key) : null;
                        this._store[key] = value;
                    }
                });
            }
            var useMutationMembrane = false;
            function defineMutationMembrane(prototype) {
                try {
                    var pseudoFrozenProperties = {
                        props: true
                    };
                    for (var key in pseudoFrozenProperties) {
                        defineWarningProperty(prototype, key);
                    }
                    useMutationMembrane = true;
                } catch (x) {}
            }
            var ReactElement = function(type, key, ref, owner, context, props) {
                this.type = type;
                this.key = key;
                this.ref = ref;
                this._owner = owner;
                this._context = context;
                if ("production" !== process.env.NODE_ENV) {
                    this._store = {
                        props: props,
                        originalProps: assign({}, props)
                    };
                    try {
                        Object.defineProperty(this._store, "validated", {
                            configurable: false,
                            enumerable: false,
                            writable: true
                        });
                    } catch (x) {}
                    this._store.validated = false;
                    if (useMutationMembrane) {
                        Object.freeze(this);
                        return;
                    }
                }
                this.props = props;
            };
            ReactElement.prototype = {
                _isReactElement: true
            };
            if ("production" !== process.env.NODE_ENV) {
                defineMutationMembrane(ReactElement.prototype);
            }
            ReactElement.createElement = function(type, config, children) {
                var propName;
                var props = {};
                var key = null;
                var ref = null;
                if (config != null) {
                    ref = config.ref === undefined ? null : config.ref;
                    key = config.key === undefined ? null : "" + config.key;
                    for (propName in config) {
                        if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                            props[propName] = config[propName];
                        }
                    }
                }
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                    props.children = children;
                } else if (childrenLength > 1) {
                    var childArray = Array(childrenLength);
                    for (var i = 0; i < childrenLength; i++) {
                        childArray[i] = arguments[i + 2];
                    }
                    props.children = childArray;
                }
                if (type && type.defaultProps) {
                    var defaultProps = type.defaultProps;
                    for (propName in defaultProps) {
                        if (typeof props[propName] === "undefined") {
                            props[propName] = defaultProps[propName];
                        }
                    }
                }
                return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props);
            };
            ReactElement.createFactory = function(type) {
                var factory = ReactElement.createElement.bind(null, type);
                factory.type = type;
                return factory;
            };
            ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
                var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);
                if ("production" !== process.env.NODE_ENV) {
                    newElement._store.validated = oldElement._store.validated;
                }
                return newElement;
            };
            ReactElement.cloneElement = function(element, config, children) {
                var propName;
                var props = assign({}, element.props);
                var key = element.key;
                var ref = element.ref;
                var owner = element._owner;
                if (config != null) {
                    if (config.ref !== undefined) {
                        ref = config.ref;
                        owner = ReactCurrentOwner.current;
                    }
                    if (config.key !== undefined) {
                        key = "" + config.key;
                    }
                    for (propName in config) {
                        if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                            props[propName] = config[propName];
                        }
                    }
                }
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                    props.children = children;
                } else if (childrenLength > 1) {
                    var childArray = Array(childrenLength);
                    for (var i = 0; i < childrenLength; i++) {
                        childArray[i] = arguments[i + 2];
                    }
                    props.children = childArray;
                }
                return new ReactElement(element.type, key, ref, owner, element._context, props);
            };
            ReactElement.isValidElement = function(object) {
                var isElement = !!(object && object._isReactElement);
                return isElement;
            };
            module.exports = ReactElement;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./ReactContext": 38,
        "./ReactCurrentOwner": 39,
        "./warning": 154,
        _process: 156
    } ],
    58: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactElement = require("./ReactElement");
            var ReactFragment = require("./ReactFragment");
            var ReactPropTypeLocations = require("./ReactPropTypeLocations");
            var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactNativeComponent = require("./ReactNativeComponent");
            var getIteratorFn = require("./getIteratorFn");
            var invariant = require("./invariant");
            var warning = require("./warning");
            function getDeclarationErrorAddendum() {
                if (ReactCurrentOwner.current) {
                    var name = ReactCurrentOwner.current.getName();
                    if (name) {
                        return " Check the render method of `" + name + "`.";
                    }
                }
                return "";
            }
            var ownerHasKeyUseWarning = {};
            var loggedTypeFailures = {};
            var NUMERIC_PROPERTY_REGEX = /^\d+$/;
            function getName(instance) {
                var publicInstance = instance && instance.getPublicInstance();
                if (!publicInstance) {
                    return undefined;
                }
                var constructor = publicInstance.constructor;
                if (!constructor) {
                    return undefined;
                }
                return constructor.displayName || constructor.name || undefined;
            }
            function getCurrentOwnerDisplayName() {
                var current = ReactCurrentOwner.current;
                return current && getName(current) || undefined;
            }
            function validateExplicitKey(element, parentType) {
                if (element._store.validated || element.key != null) {
                    return;
                }
                element._store.validated = true;
                warnAndMonitorForKeyUse('Each child in an array or iterator should have a unique "key" prop.', element, parentType);
            }
            function validatePropertyKey(name, element, parentType) {
                if (!NUMERIC_PROPERTY_REGEX.test(name)) {
                    return;
                }
                warnAndMonitorForKeyUse("Child objects should have non-numeric keys so ordering is preserved.", element, parentType);
            }
            function warnAndMonitorForKeyUse(message, element, parentType) {
                var ownerName = getCurrentOwnerDisplayName();
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                var useName = ownerName || parentName;
                var memoizer = ownerHasKeyUseWarning[message] || (ownerHasKeyUseWarning[message] = {});
                if (memoizer.hasOwnProperty(useName)) {
                    return;
                }
                memoizer[useName] = true;
                var parentOrOwnerAddendum = ownerName ? " Check the render method of " + ownerName + "." : parentName ? " Check the React.render call using <" + parentName + ">." : "";
                var childOwnerAddendum = "";
                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                    var childOwnerName = getName(element._owner);
                    childOwnerAddendum = " It was passed a child from " + childOwnerName + ".";
                }
                "production" !== process.env.NODE_ENV ? warning(false, message + "%s%s See https://fb.me/react-warning-keys for more information.", parentOrOwnerAddendum, childOwnerAddendum) : null;
            }
            function validateChildKeys(node, parentType) {
                if (Array.isArray(node)) {
                    for (var i = 0; i < node.length; i++) {
                        var child = node[i];
                        if (ReactElement.isValidElement(child)) {
                            validateExplicitKey(child, parentType);
                        }
                    }
                } else if (ReactElement.isValidElement(node)) {
                    node._store.validated = true;
                } else if (node) {
                    var iteratorFn = getIteratorFn(node);
                    if (iteratorFn) {
                        if (iteratorFn !== node.entries) {
                            var iterator = iteratorFn.call(node);
                            var step;
                            while (!(step = iterator.next()).done) {
                                if (ReactElement.isValidElement(step.value)) {
                                    validateExplicitKey(step.value, parentType);
                                }
                            }
                        }
                    } else if (typeof node === "object") {
                        var fragment = ReactFragment.extractIfFragment(node);
                        for (var key in fragment) {
                            if (fragment.hasOwnProperty(key)) {
                                validatePropertyKey(key, fragment[key], parentType);
                            }
                        }
                    }
                }
            }
            function checkPropTypes(componentName, propTypes, props, location) {
                for (var propName in propTypes) {
                    if (propTypes.hasOwnProperty(propName)) {
                        var error;
                        try {
                            "production" !== process.env.NODE_ENV ? invariant(typeof propTypes[propName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from " + "React.PropTypes.", componentName || "React class", ReactPropTypeLocationNames[location], propName) : invariant(typeof propTypes[propName] === "function");
                            error = propTypes[propName](props, propName, componentName, location);
                        } catch (ex) {
                            error = ex;
                        }
                        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                            loggedTypeFailures[error.message] = true;
                            var addendum = getDeclarationErrorAddendum(this);
                            "production" !== process.env.NODE_ENV ? warning(false, "Failed propType: %s%s", error.message, addendum) : null;
                        }
                    }
                }
            }
            var warnedPropsMutations = {};
            function warnForPropsMutation(propName, element) {
                var type = element.type;
                var elementName = typeof type === "string" ? type : type.displayName;
                var ownerName = element._owner ? element._owner.getPublicInstance().constructor.displayName : null;
                var warningKey = propName + "|" + elementName + "|" + ownerName;
                if (warnedPropsMutations.hasOwnProperty(warningKey)) {
                    return;
                }
                warnedPropsMutations[warningKey] = true;
                var elementInfo = "";
                if (elementName) {
                    elementInfo = " <" + elementName + " />";
                }
                var ownerInfo = "";
                if (ownerName) {
                    ownerInfo = " The element was created by " + ownerName + ".";
                }
                "production" !== process.env.NODE_ENV ? warning(false, "Don't set .props.%s of the React component%s. Instead, specify the " + "correct value when initially creating the element or use " + "React.cloneElement to make a new element with updated props.%s", propName, elementInfo, ownerInfo) : null;
            }
            function is(a, b) {
                if (a !== a) {
                    return b !== b;
                }
                if (a === 0 && b === 0) {
                    return 1 / a === 1 / b;
                }
                return a === b;
            }
            function checkAndWarnForMutatedProps(element) {
                if (!element._store) {
                    return;
                }
                var originalProps = element._store.originalProps;
                var props = element.props;
                for (var propName in props) {
                    if (props.hasOwnProperty(propName)) {
                        if (!originalProps.hasOwnProperty(propName) || !is(originalProps[propName], props[propName])) {
                            warnForPropsMutation(propName, element);
                            originalProps[propName] = props[propName];
                        }
                    }
                }
            }
            function validatePropTypes(element) {
                if (element.type == null) {
                    return;
                }
                var componentClass = ReactNativeComponent.getComponentClassForElement(element);
                var name = componentClass.displayName || componentClass.name;
                if (componentClass.propTypes) {
                    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
                }
                if (typeof componentClass.getDefaultProps === "function") {
                    "production" !== process.env.NODE_ENV ? warning(componentClass.getDefaultProps.isReactClassApproved, "getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.") : null;
                }
            }
            var ReactElementValidator = {
                checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,
                createElement: function(type, props, children) {
                    "production" !== process.env.NODE_ENV ? warning(type != null, "React.createElement: type should not be null or undefined. It should " + "be a string (for DOM elements) or a ReactClass (for composite " + "components).") : null;
                    var element = ReactElement.createElement.apply(this, arguments);
                    if (element == null) {
                        return element;
                    }
                    for (var i = 2; i < arguments.length; i++) {
                        validateChildKeys(arguments[i], type);
                    }
                    validatePropTypes(element);
                    return element;
                },
                createFactory: function(type) {
                    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
                    validatedFactory.type = type;
                    if ("production" !== process.env.NODE_ENV) {
                        try {
                            Object.defineProperty(validatedFactory, "type", {
                                enumerable: false,
                                get: function() {
                                    "production" !== process.env.NODE_ENV ? warning(false, "Factory.type is deprecated. Access the class directly " + "before passing it to createFactory.") : null;
                                    Object.defineProperty(this, "type", {
                                        value: type
                                    });
                                    return type;
                                }
                            });
                        } catch (x) {}
                    }
                    return validatedFactory;
                },
                cloneElement: function(element, props, children) {
                    var newElement = ReactElement.cloneElement.apply(this, arguments);
                    for (var i = 2; i < arguments.length; i++) {
                        validateChildKeys(arguments[i], newElement.type);
                    }
                    validatePropTypes(newElement);
                    return newElement;
                }
            };
            module.exports = ReactElementValidator;
        }).call(this, require("_process"));
    }, {
        "./ReactCurrentOwner": 39,
        "./ReactElement": 57,
        "./ReactFragment": 63,
        "./ReactNativeComponent": 73,
        "./ReactPropTypeLocationNames": 76,
        "./ReactPropTypeLocations": 77,
        "./getIteratorFn": 126,
        "./invariant": 135,
        "./warning": 154,
        _process: 156
    } ],
    59: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactElement = require("./ReactElement");
            var ReactInstanceMap = require("./ReactInstanceMap");
            var invariant = require("./invariant");
            var component;
            var nullComponentIDsRegistry = {};
            var ReactEmptyComponentInjection = {
                injectEmptyComponent: function(emptyComponent) {
                    component = ReactElement.createFactory(emptyComponent);
                }
            };
            var ReactEmptyComponentType = function() {};
            ReactEmptyComponentType.prototype.componentDidMount = function() {
                var internalInstance = ReactInstanceMap.get(this);
                if (!internalInstance) {
                    return;
                }
                registerNullComponentID(internalInstance._rootNodeID);
            };
            ReactEmptyComponentType.prototype.componentWillUnmount = function() {
                var internalInstance = ReactInstanceMap.get(this);
                if (!internalInstance) {
                    return;
                }
                deregisterNullComponentID(internalInstance._rootNodeID);
            };
            ReactEmptyComponentType.prototype.render = function() {
                "production" !== process.env.NODE_ENV ? invariant(component, "Trying to return null from a render, but no null placeholder component " + "was injected.") : invariant(component);
                return component();
            };
            var emptyElement = ReactElement.createElement(ReactEmptyComponentType);
            function registerNullComponentID(id) {
                nullComponentIDsRegistry[id] = true;
            }
            function deregisterNullComponentID(id) {
                delete nullComponentIDsRegistry[id];
            }
            function isNullComponentID(id) {
                return !!nullComponentIDsRegistry[id];
            }
            var ReactEmptyComponent = {
                emptyElement: emptyElement,
                injection: ReactEmptyComponentInjection,
                isNullComponentID: isNullComponentID
            };
            module.exports = ReactEmptyComponent;
        }).call(this, require("_process"));
    }, {
        "./ReactElement": 57,
        "./ReactInstanceMap": 67,
        "./invariant": 135,
        _process: 156
    } ],
    60: [ function(require, module, exports) {
        "use strict";
        var ReactErrorUtils = {
            guard: function(func, name) {
                return func;
            }
        };
        module.exports = ReactErrorUtils;
    }, {} ],
    61: [ function(require, module, exports) {
        "use strict";
        var EventPluginHub = require("./EventPluginHub");
        function runEventQueueInBatch(events) {
            EventPluginHub.enqueueEvents(events);
            EventPluginHub.processEventQueue();
        }
        var ReactEventEmitterMixin = {
            handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
                runEventQueueInBatch(events);
            }
        };
        module.exports = ReactEventEmitterMixin;
    }, {
        "./EventPluginHub": 16
    } ],
    62: [ function(require, module, exports) {
        "use strict";
        var EventListener = require("./EventListener");
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var PooledClass = require("./PooledClass");
        var ReactInstanceHandles = require("./ReactInstanceHandles");
        var ReactMount = require("./ReactMount");
        var ReactUpdates = require("./ReactUpdates");
        var assign = require("./Object.assign");
        var getEventTarget = require("./getEventTarget");
        var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");
        function findParent(node) {
            var nodeID = ReactMount.getID(node);
            var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
            var container = ReactMount.findReactContainerForID(rootID);
            var parent = ReactMount.getFirstReactDOM(container);
            return parent;
        }
        function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
            this.topLevelType = topLevelType;
            this.nativeEvent = nativeEvent;
            this.ancestors = [];
        }
        assign(TopLevelCallbackBookKeeping.prototype, {
            destructor: function() {
                this.topLevelType = null;
                this.nativeEvent = null;
                this.ancestors.length = 0;
            }
        });
        PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
        function handleTopLevelImpl(bookKeeping) {
            var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
            var ancestor = topLevelTarget;
            while (ancestor) {
                bookKeeping.ancestors.push(ancestor);
                ancestor = findParent(ancestor);
            }
            for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
                topLevelTarget = bookKeeping.ancestors[i];
                var topLevelTargetID = ReactMount.getID(topLevelTarget) || "";
                ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);
            }
        }
        function scrollValueMonitor(cb) {
            var scrollPosition = getUnboundedScrollPosition(window);
            cb(scrollPosition);
        }
        var ReactEventListener = {
            _enabled: true,
            _handleTopLevel: null,
            WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
            setHandleTopLevel: function(handleTopLevel) {
                ReactEventListener._handleTopLevel = handleTopLevel;
            },
            setEnabled: function(enabled) {
                ReactEventListener._enabled = !!enabled;
            },
            isEnabled: function() {
                return ReactEventListener._enabled;
            },
            trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
                var element = handle;
                if (!element) {
                    return null;
                }
                return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
            },
            trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
                var element = handle;
                if (!element) {
                    return null;
                }
                return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
            },
            monitorScrollValue: function(refresh) {
                var callback = scrollValueMonitor.bind(null, refresh);
                EventListener.listen(window, "scroll", callback);
            },
            dispatchEvent: function(topLevelType, nativeEvent) {
                if (!ReactEventListener._enabled) {
                    return;
                }
                var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
                try {
                    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
                } finally {
                    TopLevelCallbackBookKeeping.release(bookKeeping);
                }
            }
        };
        module.exports = ReactEventListener;
    }, {
        "./EventListener": 15,
        "./ExecutionEnvironment": 20,
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./ReactInstanceHandles": 66,
        "./ReactMount": 70,
        "./ReactUpdates": 87,
        "./getEventTarget": 125,
        "./getUnboundedScrollPosition": 131
    } ],
    63: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactElement = require("./ReactElement");
            var warning = require("./warning");
            if ("production" !== process.env.NODE_ENV) {
                var fragmentKey = "_reactFragment";
                var didWarnKey = "_reactDidWarn";
                var canWarnForReactFragment = false;
                try {
                    var dummy = function() {
                        return 1;
                    };
                    Object.defineProperty({}, fragmentKey, {
                        enumerable: false,
                        value: true
                    });
                    Object.defineProperty({}, "key", {
                        enumerable: true,
                        get: dummy
                    });
                    canWarnForReactFragment = true;
                } catch (x) {}
                var proxyPropertyAccessWithWarning = function(obj, key) {
                    Object.defineProperty(obj, key, {
                        enumerable: true,
                        get: function() {
                            "production" !== process.env.NODE_ENV ? warning(this[didWarnKey], "A ReactFragment is an opaque type. Accessing any of its " + "properties is deprecated. Pass it to one of the React.Children " + "helpers.") : null;
                            this[didWarnKey] = true;
                            return this[fragmentKey][key];
                        },
                        set: function(value) {
                            "production" !== process.env.NODE_ENV ? warning(this[didWarnKey], "A ReactFragment is an immutable opaque type. Mutating its " + "properties is deprecated.") : null;
                            this[didWarnKey] = true;
                            this[fragmentKey][key] = value;
                        }
                    });
                };
                var issuedWarnings = {};
                var didWarnForFragment = function(fragment) {
                    var fragmentCacheKey = "";
                    for (var key in fragment) {
                        fragmentCacheKey += key + ":" + typeof fragment[key] + ",";
                    }
                    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];
                    issuedWarnings[fragmentCacheKey] = true;
                    return alreadyWarnedOnce;
                };
            }
            var ReactFragment = {
                create: function(object) {
                    if ("production" !== process.env.NODE_ENV) {
                        if (typeof object !== "object" || !object || Array.isArray(object)) {
                            "production" !== process.env.NODE_ENV ? warning(false, "React.addons.createFragment only accepts a single object.", object) : null;
                            return object;
                        }
                        if (ReactElement.isValidElement(object)) {
                            "production" !== process.env.NODE_ENV ? warning(false, "React.addons.createFragment does not accept a ReactElement " + "without a wrapper object.") : null;
                            return object;
                        }
                        if (canWarnForReactFragment) {
                            var proxy = {};
                            Object.defineProperty(proxy, fragmentKey, {
                                enumerable: false,
                                value: object
                            });
                            Object.defineProperty(proxy, didWarnKey, {
                                writable: true,
                                enumerable: false,
                                value: false
                            });
                            for (var key in object) {
                                proxyPropertyAccessWithWarning(proxy, key);
                            }
                            Object.preventExtensions(proxy);
                            return proxy;
                        }
                    }
                    return object;
                },
                extract: function(fragment) {
                    if ("production" !== process.env.NODE_ENV) {
                        if (canWarnForReactFragment) {
                            if (!fragment[fragmentKey]) {
                                "production" !== process.env.NODE_ENV ? warning(didWarnForFragment(fragment), "Any use of a keyed object should be wrapped in " + "React.addons.createFragment(object) before being passed as a " + "child.") : null;
                                return fragment;
                            }
                            return fragment[fragmentKey];
                        }
                    }
                    return fragment;
                },
                extractIfFragment: function(fragment) {
                    if ("production" !== process.env.NODE_ENV) {
                        if (canWarnForReactFragment) {
                            if (fragment[fragmentKey]) {
                                return fragment[fragmentKey];
                            }
                            for (var key in fragment) {
                                if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key])) {
                                    return ReactFragment.extract(fragment);
                                }
                            }
                        }
                    }
                    return fragment;
                }
            };
            module.exports = ReactFragment;
        }).call(this, require("_process"));
    }, {
        "./ReactElement": 57,
        "./warning": 154,
        _process: 156
    } ],
    64: [ function(require, module, exports) {
        "use strict";
        var DOMProperty = require("./DOMProperty");
        var EventPluginHub = require("./EventPluginHub");
        var ReactComponentEnvironment = require("./ReactComponentEnvironment");
        var ReactClass = require("./ReactClass");
        var ReactEmptyComponent = require("./ReactEmptyComponent");
        var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
        var ReactNativeComponent = require("./ReactNativeComponent");
        var ReactDOMComponent = require("./ReactDOMComponent");
        var ReactPerf = require("./ReactPerf");
        var ReactRootIndex = require("./ReactRootIndex");
        var ReactUpdates = require("./ReactUpdates");
        var ReactInjection = {
            Component: ReactComponentEnvironment.injection,
            Class: ReactClass.injection,
            DOMComponent: ReactDOMComponent.injection,
            DOMProperty: DOMProperty.injection,
            EmptyComponent: ReactEmptyComponent.injection,
            EventPluginHub: EventPluginHub.injection,
            EventEmitter: ReactBrowserEventEmitter.injection,
            NativeComponent: ReactNativeComponent.injection,
            Perf: ReactPerf.injection,
            RootIndex: ReactRootIndex.injection,
            Updates: ReactUpdates.injection
        };
        module.exports = ReactInjection;
    }, {
        "./DOMProperty": 9,
        "./EventPluginHub": 16,
        "./ReactBrowserEventEmitter": 30,
        "./ReactClass": 33,
        "./ReactComponentEnvironment": 36,
        "./ReactDOMComponent": 42,
        "./ReactEmptyComponent": 59,
        "./ReactNativeComponent": 73,
        "./ReactPerf": 75,
        "./ReactRootIndex": 83,
        "./ReactUpdates": 87
    } ],
    65: [ function(require, module, exports) {
        "use strict";
        var ReactDOMSelection = require("./ReactDOMSelection");
        var containsNode = require("./containsNode");
        var focusNode = require("./focusNode");
        var getActiveElement = require("./getActiveElement");
        function isInDocument(node) {
            return containsNode(document.documentElement, node);
        }
        var ReactInputSelection = {
            hasSelectionCapabilities: function(elem) {
                return elem && (elem.nodeName === "INPUT" && elem.type === "text" || elem.nodeName === "TEXTAREA" || elem.contentEditable === "true");
            },
            getSelectionInformation: function() {
                var focusedElem = getActiveElement();
                return {
                    focusedElem: focusedElem,
                    selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
                };
            },
            restoreSelection: function(priorSelectionInformation) {
                var curFocusedElem = getActiveElement();
                var priorFocusedElem = priorSelectionInformation.focusedElem;
                var priorSelectionRange = priorSelectionInformation.selectionRange;
                if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
                    if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
                        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
                    }
                    focusNode(priorFocusedElem);
                }
            },
            getSelection: function(input) {
                var selection;
                if ("selectionStart" in input) {
                    selection = {
                        start: input.selectionStart,
                        end: input.selectionEnd
                    };
                } else if (document.selection && input.nodeName === "INPUT") {
                    var range = document.selection.createRange();
                    if (range.parentElement() === input) {
                        selection = {
                            start: -range.moveStart("character", -input.value.length),
                            end: -range.moveEnd("character", -input.value.length)
                        };
                    }
                } else {
                    selection = ReactDOMSelection.getOffsets(input);
                }
                return selection || {
                    start: 0,
                    end: 0
                };
            },
            setSelection: function(input, offsets) {
                var start = offsets.start;
                var end = offsets.end;
                if (typeof end === "undefined") {
                    end = start;
                }
                if ("selectionStart" in input) {
                    input.selectionStart = start;
                    input.selectionEnd = Math.min(end, input.value.length);
                } else if (document.selection && input.nodeName === "INPUT") {
                    var range = input.createTextRange();
                    range.collapse(true);
                    range.moveStart("character", start);
                    range.moveEnd("character", end - start);
                    range.select();
                } else {
                    ReactDOMSelection.setOffsets(input, offsets);
                }
            }
        };
        module.exports = ReactInputSelection;
    }, {
        "./ReactDOMSelection": 50,
        "./containsNode": 109,
        "./focusNode": 119,
        "./getActiveElement": 121
    } ],
    66: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactRootIndex = require("./ReactRootIndex");
            var invariant = require("./invariant");
            var SEPARATOR = ".";
            var SEPARATOR_LENGTH = SEPARATOR.length;
            var MAX_TREE_DEPTH = 100;
            function getReactRootIDString(index) {
                return SEPARATOR + index.toString(36);
            }
            function isBoundary(id, index) {
                return id.charAt(index) === SEPARATOR || index === id.length;
            }
            function isValidID(id) {
                return id === "" || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
            }
            function isAncestorIDOf(ancestorID, descendantID) {
                return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
            }
            function getParentID(id) {
                return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : "";
            }
            function getNextDescendantID(ancestorID, destinationID) {
                "production" !== process.env.NODE_ENV ? invariant(isValidID(ancestorID) && isValidID(destinationID), "getNextDescendantID(%s, %s): Received an invalid React DOM ID.", ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID));
                "production" !== process.env.NODE_ENV ? invariant(isAncestorIDOf(ancestorID, destinationID), "getNextDescendantID(...): React has made an invalid assumption about " + "the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.", ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID));
                if (ancestorID === destinationID) {
                    return ancestorID;
                }
                var start = ancestorID.length + SEPARATOR_LENGTH;
                var i;
                for (i = start; i < destinationID.length; i++) {
                    if (isBoundary(destinationID, i)) {
                        break;
                    }
                }
                return destinationID.substr(0, i);
            }
            function getFirstCommonAncestorID(oneID, twoID) {
                var minLength = Math.min(oneID.length, twoID.length);
                if (minLength === 0) {
                    return "";
                }
                var lastCommonMarkerIndex = 0;
                for (var i = 0; i <= minLength; i++) {
                    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
                        lastCommonMarkerIndex = i;
                    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
                        break;
                    }
                }
                var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
                "production" !== process.env.NODE_ENV ? invariant(isValidID(longestCommonID), "getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s", oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID));
                return longestCommonID;
            }
            function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
                start = start || "";
                stop = stop || "";
                "production" !== process.env.NODE_ENV ? invariant(start !== stop, "traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.", start) : invariant(start !== stop);
                var traverseUp = isAncestorIDOf(stop, start);
                "production" !== process.env.NODE_ENV ? invariant(traverseUp || isAncestorIDOf(start, stop), "traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do " + "not have a parent path.", start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop));
                var depth = 0;
                var traverse = traverseUp ? getParentID : getNextDescendantID;
                for (var id = start; ;id = traverse(id, stop)) {
                    var ret;
                    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
                        ret = cb(id, traverseUp, arg);
                    }
                    if (ret === false || id === stop) {
                        break;
                    }
                    "production" !== process.env.NODE_ENV ? invariant(depth++ < MAX_TREE_DEPTH, "traverseParentPath(%s, %s, ...): Detected an infinite loop while " + "traversing the React DOM ID tree. This may be due to malformed IDs: %s", start, stop) : invariant(depth++ < MAX_TREE_DEPTH);
                }
            }
            var ReactInstanceHandles = {
                createReactRootID: function() {
                    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
                },
                createReactID: function(rootID, name) {
                    return rootID + name;
                },
                getReactRootIDFromNodeID: function(id) {
                    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
                        var index = id.indexOf(SEPARATOR, 1);
                        return index > -1 ? id.substr(0, index) : id;
                    }
                    return null;
                },
                traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
                    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
                    if (ancestorID !== leaveID) {
                        traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
                    }
                    if (ancestorID !== enterID) {
                        traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
                    }
                },
                traverseTwoPhase: function(targetID, cb, arg) {
                    if (targetID) {
                        traverseParentPath("", targetID, cb, arg, true, false);
                        traverseParentPath(targetID, "", cb, arg, false, true);
                    }
                },
                traverseAncestors: function(targetID, cb, arg) {
                    traverseParentPath("", targetID, cb, arg, true, false);
                },
                _getFirstCommonAncestorID: getFirstCommonAncestorID,
                _getNextDescendantID: getNextDescendantID,
                isAncestorIDOf: isAncestorIDOf,
                SEPARATOR: SEPARATOR
            };
            module.exports = ReactInstanceHandles;
        }).call(this, require("_process"));
    }, {
        "./ReactRootIndex": 83,
        "./invariant": 135,
        _process: 156
    } ],
    67: [ function(require, module, exports) {
        "use strict";
        var ReactInstanceMap = {
            remove: function(key) {
                key._reactInternalInstance = undefined;
            },
            get: function(key) {
                return key._reactInternalInstance;
            },
            has: function(key) {
                return key._reactInternalInstance !== undefined;
            },
            set: function(key, value) {
                key._reactInternalInstance = value;
            }
        };
        module.exports = ReactInstanceMap;
    }, {} ],
    68: [ function(require, module, exports) {
        "use strict";
        var ReactLifeCycle = {
            currentlyMountingInstance: null,
            currentlyUnmountingInstance: null
        };
        module.exports = ReactLifeCycle;
    }, {} ],
    69: [ function(require, module, exports) {
        "use strict";
        var adler32 = require("./adler32");
        var ReactMarkupChecksum = {
            CHECKSUM_ATTR_NAME: "data-react-checksum",
            addChecksumToMarkup: function(markup) {
                var checksum = adler32(markup);
                return markup.replace(">", " " + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">');
            },
            canReuseMarkup: function(markup, element) {
                var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
                var markupChecksum = adler32(markup);
                return markupChecksum === existingChecksum;
            }
        };
        module.exports = ReactMarkupChecksum;
    }, {
        "./adler32": 106
    } ],
    70: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var DOMProperty = require("./DOMProperty");
            var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactElement = require("./ReactElement");
            var ReactElementValidator = require("./ReactElementValidator");
            var ReactEmptyComponent = require("./ReactEmptyComponent");
            var ReactInstanceHandles = require("./ReactInstanceHandles");
            var ReactInstanceMap = require("./ReactInstanceMap");
            var ReactMarkupChecksum = require("./ReactMarkupChecksum");
            var ReactPerf = require("./ReactPerf");
            var ReactReconciler = require("./ReactReconciler");
            var ReactUpdateQueue = require("./ReactUpdateQueue");
            var ReactUpdates = require("./ReactUpdates");
            var emptyObject = require("./emptyObject");
            var containsNode = require("./containsNode");
            var getReactRootElementInContainer = require("./getReactRootElementInContainer");
            var instantiateReactComponent = require("./instantiateReactComponent");
            var invariant = require("./invariant");
            var setInnerHTML = require("./setInnerHTML");
            var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
            var warning = require("./warning");
            var SEPARATOR = ReactInstanceHandles.SEPARATOR;
            var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
            var nodeCache = {};
            var ELEMENT_NODE_TYPE = 1;
            var DOC_NODE_TYPE = 9;
            var instancesByReactRootID = {};
            var containersByReactRootID = {};
            if ("production" !== process.env.NODE_ENV) {
                var rootElementsByReactRootID = {};
            }
            var findComponentRootReusableArray = [];
            function firstDifferenceIndex(string1, string2) {
                var minLen = Math.min(string1.length, string2.length);
                for (var i = 0; i < minLen; i++) {
                    if (string1.charAt(i) !== string2.charAt(i)) {
                        return i;
                    }
                }
                return string1.length === string2.length ? -1 : minLen;
            }
            function getReactRootID(container) {
                var rootElement = getReactRootElementInContainer(container);
                return rootElement && ReactMount.getID(rootElement);
            }
            function getID(node) {
                var id = internalGetID(node);
                if (id) {
                    if (nodeCache.hasOwnProperty(id)) {
                        var cached = nodeCache[id];
                        if (cached !== node) {
                            "production" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), "ReactMount: Two valid but unequal nodes with the same `%s`: %s", ATTR_NAME, id) : invariant(!isValid(cached, id));
                            nodeCache[id] = node;
                        }
                    } else {
                        nodeCache[id] = node;
                    }
                }
                return id;
            }
            function internalGetID(node) {
                return node && node.getAttribute && node.getAttribute(ATTR_NAME) || "";
            }
            function setID(node, id) {
                var oldID = internalGetID(node);
                if (oldID !== id) {
                    delete nodeCache[oldID];
                }
                node.setAttribute(ATTR_NAME, id);
                nodeCache[id] = node;
            }
            function getNode(id) {
                if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
                    nodeCache[id] = ReactMount.findReactNodeByID(id);
                }
                return nodeCache[id];
            }
            function getNodeFromInstance(instance) {
                var id = ReactInstanceMap.get(instance)._rootNodeID;
                if (ReactEmptyComponent.isNullComponentID(id)) {
                    return null;
                }
                if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
                    nodeCache[id] = ReactMount.findReactNodeByID(id);
                }
                return nodeCache[id];
            }
            function isValid(node, id) {
                if (node) {
                    "production" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, "ReactMount: Unexpected modification of `%s`", ATTR_NAME) : invariant(internalGetID(node) === id);
                    var container = ReactMount.findReactContainerForID(id);
                    if (container && containsNode(container, node)) {
                        return true;
                    }
                }
                return false;
            }
            function purgeID(id) {
                delete nodeCache[id];
            }
            var deepestNodeSoFar = null;
            function findDeepestCachedAncestorImpl(ancestorID) {
                var ancestor = nodeCache[ancestorID];
                if (ancestor && isValid(ancestor, ancestorID)) {
                    deepestNodeSoFar = ancestor;
                } else {
                    return false;
                }
            }
            function findDeepestCachedAncestor(targetID) {
                deepestNodeSoFar = null;
                ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
                var foundNode = deepestNodeSoFar;
                deepestNodeSoFar = null;
                return foundNode;
            }
            function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup) {
                var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, emptyObject);
                componentInstance._isTopLevel = true;
                ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);
            }
            function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup) {
                var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
                transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup);
                ReactUpdates.ReactReconcileTransaction.release(transaction);
            }
            var ReactMount = {
                _instancesByReactRootID: instancesByReactRootID,
                scrollMonitor: function(container, renderCallback) {
                    renderCallback();
                },
                _updateRootComponent: function(prevComponent, nextElement, container, callback) {
                    if ("production" !== process.env.NODE_ENV) {
                        ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
                    }
                    ReactMount.scrollMonitor(container, function() {
                        ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
                        if (callback) {
                            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
                        }
                    });
                    if ("production" !== process.env.NODE_ENV) {
                        rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
                    }
                    return prevComponent;
                },
                _registerComponent: function(nextComponent, container) {
                    "production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "_registerComponent(...): Target container is not a DOM element.") : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));
                    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
                    var reactRootID = ReactMount.registerContainer(container);
                    instancesByReactRootID[reactRootID] = nextComponent;
                    return reactRootID;
                },
                _renderNewRootComponent: function(nextElement, container, shouldReuseMarkup) {
                    "production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, "_renderNewRootComponent(): Render methods should be a pure function " + "of props and state; triggering nested component updates from " + "render is not allowed. If necessary, trigger nested updates in " + "componentDidUpdate.") : null;
                    var componentInstance = instantiateReactComponent(nextElement, null);
                    var reactRootID = ReactMount._registerComponent(componentInstance, container);
                    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup);
                    if ("production" !== process.env.NODE_ENV) {
                        rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
                    }
                    return componentInstance;
                },
                render: function(nextElement, container, callback) {
                    "production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), "React.render(): Invalid component element.%s", typeof nextElement === "string" ? " Instead of passing an element string, make sure to instantiate " + "it by passing it to React.createElement." : typeof nextElement === "function" ? " Instead of passing a component class, make sure to instantiate " + "it by passing it to React.createElement." : nextElement != null && nextElement.props !== undefined ? " This may be caused by unintentionally loading two independent " + "copies of React." : "") : invariant(ReactElement.isValidElement(nextElement));
                    var prevComponent = instancesByReactRootID[getReactRootID(container)];
                    if (prevComponent) {
                        var prevElement = prevComponent._currentElement;
                        if (shouldUpdateReactComponent(prevElement, nextElement)) {
                            return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback).getPublicInstance();
                        } else {
                            ReactMount.unmountComponentAtNode(container);
                        }
                    }
                    var reactRootElement = getReactRootElementInContainer(container);
                    var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
                    if ("production" !== process.env.NODE_ENV) {
                        if (!containerHasReactMarkup || reactRootElement.nextSibling) {
                            var rootElementSibling = reactRootElement;
                            while (rootElementSibling) {
                                if (ReactMount.isRenderedByReact(rootElementSibling)) {
                                    "production" !== process.env.NODE_ENV ? warning(false, "render(): Target node has markup rendered by React, but there " + "are unrelated nodes as well. This is most commonly caused by " + "white-space inserted around server-rendered markup.") : null;
                                    break;
                                }
                                rootElementSibling = rootElementSibling.nextSibling;
                            }
                        }
                    }
                    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
                    var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup).getPublicInstance();
                    if (callback) {
                        callback.call(component);
                    }
                    return component;
                },
                constructAndRenderComponent: function(constructor, props, container) {
                    var element = ReactElement.createElement(constructor, props);
                    return ReactMount.render(element, container);
                },
                constructAndRenderComponentByID: function(constructor, props, id) {
                    var domNode = document.getElementById(id);
                    "production" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(domNode);
                    return ReactMount.constructAndRenderComponent(constructor, props, domNode);
                },
                registerContainer: function(container) {
                    var reactRootID = getReactRootID(container);
                    if (reactRootID) {
                        reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
                    }
                    if (!reactRootID) {
                        reactRootID = ReactInstanceHandles.createReactRootID();
                    }
                    containersByReactRootID[reactRootID] = container;
                    return reactRootID;
                },
                unmountComponentAtNode: function(container) {
                    "production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, "unmountComponentAtNode(): Render methods should be a pure function of " + "props and state; triggering nested component updates from render is " + "not allowed. If necessary, trigger nested updates in " + "componentDidUpdate.") : null;
                    "production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "unmountComponentAtNode(...): Target container is not a DOM element.") : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));
                    var reactRootID = getReactRootID(container);
                    var component = instancesByReactRootID[reactRootID];
                    if (!component) {
                        return false;
                    }
                    ReactMount.unmountComponentFromNode(component, container);
                    delete instancesByReactRootID[reactRootID];
                    delete containersByReactRootID[reactRootID];
                    if ("production" !== process.env.NODE_ENV) {
                        delete rootElementsByReactRootID[reactRootID];
                    }
                    return true;
                },
                unmountComponentFromNode: function(instance, container) {
                    ReactReconciler.unmountComponent(instance);
                    if (container.nodeType === DOC_NODE_TYPE) {
                        container = container.documentElement;
                    }
                    while (container.lastChild) {
                        container.removeChild(container.lastChild);
                    }
                },
                findReactContainerForID: function(id) {
                    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
                    var container = containersByReactRootID[reactRootID];
                    if ("production" !== process.env.NODE_ENV) {
                        var rootElement = rootElementsByReactRootID[reactRootID];
                        if (rootElement && rootElement.parentNode !== container) {
                            "production" !== process.env.NODE_ENV ? invariant(internalGetID(rootElement) === reactRootID, "ReactMount: Root element ID differed from reactRootID.") : invariant(internalGetID(rootElement) === reactRootID);
                            var containerChild = container.firstChild;
                            if (containerChild && reactRootID === internalGetID(containerChild)) {
                                rootElementsByReactRootID[reactRootID] = containerChild;
                            } else {
                                "production" !== process.env.NODE_ENV ? warning(false, "ReactMount: Root element has been removed from its original " + "container. New container:", rootElement.parentNode) : null;
                            }
                        }
                    }
                    return container;
                },
                findReactNodeByID: function(id) {
                    var reactRoot = ReactMount.findReactContainerForID(id);
                    return ReactMount.findComponentRoot(reactRoot, id);
                },
                isRenderedByReact: function(node) {
                    if (node.nodeType !== 1) {
                        return false;
                    }
                    var id = ReactMount.getID(node);
                    return id ? id.charAt(0) === SEPARATOR : false;
                },
                getFirstReactDOM: function(node) {
                    var current = node;
                    while (current && current.parentNode !== current) {
                        if (ReactMount.isRenderedByReact(current)) {
                            return current;
                        }
                        current = current.parentNode;
                    }
                    return null;
                },
                findComponentRoot: function(ancestorNode, targetID) {
                    var firstChildren = findComponentRootReusableArray;
                    var childIndex = 0;
                    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
                    firstChildren[0] = deepestAncestor.firstChild;
                    firstChildren.length = 1;
                    while (childIndex < firstChildren.length) {
                        var child = firstChildren[childIndex++];
                        var targetChild;
                        while (child) {
                            var childID = ReactMount.getID(child);
                            if (childID) {
                                if (targetID === childID) {
                                    targetChild = child;
                                } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                                    firstChildren.length = childIndex = 0;
                                    firstChildren.push(child.firstChild);
                                }
                            } else {
                                firstChildren.push(child.firstChild);
                            }
                            child = child.nextSibling;
                        }
                        if (targetChild) {
                            firstChildren.length = 0;
                            return targetChild;
                        }
                    }
                    firstChildren.length = 0;
                    "production" !== process.env.NODE_ENV ? invariant(false, "findComponentRoot(..., %s): Unable to find element. This probably " + "means the DOM was unexpectedly mutated (e.g., by the browser), " + "usually due to forgetting a <tbody> when using tables, nesting tags " + "like <form>, <p>, or <a>, or using non-SVG elements in an <svg> " + "parent. " + "Try inspecting the child nodes of the element with React ID `%s`.", targetID, ReactMount.getID(ancestorNode)) : invariant(false);
                },
                _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {
                    "production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "mountComponentIntoNode(...): Target container is not valid.") : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));
                    if (shouldReuseMarkup) {
                        var rootElement = getReactRootElementInContainer(container);
                        if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
                            return;
                        } else {
                            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                            var rootMarkup = rootElement.outerHTML;
                            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
                            var diffIndex = firstDifferenceIndex(markup, rootMarkup);
                            var difference = " (client) " + markup.substring(diffIndex - 20, diffIndex + 20) + "\n (server) " + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
                            "production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, "You're trying to render a component to the document using " + "server rendering but the checksum was invalid. This usually " + "means you rendered a different component type or props on " + "the client from the one on the server, or your render() " + "methods are impure. React cannot handle this case due to " + "cross-browser quirks by rendering at the document root. You " + "should look for environment dependent code in your components " + "and ensure the props are the same client and server side:\n%s", difference) : invariant(container.nodeType !== DOC_NODE_TYPE);
                            if ("production" !== process.env.NODE_ENV) {
                                "production" !== process.env.NODE_ENV ? warning(false, "React attempted to reuse markup in a container but the " + "checksum was invalid. This generally means that you are " + "using server rendering and the markup generated on the " + "server was not what the client was expecting. React injected " + "new markup to compensate which works but you have lost many " + "of the benefits of server rendering. Instead, figure out " + "why the markup being generated is different on the client " + "or server:\n%s", difference) : null;
                            }
                        }
                    }
                    "production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, "You're trying to render a component to the document but " + "you didn't use server rendering. We can't do this " + "without using server rendering due to cross-browser quirks. " + "See React.renderToString() for server rendering.") : invariant(container.nodeType !== DOC_NODE_TYPE);
                    setInnerHTML(container, markup);
                },
                getReactRootID: getReactRootID,
                getID: getID,
                setID: setID,
                getNode: getNode,
                getNodeFromInstance: getNodeFromInstance,
                purgeID: purgeID
            };
            ReactPerf.measureMethods(ReactMount, "ReactMount", {
                _renderNewRootComponent: "_renderNewRootComponent",
                _mountImageIntoNode: "_mountImageIntoNode"
            });
            module.exports = ReactMount;
        }).call(this, require("_process"));
    }, {
        "./DOMProperty": 9,
        "./ReactBrowserEventEmitter": 30,
        "./ReactCurrentOwner": 39,
        "./ReactElement": 57,
        "./ReactElementValidator": 58,
        "./ReactEmptyComponent": 59,
        "./ReactInstanceHandles": 66,
        "./ReactInstanceMap": 67,
        "./ReactMarkupChecksum": 69,
        "./ReactPerf": 75,
        "./ReactReconciler": 81,
        "./ReactUpdateQueue": 86,
        "./ReactUpdates": 87,
        "./containsNode": 109,
        "./emptyObject": 115,
        "./getReactRootElementInContainer": 129,
        "./instantiateReactComponent": 134,
        "./invariant": 135,
        "./setInnerHTML": 148,
        "./shouldUpdateReactComponent": 151,
        "./warning": 154,
        _process: 156
    } ],
    71: [ function(require, module, exports) {
        "use strict";
        var ReactComponentEnvironment = require("./ReactComponentEnvironment");
        var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");
        var ReactReconciler = require("./ReactReconciler");
        var ReactChildReconciler = require("./ReactChildReconciler");
        var updateDepth = 0;
        var updateQueue = [];
        var markupQueue = [];
        function enqueueMarkup(parentID, markup, toIndex) {
            updateQueue.push({
                parentID: parentID,
                parentNode: null,
                type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
                markupIndex: markupQueue.push(markup) - 1,
                textContent: null,
                fromIndex: null,
                toIndex: toIndex
            });
        }
        function enqueueMove(parentID, fromIndex, toIndex) {
            updateQueue.push({
                parentID: parentID,
                parentNode: null,
                type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
                markupIndex: null,
                textContent: null,
                fromIndex: fromIndex,
                toIndex: toIndex
            });
        }
        function enqueueRemove(parentID, fromIndex) {
            updateQueue.push({
                parentID: parentID,
                parentNode: null,
                type: ReactMultiChildUpdateTypes.REMOVE_NODE,
                markupIndex: null,
                textContent: null,
                fromIndex: fromIndex,
                toIndex: null
            });
        }
        function enqueueTextContent(parentID, textContent) {
            updateQueue.push({
                parentID: parentID,
                parentNode: null,
                type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
                markupIndex: null,
                textContent: textContent,
                fromIndex: null,
                toIndex: null
            });
        }
        function processQueue() {
            if (updateQueue.length) {
                ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
                clearQueue();
            }
        }
        function clearQueue() {
            updateQueue.length = 0;
            markupQueue.length = 0;
        }
        var ReactMultiChild = {
            Mixin: {
                mountChildren: function(nestedChildren, transaction, context) {
                    var children = ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
                    this._renderedChildren = children;
                    var mountImages = [];
                    var index = 0;
                    for (var name in children) {
                        if (children.hasOwnProperty(name)) {
                            var child = children[name];
                            var rootID = this._rootNodeID + name;
                            var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
                            child._mountIndex = index;
                            mountImages.push(mountImage);
                            index++;
                        }
                    }
                    return mountImages;
                },
                updateTextContent: function(nextContent) {
                    updateDepth++;
                    var errorThrown = true;
                    try {
                        var prevChildren = this._renderedChildren;
                        ReactChildReconciler.unmountChildren(prevChildren);
                        for (var name in prevChildren) {
                            if (prevChildren.hasOwnProperty(name)) {
                                this._unmountChildByName(prevChildren[name], name);
                            }
                        }
                        this.setTextContent(nextContent);
                        errorThrown = false;
                    } finally {
                        updateDepth--;
                        if (!updateDepth) {
                            if (errorThrown) {
                                clearQueue();
                            } else {
                                processQueue();
                            }
                        }
                    }
                },
                updateChildren: function(nextNestedChildren, transaction, context) {
                    updateDepth++;
                    var errorThrown = true;
                    try {
                        this._updateChildren(nextNestedChildren, transaction, context);
                        errorThrown = false;
                    } finally {
                        updateDepth--;
                        if (!updateDepth) {
                            if (errorThrown) {
                                clearQueue();
                            } else {
                                processQueue();
                            }
                        }
                    }
                },
                _updateChildren: function(nextNestedChildren, transaction, context) {
                    var prevChildren = this._renderedChildren;
                    var nextChildren = ReactChildReconciler.updateChildren(prevChildren, nextNestedChildren, transaction, context);
                    this._renderedChildren = nextChildren;
                    if (!nextChildren && !prevChildren) {
                        return;
                    }
                    var name;
                    var lastIndex = 0;
                    var nextIndex = 0;
                    for (name in nextChildren) {
                        if (!nextChildren.hasOwnProperty(name)) {
                            continue;
                        }
                        var prevChild = prevChildren && prevChildren[name];
                        var nextChild = nextChildren[name];
                        if (prevChild === nextChild) {
                            this.moveChild(prevChild, nextIndex, lastIndex);
                            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                            prevChild._mountIndex = nextIndex;
                        } else {
                            if (prevChild) {
                                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                                this._unmountChildByName(prevChild, name);
                            }
                            this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
                        }
                        nextIndex++;
                    }
                    for (name in prevChildren) {
                        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
                            this._unmountChildByName(prevChildren[name], name);
                        }
                    }
                },
                unmountChildren: function() {
                    var renderedChildren = this._renderedChildren;
                    ReactChildReconciler.unmountChildren(renderedChildren);
                    this._renderedChildren = null;
                },
                moveChild: function(child, toIndex, lastIndex) {
                    if (child._mountIndex < lastIndex) {
                        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
                    }
                },
                createChild: function(child, mountImage) {
                    enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
                },
                removeChild: function(child) {
                    enqueueRemove(this._rootNodeID, child._mountIndex);
                },
                setTextContent: function(textContent) {
                    enqueueTextContent(this._rootNodeID, textContent);
                },
                _mountChildByNameAtIndex: function(child, name, index, transaction, context) {
                    var rootID = this._rootNodeID + name;
                    var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
                    child._mountIndex = index;
                    this.createChild(child, mountImage);
                },
                _unmountChildByName: function(child, name) {
                    this.removeChild(child);
                    child._mountIndex = null;
                }
            }
        };
        module.exports = ReactMultiChild;
    }, {
        "./ReactChildReconciler": 31,
        "./ReactComponentEnvironment": 36,
        "./ReactMultiChildUpdateTypes": 72,
        "./ReactReconciler": 81
    } ],
    72: [ function(require, module, exports) {
        "use strict";
        var keyMirror = require("./keyMirror");
        var ReactMultiChildUpdateTypes = keyMirror({
            INSERT_MARKUP: null,
            MOVE_EXISTING: null,
            REMOVE_NODE: null,
            TEXT_CONTENT: null
        });
        module.exports = ReactMultiChildUpdateTypes;
    }, {
        "./keyMirror": 140
    } ],
    73: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            var autoGenerateWrapperClass = null;
            var genericComponentClass = null;
            var tagToComponentClass = {};
            var textComponentClass = null;
            var ReactNativeComponentInjection = {
                injectGenericComponentClass: function(componentClass) {
                    genericComponentClass = componentClass;
                },
                injectTextComponentClass: function(componentClass) {
                    textComponentClass = componentClass;
                },
                injectComponentClasses: function(componentClasses) {
                    assign(tagToComponentClass, componentClasses);
                },
                injectAutoWrapper: function(wrapperFactory) {
                    autoGenerateWrapperClass = wrapperFactory;
                }
            };
            function getComponentClassForElement(element) {
                if (typeof element.type === "function") {
                    return element.type;
                }
                var tag = element.type;
                var componentClass = tagToComponentClass[tag];
                if (componentClass == null) {
                    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
                }
                return componentClass;
            }
            function createInternalComponent(element) {
                "production" !== process.env.NODE_ENV ? invariant(genericComponentClass, "There is no registered component for the tag %s", element.type) : invariant(genericComponentClass);
                return new genericComponentClass(element.type, element.props);
            }
            function createInstanceForText(text) {
                return new textComponentClass(text);
            }
            function isTextComponent(component) {
                return component instanceof textComponentClass;
            }
            var ReactNativeComponent = {
                getComponentClassForElement: getComponentClassForElement,
                createInternalComponent: createInternalComponent,
                createInstanceForText: createInstanceForText,
                isTextComponent: isTextComponent,
                injection: ReactNativeComponentInjection
            };
            module.exports = ReactNativeComponent;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./invariant": 135,
        _process: 156
    } ],
    74: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            var ReactOwner = {
                isValidOwner: function(object) {
                    return !!(object && typeof object.attachRef === "function" && typeof object.detachRef === "function");
                },
                addComponentAsRefTo: function(component, ref, owner) {
                    "production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), "addComponentAsRefTo(...): Only a ReactOwner can have refs. This " + "usually means that you're trying to add a ref to a component that " + "doesn't have an owner (that is, was not created inside of another " + "component's `render` method). Try rendering this component inside of " + "a new top-level component which will hold the ref.") : invariant(ReactOwner.isValidOwner(owner));
                    owner.attachRef(ref, component);
                },
                removeComponentAsRefFrom: function(component, ref, owner) {
                    "production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), "removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This " + "usually means that you're trying to remove a ref to a component that " + "doesn't have an owner (that is, was not created inside of another " + "component's `render` method). Try rendering this component inside of " + "a new top-level component which will hold the ref.") : invariant(ReactOwner.isValidOwner(owner));
                    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
                        owner.detachRef(ref);
                    }
                }
            };
            module.exports = ReactOwner;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    75: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactPerf = {
                enableMeasure: false,
                storedMeasure: _noMeasure,
                measureMethods: function(object, objectName, methodNames) {
                    if ("production" !== process.env.NODE_ENV) {
                        for (var key in methodNames) {
                            if (!methodNames.hasOwnProperty(key)) {
                                continue;
                            }
                            object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
                        }
                    }
                },
                measure: function(objName, fnName, func) {
                    if ("production" !== process.env.NODE_ENV) {
                        var measuredFunc = null;
                        var wrapper = function() {
                            if (ReactPerf.enableMeasure) {
                                if (!measuredFunc) {
                                    measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
                                }
                                return measuredFunc.apply(this, arguments);
                            }
                            return func.apply(this, arguments);
                        };
                        wrapper.displayName = objName + "_" + fnName;
                        return wrapper;
                    }
                    return func;
                },
                injection: {
                    injectMeasure: function(measure) {
                        ReactPerf.storedMeasure = measure;
                    }
                }
            };
            function _noMeasure(objName, fnName, func) {
                return func;
            }
            module.exports = ReactPerf;
        }).call(this, require("_process"));
    }, {
        _process: 156
    } ],
    76: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactPropTypeLocationNames = {};
            if ("production" !== process.env.NODE_ENV) {
                ReactPropTypeLocationNames = {
                    prop: "prop",
                    context: "context",
                    childContext: "child context"
                };
            }
            module.exports = ReactPropTypeLocationNames;
        }).call(this, require("_process"));
    }, {
        _process: 156
    } ],
    77: [ function(require, module, exports) {
        "use strict";
        var keyMirror = require("./keyMirror");
        var ReactPropTypeLocations = keyMirror({
            prop: null,
            context: null,
            childContext: null
        });
        module.exports = ReactPropTypeLocations;
    }, {
        "./keyMirror": 140
    } ],
    78: [ function(require, module, exports) {
        "use strict";
        var ReactElement = require("./ReactElement");
        var ReactFragment = require("./ReactFragment");
        var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
        var emptyFunction = require("./emptyFunction");
        var ANONYMOUS = "<<anonymous>>";
        var elementTypeChecker = createElementTypeChecker();
        var nodeTypeChecker = createNodeChecker();
        var ReactPropTypes = {
            array: createPrimitiveTypeChecker("array"),
            bool: createPrimitiveTypeChecker("boolean"),
            func: createPrimitiveTypeChecker("function"),
            number: createPrimitiveTypeChecker("number"),
            object: createPrimitiveTypeChecker("object"),
            string: createPrimitiveTypeChecker("string"),
            any: createAnyTypeChecker(),
            arrayOf: createArrayOfTypeChecker,
            element: elementTypeChecker,
            instanceOf: createInstanceTypeChecker,
            node: nodeTypeChecker,
            objectOf: createObjectOfTypeChecker,
            oneOf: createEnumTypeChecker,
            oneOfType: createUnionTypeChecker,
            shape: createShapeTypeChecker
        };
        function createChainableTypeChecker(validate) {
            function checkType(isRequired, props, propName, componentName, location) {
                componentName = componentName || ANONYMOUS;
                if (props[propName] == null) {
                    var locationName = ReactPropTypeLocationNames[location];
                    if (isRequired) {
                        return new Error("Required " + locationName + " `" + propName + "` was not specified in " + ("`" + componentName + "`."));
                    }
                    return null;
                } else {
                    return validate(props, propName, componentName, location);
                }
            }
            var chainedCheckType = checkType.bind(null, false);
            chainedCheckType.isRequired = checkType.bind(null, true);
            return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
            function validate(props, propName, componentName, location) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== expectedType) {
                    var locationName = ReactPropTypeLocationNames[location];
                    var preciseType = getPreciseType(propValue);
                    return new Error("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` " + ("supplied to `" + componentName + "`, expected `" + expectedType + "`."));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
            return createChainableTypeChecker(emptyFunction.thatReturns(null));
        }
        function createArrayOfTypeChecker(typeChecker) {
            function validate(props, propName, componentName, location) {
                var propValue = props[propName];
                if (!Array.isArray(propValue)) {
                    var locationName = ReactPropTypeLocationNames[location];
                    var propType = getPropType(propValue);
                    return new Error("Invalid " + locationName + " `" + propName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
                }
                for (var i = 0; i < propValue.length; i++) {
                    var error = typeChecker(propValue, i, componentName, location);
                    if (error instanceof Error) {
                        return error;
                    }
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
            function validate(props, propName, componentName, location) {
                if (!ReactElement.isValidElement(props[propName])) {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected a ReactElement."));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
            function validate(props, propName, componentName, location) {
                if (!(props[propName] instanceof expectedClass)) {
                    var locationName = ReactPropTypeLocationNames[location];
                    var expectedClassName = expectedClass.name || ANONYMOUS;
                    return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected instance of `" + expectedClassName + "`."));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
            function validate(props, propName, componentName, location) {
                var propValue = props[propName];
                for (var i = 0; i < expectedValues.length; i++) {
                    if (propValue === expectedValues[i]) {
                        return null;
                    }
                }
                var locationName = ReactPropTypeLocationNames[location];
                var valuesString = JSON.stringify(expectedValues);
                return new Error("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
            }
            return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
            function validate(props, propName, componentName, location) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error("Invalid " + locationName + " `" + propName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
                }
                for (var key in propValue) {
                    if (propValue.hasOwnProperty(key)) {
                        var error = typeChecker(propValue, key, componentName, location);
                        if (error instanceof Error) {
                            return error;
                        }
                    }
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
            function validate(props, propName, componentName, location) {
                for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                    var checker = arrayOfTypeCheckers[i];
                    if (checker(props, propName, componentName, location) == null) {
                        return null;
                    }
                }
                var locationName = ReactPropTypeLocationNames[location];
                return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`."));
            }
            return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
            function validate(props, propName, componentName, location) {
                if (!isNode(props[propName])) {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }
        function createShapeTypeChecker(shapeTypes) {
            function validate(props, propName, componentName, location) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                }
                for (var key in shapeTypes) {
                    var checker = shapeTypes[key];
                    if (!checker) {
                        continue;
                    }
                    var error = checker(propValue, key, componentName, location);
                    if (error) {
                        return error;
                    }
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
            switch (typeof propValue) {
              case "number":
              case "string":
              case "undefined":
                return true;

              case "boolean":
                return !propValue;

              case "object":
                if (Array.isArray(propValue)) {
                    return propValue.every(isNode);
                }
                if (propValue === null || ReactElement.isValidElement(propValue)) {
                    return true;
                }
                propValue = ReactFragment.extractIfFragment(propValue);
                for (var k in propValue) {
                    if (!isNode(propValue[k])) {
                        return false;
                    }
                }
                return true;

              default:
                return false;
            }
        }
        function getPropType(propValue) {
            var propType = typeof propValue;
            if (Array.isArray(propValue)) {
                return "array";
            }
            if (propValue instanceof RegExp) {
                return "object";
            }
            return propType;
        }
        function getPreciseType(propValue) {
            var propType = getPropType(propValue);
            if (propType === "object") {
                if (propValue instanceof Date) {
                    return "date";
                } else if (propValue instanceof RegExp) {
                    return "regexp";
                }
            }
            return propType;
        }
        module.exports = ReactPropTypes;
    }, {
        "./ReactElement": 57,
        "./ReactFragment": 63,
        "./ReactPropTypeLocationNames": 76,
        "./emptyFunction": 114
    } ],
    79: [ function(require, module, exports) {
        "use strict";
        var PooledClass = require("./PooledClass");
        var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
        var assign = require("./Object.assign");
        function ReactPutListenerQueue() {
            this.listenersToPut = [];
        }
        assign(ReactPutListenerQueue.prototype, {
            enqueuePutListener: function(rootNodeID, propKey, propValue) {
                this.listenersToPut.push({
                    rootNodeID: rootNodeID,
                    propKey: propKey,
                    propValue: propValue
                });
            },
            putListeners: function() {
                for (var i = 0; i < this.listenersToPut.length; i++) {
                    var listenerToPut = this.listenersToPut[i];
                    ReactBrowserEventEmitter.putListener(listenerToPut.rootNodeID, listenerToPut.propKey, listenerToPut.propValue);
                }
            },
            reset: function() {
                this.listenersToPut.length = 0;
            },
            destructor: function() {
                this.reset();
            }
        });
        PooledClass.addPoolingTo(ReactPutListenerQueue);
        module.exports = ReactPutListenerQueue;
    }, {
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./ReactBrowserEventEmitter": 30
    } ],
    80: [ function(require, module, exports) {
        "use strict";
        var CallbackQueue = require("./CallbackQueue");
        var PooledClass = require("./PooledClass");
        var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
        var ReactInputSelection = require("./ReactInputSelection");
        var ReactPutListenerQueue = require("./ReactPutListenerQueue");
        var Transaction = require("./Transaction");
        var assign = require("./Object.assign");
        var SELECTION_RESTORATION = {
            initialize: ReactInputSelection.getSelectionInformation,
            close: ReactInputSelection.restoreSelection
        };
        var EVENT_SUPPRESSION = {
            initialize: function() {
                var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
                ReactBrowserEventEmitter.setEnabled(false);
                return currentlyEnabled;
            },
            close: function(previouslyEnabled) {
                ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
            }
        };
        var ON_DOM_READY_QUEUEING = {
            initialize: function() {
                this.reactMountReady.reset();
            },
            close: function() {
                this.reactMountReady.notifyAll();
            }
        };
        var PUT_LISTENER_QUEUEING = {
            initialize: function() {
                this.putListenerQueue.reset();
            },
            close: function() {
                this.putListenerQueue.putListeners();
            }
        };
        var TRANSACTION_WRAPPERS = [ PUT_LISTENER_QUEUEING, SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING ];
        function ReactReconcileTransaction() {
            this.reinitializeTransaction();
            this.renderToStaticMarkup = false;
            this.reactMountReady = CallbackQueue.getPooled(null);
            this.putListenerQueue = ReactPutListenerQueue.getPooled();
        }
        var Mixin = {
            getTransactionWrappers: function() {
                return TRANSACTION_WRAPPERS;
            },
            getReactMountReady: function() {
                return this.reactMountReady;
            },
            getPutListenerQueue: function() {
                return this.putListenerQueue;
            },
            destructor: function() {
                CallbackQueue.release(this.reactMountReady);
                this.reactMountReady = null;
                ReactPutListenerQueue.release(this.putListenerQueue);
                this.putListenerQueue = null;
            }
        };
        assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
        PooledClass.addPoolingTo(ReactReconcileTransaction);
        module.exports = ReactReconcileTransaction;
    }, {
        "./CallbackQueue": 5,
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./ReactBrowserEventEmitter": 30,
        "./ReactInputSelection": 65,
        "./ReactPutListenerQueue": 79,
        "./Transaction": 103
    } ],
    81: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactRef = require("./ReactRef");
            var ReactElementValidator = require("./ReactElementValidator");
            function attachRefs() {
                ReactRef.attachRefs(this, this._currentElement);
            }
            var ReactReconciler = {
                mountComponent: function(internalInstance, rootID, transaction, context) {
                    var markup = internalInstance.mountComponent(rootID, transaction, context);
                    if ("production" !== process.env.NODE_ENV) {
                        ReactElementValidator.checkAndWarnForMutatedProps(internalInstance._currentElement);
                    }
                    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
                    return markup;
                },
                unmountComponent: function(internalInstance) {
                    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
                    internalInstance.unmountComponent();
                },
                receiveComponent: function(internalInstance, nextElement, transaction, context) {
                    var prevElement = internalInstance._currentElement;
                    if (nextElement === prevElement && nextElement._owner != null) {
                        return;
                    }
                    if ("production" !== process.env.NODE_ENV) {
                        ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
                    }
                    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
                    if (refsChanged) {
                        ReactRef.detachRefs(internalInstance, prevElement);
                    }
                    internalInstance.receiveComponent(nextElement, transaction, context);
                    if (refsChanged) {
                        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
                    }
                },
                performUpdateIfNecessary: function(internalInstance, transaction) {
                    internalInstance.performUpdateIfNecessary(transaction);
                }
            };
            module.exports = ReactReconciler;
        }).call(this, require("_process"));
    }, {
        "./ReactElementValidator": 58,
        "./ReactRef": 82,
        _process: 156
    } ],
    82: [ function(require, module, exports) {
        "use strict";
        var ReactOwner = require("./ReactOwner");
        var ReactRef = {};
        function attachRef(ref, component, owner) {
            if (typeof ref === "function") {
                ref(component.getPublicInstance());
            } else {
                ReactOwner.addComponentAsRefTo(component, ref, owner);
            }
        }
        function detachRef(ref, component, owner) {
            if (typeof ref === "function") {
                ref(null);
            } else {
                ReactOwner.removeComponentAsRefFrom(component, ref, owner);
            }
        }
        ReactRef.attachRefs = function(instance, element) {
            var ref = element.ref;
            if (ref != null) {
                attachRef(ref, instance, element._owner);
            }
        };
        ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
            return nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref;
        };
        ReactRef.detachRefs = function(instance, element) {
            var ref = element.ref;
            if (ref != null) {
                detachRef(ref, instance, element._owner);
            }
        };
        module.exports = ReactRef;
    }, {
        "./ReactOwner": 74
    } ],
    83: [ function(require, module, exports) {
        "use strict";
        var ReactRootIndexInjection = {
            injectCreateReactRootIndex: function(_createReactRootIndex) {
                ReactRootIndex.createReactRootIndex = _createReactRootIndex;
            }
        };
        var ReactRootIndex = {
            createReactRootIndex: null,
            injection: ReactRootIndexInjection
        };
        module.exports = ReactRootIndex;
    }, {} ],
    84: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactElement = require("./ReactElement");
            var ReactInstanceHandles = require("./ReactInstanceHandles");
            var ReactMarkupChecksum = require("./ReactMarkupChecksum");
            var ReactServerRenderingTransaction = require("./ReactServerRenderingTransaction");
            var emptyObject = require("./emptyObject");
            var instantiateReactComponent = require("./instantiateReactComponent");
            var invariant = require("./invariant");
            function renderToString(element) {
                "production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), "renderToString(): You must pass a valid ReactElement.") : invariant(ReactElement.isValidElement(element));
                var transaction;
                try {
                    var id = ReactInstanceHandles.createReactRootID();
                    transaction = ReactServerRenderingTransaction.getPooled(false);
                    return transaction.perform(function() {
                        var componentInstance = instantiateReactComponent(element, null);
                        var markup = componentInstance.mountComponent(id, transaction, emptyObject);
                        return ReactMarkupChecksum.addChecksumToMarkup(markup);
                    }, null);
                } finally {
                    ReactServerRenderingTransaction.release(transaction);
                }
            }
            function renderToStaticMarkup(element) {
                "production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), "renderToStaticMarkup(): You must pass a valid ReactElement.") : invariant(ReactElement.isValidElement(element));
                var transaction;
                try {
                    var id = ReactInstanceHandles.createReactRootID();
                    transaction = ReactServerRenderingTransaction.getPooled(true);
                    return transaction.perform(function() {
                        var componentInstance = instantiateReactComponent(element, null);
                        return componentInstance.mountComponent(id, transaction, emptyObject);
                    }, null);
                } finally {
                    ReactServerRenderingTransaction.release(transaction);
                }
            }
            module.exports = {
                renderToString: renderToString,
                renderToStaticMarkup: renderToStaticMarkup
            };
        }).call(this, require("_process"));
    }, {
        "./ReactElement": 57,
        "./ReactInstanceHandles": 66,
        "./ReactMarkupChecksum": 69,
        "./ReactServerRenderingTransaction": 85,
        "./emptyObject": 115,
        "./instantiateReactComponent": 134,
        "./invariant": 135,
        _process: 156
    } ],
    85: [ function(require, module, exports) {
        "use strict";
        var PooledClass = require("./PooledClass");
        var CallbackQueue = require("./CallbackQueue");
        var ReactPutListenerQueue = require("./ReactPutListenerQueue");
        var Transaction = require("./Transaction");
        var assign = require("./Object.assign");
        var emptyFunction = require("./emptyFunction");
        var ON_DOM_READY_QUEUEING = {
            initialize: function() {
                this.reactMountReady.reset();
            },
            close: emptyFunction
        };
        var PUT_LISTENER_QUEUEING = {
            initialize: function() {
                this.putListenerQueue.reset();
            },
            close: emptyFunction
        };
        var TRANSACTION_WRAPPERS = [ PUT_LISTENER_QUEUEING, ON_DOM_READY_QUEUEING ];
        function ReactServerRenderingTransaction(renderToStaticMarkup) {
            this.reinitializeTransaction();
            this.renderToStaticMarkup = renderToStaticMarkup;
            this.reactMountReady = CallbackQueue.getPooled(null);
            this.putListenerQueue = ReactPutListenerQueue.getPooled();
        }
        var Mixin = {
            getTransactionWrappers: function() {
                return TRANSACTION_WRAPPERS;
            },
            getReactMountReady: function() {
                return this.reactMountReady;
            },
            getPutListenerQueue: function() {
                return this.putListenerQueue;
            },
            destructor: function() {
                CallbackQueue.release(this.reactMountReady);
                this.reactMountReady = null;
                ReactPutListenerQueue.release(this.putListenerQueue);
                this.putListenerQueue = null;
            }
        };
        assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
        PooledClass.addPoolingTo(ReactServerRenderingTransaction);
        module.exports = ReactServerRenderingTransaction;
    }, {
        "./CallbackQueue": 5,
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./ReactPutListenerQueue": 79,
        "./Transaction": 103,
        "./emptyFunction": 114
    } ],
    86: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactLifeCycle = require("./ReactLifeCycle");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactElement = require("./ReactElement");
            var ReactInstanceMap = require("./ReactInstanceMap");
            var ReactUpdates = require("./ReactUpdates");
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            var warning = require("./warning");
            function enqueueUpdate(internalInstance) {
                if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {
                    ReactUpdates.enqueueUpdate(internalInstance);
                }
            }
            function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
                "production" !== process.env.NODE_ENV ? invariant(ReactCurrentOwner.current == null, "%s(...): Cannot update during an existing state transition " + "(such as within `render`). Render methods should be a pure function " + "of props and state.", callerName) : invariant(ReactCurrentOwner.current == null);
                var internalInstance = ReactInstanceMap.get(publicInstance);
                if (!internalInstance) {
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(!callerName, "%s(...): Can only update a mounted or mounting component. " + "This usually means you called %s() on an unmounted " + "component. This is a no-op.", callerName, callerName) : null;
                    }
                    return null;
                }
                if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {
                    return null;
                }
                return internalInstance;
            }
            var ReactUpdateQueue = {
                enqueueCallback: function(publicInstance, callback) {
                    "production" !== process.env.NODE_ENV ? invariant(typeof callback === "function", "enqueueCallback(...): You called `setProps`, `replaceProps`, " + "`setState`, `replaceState`, or `forceUpdate` with a callback that " + "isn't callable.") : invariant(typeof callback === "function");
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
                    if (!internalInstance || internalInstance === ReactLifeCycle.currentlyMountingInstance) {
                        return null;
                    }
                    if (internalInstance._pendingCallbacks) {
                        internalInstance._pendingCallbacks.push(callback);
                    } else {
                        internalInstance._pendingCallbacks = [ callback ];
                    }
                    enqueueUpdate(internalInstance);
                },
                enqueueCallbackInternal: function(internalInstance, callback) {
                    "production" !== process.env.NODE_ENV ? invariant(typeof callback === "function", "enqueueCallback(...): You called `setProps`, `replaceProps`, " + "`setState`, `replaceState`, or `forceUpdate` with a callback that " + "isn't callable.") : invariant(typeof callback === "function");
                    if (internalInstance._pendingCallbacks) {
                        internalInstance._pendingCallbacks.push(callback);
                    } else {
                        internalInstance._pendingCallbacks = [ callback ];
                    }
                    enqueueUpdate(internalInstance);
                },
                enqueueForceUpdate: function(publicInstance) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "forceUpdate");
                    if (!internalInstance) {
                        return;
                    }
                    internalInstance._pendingForceUpdate = true;
                    enqueueUpdate(internalInstance);
                },
                enqueueReplaceState: function(publicInstance, completeState) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "replaceState");
                    if (!internalInstance) {
                        return;
                    }
                    internalInstance._pendingStateQueue = [ completeState ];
                    internalInstance._pendingReplaceState = true;
                    enqueueUpdate(internalInstance);
                },
                enqueueSetState: function(publicInstance, partialState) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "setState");
                    if (!internalInstance) {
                        return;
                    }
                    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
                    queue.push(partialState);
                    enqueueUpdate(internalInstance);
                },
                enqueueSetProps: function(publicInstance, partialProps) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "setProps");
                    if (!internalInstance) {
                        return;
                    }
                    "production" !== process.env.NODE_ENV ? invariant(internalInstance._isTopLevel, "setProps(...): You called `setProps` on a " + "component with a parent. This is an anti-pattern since props will " + "get reactively updated when rendered. Instead, change the owner's " + "`render` method to pass the correct value as props to the component " + "where it is created.") : invariant(internalInstance._isTopLevel);
                    var element = internalInstance._pendingElement || internalInstance._currentElement;
                    var props = assign({}, element.props, partialProps);
                    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);
                    enqueueUpdate(internalInstance);
                },
                enqueueReplaceProps: function(publicInstance, props) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "replaceProps");
                    if (!internalInstance) {
                        return;
                    }
                    "production" !== process.env.NODE_ENV ? invariant(internalInstance._isTopLevel, "replaceProps(...): You called `replaceProps` on a " + "component with a parent. This is an anti-pattern since props will " + "get reactively updated when rendered. Instead, change the owner's " + "`render` method to pass the correct value as props to the component " + "where it is created.") : invariant(internalInstance._isTopLevel);
                    var element = internalInstance._pendingElement || internalInstance._currentElement;
                    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);
                    enqueueUpdate(internalInstance);
                },
                enqueueElementInternal: function(internalInstance, newElement) {
                    internalInstance._pendingElement = newElement;
                    enqueueUpdate(internalInstance);
                }
            };
            module.exports = ReactUpdateQueue;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./ReactCurrentOwner": 39,
        "./ReactElement": 57,
        "./ReactInstanceMap": 67,
        "./ReactLifeCycle": 68,
        "./ReactUpdates": 87,
        "./invariant": 135,
        "./warning": 154,
        _process: 156
    } ],
    87: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var CallbackQueue = require("./CallbackQueue");
            var PooledClass = require("./PooledClass");
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactPerf = require("./ReactPerf");
            var ReactReconciler = require("./ReactReconciler");
            var Transaction = require("./Transaction");
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            var warning = require("./warning");
            var dirtyComponents = [];
            var asapCallbackQueue = CallbackQueue.getPooled();
            var asapEnqueued = false;
            var batchingStrategy = null;
            function ensureInjected() {
                "production" !== process.env.NODE_ENV ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, "ReactUpdates: must inject a reconcile transaction class and batching " + "strategy") : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy);
            }
            var NESTED_UPDATES = {
                initialize: function() {
                    this.dirtyComponentsLength = dirtyComponents.length;
                },
                close: function() {
                    if (this.dirtyComponentsLength !== dirtyComponents.length) {
                        dirtyComponents.splice(0, this.dirtyComponentsLength);
                        flushBatchedUpdates();
                    } else {
                        dirtyComponents.length = 0;
                    }
                }
            };
            var UPDATE_QUEUEING = {
                initialize: function() {
                    this.callbackQueue.reset();
                },
                close: function() {
                    this.callbackQueue.notifyAll();
                }
            };
            var TRANSACTION_WRAPPERS = [ NESTED_UPDATES, UPDATE_QUEUEING ];
            function ReactUpdatesFlushTransaction() {
                this.reinitializeTransaction();
                this.dirtyComponentsLength = null;
                this.callbackQueue = CallbackQueue.getPooled();
                this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
            }
            assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
                getTransactionWrappers: function() {
                    return TRANSACTION_WRAPPERS;
                },
                destructor: function() {
                    this.dirtyComponentsLength = null;
                    CallbackQueue.release(this.callbackQueue);
                    this.callbackQueue = null;
                    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
                    this.reconcileTransaction = null;
                },
                perform: function(method, scope, a) {
                    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
                }
            });
            PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
            function batchedUpdates(callback, a, b, c, d) {
                ensureInjected();
                batchingStrategy.batchedUpdates(callback, a, b, c, d);
            }
            function mountOrderComparator(c1, c2) {
                return c1._mountOrder - c2._mountOrder;
            }
            function runBatchedUpdates(transaction) {
                var len = transaction.dirtyComponentsLength;
                "production" !== process.env.NODE_ENV ? invariant(len === dirtyComponents.length, "Expected flush transaction's stored dirty-components length (%s) to " + "match dirty-components array length (%s).", len, dirtyComponents.length) : invariant(len === dirtyComponents.length);
                dirtyComponents.sort(mountOrderComparator);
                for (var i = 0; i < len; i++) {
                    var component = dirtyComponents[i];
                    var callbacks = component._pendingCallbacks;
                    component._pendingCallbacks = null;
                    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
                    if (callbacks) {
                        for (var j = 0; j < callbacks.length; j++) {
                            transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
                        }
                    }
                }
            }
            var flushBatchedUpdates = function() {
                while (dirtyComponents.length || asapEnqueued) {
                    if (dirtyComponents.length) {
                        var transaction = ReactUpdatesFlushTransaction.getPooled();
                        transaction.perform(runBatchedUpdates, null, transaction);
                        ReactUpdatesFlushTransaction.release(transaction);
                    }
                    if (asapEnqueued) {
                        asapEnqueued = false;
                        var queue = asapCallbackQueue;
                        asapCallbackQueue = CallbackQueue.getPooled();
                        queue.notifyAll();
                        CallbackQueue.release(queue);
                    }
                }
            };
            flushBatchedUpdates = ReactPerf.measure("ReactUpdates", "flushBatchedUpdates", flushBatchedUpdates);
            function enqueueUpdate(component) {
                ensureInjected();
                "production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, "enqueueUpdate(): Render methods should be a pure function of props " + "and state; triggering nested component updates from render is not " + "allowed. If necessary, trigger nested updates in " + "componentDidUpdate.") : null;
                if (!batchingStrategy.isBatchingUpdates) {
                    batchingStrategy.batchedUpdates(enqueueUpdate, component);
                    return;
                }
                dirtyComponents.push(component);
            }
            function asap(callback, context) {
                "production" !== process.env.NODE_ENV ? invariant(batchingStrategy.isBatchingUpdates, "ReactUpdates.asap: Can't enqueue an asap callback in a context where" + "updates are not being batched.") : invariant(batchingStrategy.isBatchingUpdates);
                asapCallbackQueue.enqueue(callback, context);
                asapEnqueued = true;
            }
            var ReactUpdatesInjection = {
                injectReconcileTransaction: function(ReconcileTransaction) {
                    "production" !== process.env.NODE_ENV ? invariant(ReconcileTransaction, "ReactUpdates: must provide a reconcile transaction class") : invariant(ReconcileTransaction);
                    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
                },
                injectBatchingStrategy: function(_batchingStrategy) {
                    "production" !== process.env.NODE_ENV ? invariant(_batchingStrategy, "ReactUpdates: must provide a batching strategy") : invariant(_batchingStrategy);
                    "production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === "function", "ReactUpdates: must provide a batchedUpdates() function") : invariant(typeof _batchingStrategy.batchedUpdates === "function");
                    "production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === "boolean", "ReactUpdates: must provide an isBatchingUpdates boolean attribute") : invariant(typeof _batchingStrategy.isBatchingUpdates === "boolean");
                    batchingStrategy = _batchingStrategy;
                }
            };
            var ReactUpdates = {
                ReactReconcileTransaction: null,
                batchedUpdates: batchedUpdates,
                enqueueUpdate: enqueueUpdate,
                flushBatchedUpdates: flushBatchedUpdates,
                injection: ReactUpdatesInjection,
                asap: asap
            };
            module.exports = ReactUpdates;
        }).call(this, require("_process"));
    }, {
        "./CallbackQueue": 5,
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./ReactCurrentOwner": 39,
        "./ReactPerf": 75,
        "./ReactReconciler": 81,
        "./Transaction": 103,
        "./invariant": 135,
        "./warning": 154,
        _process: 156
    } ],
    88: [ function(require, module, exports) {
        "use strict";
        var DOMProperty = require("./DOMProperty");
        var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
        var SVGDOMPropertyConfig = {
            Properties: {
                clipPath: MUST_USE_ATTRIBUTE,
                cx: MUST_USE_ATTRIBUTE,
                cy: MUST_USE_ATTRIBUTE,
                d: MUST_USE_ATTRIBUTE,
                dx: MUST_USE_ATTRIBUTE,
                dy: MUST_USE_ATTRIBUTE,
                fill: MUST_USE_ATTRIBUTE,
                fillOpacity: MUST_USE_ATTRIBUTE,
                fontFamily: MUST_USE_ATTRIBUTE,
                fontSize: MUST_USE_ATTRIBUTE,
                fx: MUST_USE_ATTRIBUTE,
                fy: MUST_USE_ATTRIBUTE,
                gradientTransform: MUST_USE_ATTRIBUTE,
                gradientUnits: MUST_USE_ATTRIBUTE,
                markerEnd: MUST_USE_ATTRIBUTE,
                markerMid: MUST_USE_ATTRIBUTE,
                markerStart: MUST_USE_ATTRIBUTE,
                offset: MUST_USE_ATTRIBUTE,
                opacity: MUST_USE_ATTRIBUTE,
                patternContentUnits: MUST_USE_ATTRIBUTE,
                patternUnits: MUST_USE_ATTRIBUTE,
                points: MUST_USE_ATTRIBUTE,
                preserveAspectRatio: MUST_USE_ATTRIBUTE,
                r: MUST_USE_ATTRIBUTE,
                rx: MUST_USE_ATTRIBUTE,
                ry: MUST_USE_ATTRIBUTE,
                spreadMethod: MUST_USE_ATTRIBUTE,
                stopColor: MUST_USE_ATTRIBUTE,
                stopOpacity: MUST_USE_ATTRIBUTE,
                stroke: MUST_USE_ATTRIBUTE,
                strokeDasharray: MUST_USE_ATTRIBUTE,
                strokeLinecap: MUST_USE_ATTRIBUTE,
                strokeOpacity: MUST_USE_ATTRIBUTE,
                strokeWidth: MUST_USE_ATTRIBUTE,
                textAnchor: MUST_USE_ATTRIBUTE,
                transform: MUST_USE_ATTRIBUTE,
                version: MUST_USE_ATTRIBUTE,
                viewBox: MUST_USE_ATTRIBUTE,
                x1: MUST_USE_ATTRIBUTE,
                x2: MUST_USE_ATTRIBUTE,
                x: MUST_USE_ATTRIBUTE,
                y1: MUST_USE_ATTRIBUTE,
                y2: MUST_USE_ATTRIBUTE,
                y: MUST_USE_ATTRIBUTE
            },
            DOMAttributeNames: {
                clipPath: "clip-path",
                fillOpacity: "fill-opacity",
                fontFamily: "font-family",
                fontSize: "font-size",
                gradientTransform: "gradientTransform",
                gradientUnits: "gradientUnits",
                markerEnd: "marker-end",
                markerMid: "marker-mid",
                markerStart: "marker-start",
                patternContentUnits: "patternContentUnits",
                patternUnits: "patternUnits",
                preserveAspectRatio: "preserveAspectRatio",
                spreadMethod: "spreadMethod",
                stopColor: "stop-color",
                stopOpacity: "stop-opacity",
                strokeDasharray: "stroke-dasharray",
                strokeLinecap: "stroke-linecap",
                strokeOpacity: "stroke-opacity",
                strokeWidth: "stroke-width",
                textAnchor: "text-anchor",
                viewBox: "viewBox"
            }
        };
        module.exports = SVGDOMPropertyConfig;
    }, {
        "./DOMProperty": 9
    } ],
    89: [ function(require, module, exports) {
        "use strict";
        var EventConstants = require("./EventConstants");
        var EventPropagators = require("./EventPropagators");
        var ReactInputSelection = require("./ReactInputSelection");
        var SyntheticEvent = require("./SyntheticEvent");
        var getActiveElement = require("./getActiveElement");
        var isTextInputElement = require("./isTextInputElement");
        var keyOf = require("./keyOf");
        var shallowEqual = require("./shallowEqual");
        var topLevelTypes = EventConstants.topLevelTypes;
        var eventTypes = {
            select: {
                phasedRegistrationNames: {
                    bubbled: keyOf({
                        onSelect: null
                    }),
                    captured: keyOf({
                        onSelectCapture: null
                    })
                },
                dependencies: [ topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange ]
            }
        };
        var activeElement = null;
        var activeElementID = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection(node) {
            if ("selectionStart" in node && ReactInputSelection.hasSelectionCapabilities(node)) {
                return {
                    start: node.selectionStart,
                    end: node.selectionEnd
                };
            } else if (window.getSelection) {
                var selection = window.getSelection();
                return {
                    anchorNode: selection.anchorNode,
                    anchorOffset: selection.anchorOffset,
                    focusNode: selection.focusNode,
                    focusOffset: selection.focusOffset
                };
            } else if (document.selection) {
                var range = document.selection.createRange();
                return {
                    parentElement: range.parentElement(),
                    text: range.text,
                    top: range.boundingTop,
                    left: range.boundingLeft
                };
            }
        }
        function constructSelectEvent(nativeEvent) {
            if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
                return null;
            }
            var currentSelection = getSelection(activeElement);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
                lastSelection = currentSelection;
                var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);
                syntheticEvent.type = "select";
                syntheticEvent.target = activeElement;
                EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
                return syntheticEvent;
            }
        }
        var SelectEventPlugin = {
            eventTypes: eventTypes,
            extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                switch (topLevelType) {
                  case topLevelTypes.topFocus:
                    if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === "true") {
                        activeElement = topLevelTarget;
                        activeElementID = topLevelTargetID;
                        lastSelection = null;
                    }
                    break;

                  case topLevelTypes.topBlur:
                    activeElement = null;
                    activeElementID = null;
                    lastSelection = null;
                    break;

                  case topLevelTypes.topMouseDown:
                    mouseDown = true;
                    break;

                  case topLevelTypes.topContextMenu:
                  case topLevelTypes.topMouseUp:
                    mouseDown = false;
                    return constructSelectEvent(nativeEvent);

                  case topLevelTypes.topSelectionChange:
                  case topLevelTypes.topKeyDown:
                  case topLevelTypes.topKeyUp:
                    return constructSelectEvent(nativeEvent);
                }
            }
        };
        module.exports = SelectEventPlugin;
    }, {
        "./EventConstants": 14,
        "./EventPropagators": 19,
        "./ReactInputSelection": 65,
        "./SyntheticEvent": 95,
        "./getActiveElement": 121,
        "./isTextInputElement": 138,
        "./keyOf": 141,
        "./shallowEqual": 150
    } ],
    90: [ function(require, module, exports) {
        "use strict";
        var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
        var ServerReactRootIndex = {
            createReactRootIndex: function() {
                return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
            }
        };
        module.exports = ServerReactRootIndex;
    }, {} ],
    91: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var EventConstants = require("./EventConstants");
            var EventPluginUtils = require("./EventPluginUtils");
            var EventPropagators = require("./EventPropagators");
            var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
            var SyntheticEvent = require("./SyntheticEvent");
            var SyntheticFocusEvent = require("./SyntheticFocusEvent");
            var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
            var SyntheticMouseEvent = require("./SyntheticMouseEvent");
            var SyntheticDragEvent = require("./SyntheticDragEvent");
            var SyntheticTouchEvent = require("./SyntheticTouchEvent");
            var SyntheticUIEvent = require("./SyntheticUIEvent");
            var SyntheticWheelEvent = require("./SyntheticWheelEvent");
            var getEventCharCode = require("./getEventCharCode");
            var invariant = require("./invariant");
            var keyOf = require("./keyOf");
            var warning = require("./warning");
            var topLevelTypes = EventConstants.topLevelTypes;
            var eventTypes = {
                blur: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onBlur: true
                        }),
                        captured: keyOf({
                            onBlurCapture: true
                        })
                    }
                },
                click: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onClick: true
                        }),
                        captured: keyOf({
                            onClickCapture: true
                        })
                    }
                },
                contextMenu: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onContextMenu: true
                        }),
                        captured: keyOf({
                            onContextMenuCapture: true
                        })
                    }
                },
                copy: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onCopy: true
                        }),
                        captured: keyOf({
                            onCopyCapture: true
                        })
                    }
                },
                cut: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onCut: true
                        }),
                        captured: keyOf({
                            onCutCapture: true
                        })
                    }
                },
                doubleClick: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDoubleClick: true
                        }),
                        captured: keyOf({
                            onDoubleClickCapture: true
                        })
                    }
                },
                drag: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDrag: true
                        }),
                        captured: keyOf({
                            onDragCapture: true
                        })
                    }
                },
                dragEnd: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDragEnd: true
                        }),
                        captured: keyOf({
                            onDragEndCapture: true
                        })
                    }
                },
                dragEnter: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDragEnter: true
                        }),
                        captured: keyOf({
                            onDragEnterCapture: true
                        })
                    }
                },
                dragExit: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDragExit: true
                        }),
                        captured: keyOf({
                            onDragExitCapture: true
                        })
                    }
                },
                dragLeave: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDragLeave: true
                        }),
                        captured: keyOf({
                            onDragLeaveCapture: true
                        })
                    }
                },
                dragOver: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDragOver: true
                        }),
                        captured: keyOf({
                            onDragOverCapture: true
                        })
                    }
                },
                dragStart: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDragStart: true
                        }),
                        captured: keyOf({
                            onDragStartCapture: true
                        })
                    }
                },
                drop: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onDrop: true
                        }),
                        captured: keyOf({
                            onDropCapture: true
                        })
                    }
                },
                focus: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onFocus: true
                        }),
                        captured: keyOf({
                            onFocusCapture: true
                        })
                    }
                },
                input: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onInput: true
                        }),
                        captured: keyOf({
                            onInputCapture: true
                        })
                    }
                },
                keyDown: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onKeyDown: true
                        }),
                        captured: keyOf({
                            onKeyDownCapture: true
                        })
                    }
                },
                keyPress: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onKeyPress: true
                        }),
                        captured: keyOf({
                            onKeyPressCapture: true
                        })
                    }
                },
                keyUp: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onKeyUp: true
                        }),
                        captured: keyOf({
                            onKeyUpCapture: true
                        })
                    }
                },
                load: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onLoad: true
                        }),
                        captured: keyOf({
                            onLoadCapture: true
                        })
                    }
                },
                error: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onError: true
                        }),
                        captured: keyOf({
                            onErrorCapture: true
                        })
                    }
                },
                mouseDown: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onMouseDown: true
                        }),
                        captured: keyOf({
                            onMouseDownCapture: true
                        })
                    }
                },
                mouseMove: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onMouseMove: true
                        }),
                        captured: keyOf({
                            onMouseMoveCapture: true
                        })
                    }
                },
                mouseOut: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onMouseOut: true
                        }),
                        captured: keyOf({
                            onMouseOutCapture: true
                        })
                    }
                },
                mouseOver: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onMouseOver: true
                        }),
                        captured: keyOf({
                            onMouseOverCapture: true
                        })
                    }
                },
                mouseUp: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onMouseUp: true
                        }),
                        captured: keyOf({
                            onMouseUpCapture: true
                        })
                    }
                },
                paste: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onPaste: true
                        }),
                        captured: keyOf({
                            onPasteCapture: true
                        })
                    }
                },
                reset: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onReset: true
                        }),
                        captured: keyOf({
                            onResetCapture: true
                        })
                    }
                },
                scroll: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onScroll: true
                        }),
                        captured: keyOf({
                            onScrollCapture: true
                        })
                    }
                },
                submit: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onSubmit: true
                        }),
                        captured: keyOf({
                            onSubmitCapture: true
                        })
                    }
                },
                touchCancel: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onTouchCancel: true
                        }),
                        captured: keyOf({
                            onTouchCancelCapture: true
                        })
                    }
                },
                touchEnd: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onTouchEnd: true
                        }),
                        captured: keyOf({
                            onTouchEndCapture: true
                        })
                    }
                },
                touchMove: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onTouchMove: true
                        }),
                        captured: keyOf({
                            onTouchMoveCapture: true
                        })
                    }
                },
                touchStart: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onTouchStart: true
                        }),
                        captured: keyOf({
                            onTouchStartCapture: true
                        })
                    }
                },
                wheel: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({
                            onWheel: true
                        }),
                        captured: keyOf({
                            onWheelCapture: true
                        })
                    }
                }
            };
            var topLevelEventsToDispatchConfig = {
                topBlur: eventTypes.blur,
                topClick: eventTypes.click,
                topContextMenu: eventTypes.contextMenu,
                topCopy: eventTypes.copy,
                topCut: eventTypes.cut,
                topDoubleClick: eventTypes.doubleClick,
                topDrag: eventTypes.drag,
                topDragEnd: eventTypes.dragEnd,
                topDragEnter: eventTypes.dragEnter,
                topDragExit: eventTypes.dragExit,
                topDragLeave: eventTypes.dragLeave,
                topDragOver: eventTypes.dragOver,
                topDragStart: eventTypes.dragStart,
                topDrop: eventTypes.drop,
                topError: eventTypes.error,
                topFocus: eventTypes.focus,
                topInput: eventTypes.input,
                topKeyDown: eventTypes.keyDown,
                topKeyPress: eventTypes.keyPress,
                topKeyUp: eventTypes.keyUp,
                topLoad: eventTypes.load,
                topMouseDown: eventTypes.mouseDown,
                topMouseMove: eventTypes.mouseMove,
                topMouseOut: eventTypes.mouseOut,
                topMouseOver: eventTypes.mouseOver,
                topMouseUp: eventTypes.mouseUp,
                topPaste: eventTypes.paste,
                topReset: eventTypes.reset,
                topScroll: eventTypes.scroll,
                topSubmit: eventTypes.submit,
                topTouchCancel: eventTypes.touchCancel,
                topTouchEnd: eventTypes.touchEnd,
                topTouchMove: eventTypes.touchMove,
                topTouchStart: eventTypes.touchStart,
                topWheel: eventTypes.wheel
            };
            for (var type in topLevelEventsToDispatchConfig) {
                topLevelEventsToDispatchConfig[type].dependencies = [ type ];
            }
            var SimpleEventPlugin = {
                eventTypes: eventTypes,
                executeDispatch: function(event, listener, domID) {
                    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
                    "production" !== process.env.NODE_ENV ? warning(typeof returnValue !== "boolean", "Returning `false` from an event handler is deprecated and will be " + "ignored in a future release. Instead, manually call " + "e.stopPropagation() or e.preventDefault(), as appropriate.") : null;
                    if (returnValue === false) {
                        event.stopPropagation();
                        event.preventDefault();
                    }
                },
                extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
                    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
                    if (!dispatchConfig) {
                        return null;
                    }
                    var EventConstructor;
                    switch (topLevelType) {
                      case topLevelTypes.topInput:
                      case topLevelTypes.topLoad:
                      case topLevelTypes.topError:
                      case topLevelTypes.topReset:
                      case topLevelTypes.topSubmit:
                        EventConstructor = SyntheticEvent;
                        break;

                      case topLevelTypes.topKeyPress:
                        if (getEventCharCode(nativeEvent) === 0) {
                            return null;
                        }

                      case topLevelTypes.topKeyDown:
                      case topLevelTypes.topKeyUp:
                        EventConstructor = SyntheticKeyboardEvent;
                        break;

                      case topLevelTypes.topBlur:
                      case topLevelTypes.topFocus:
                        EventConstructor = SyntheticFocusEvent;
                        break;

                      case topLevelTypes.topClick:
                        if (nativeEvent.button === 2) {
                            return null;
                        }

                      case topLevelTypes.topContextMenu:
                      case topLevelTypes.topDoubleClick:
                      case topLevelTypes.topMouseDown:
                      case topLevelTypes.topMouseMove:
                      case topLevelTypes.topMouseOut:
                      case topLevelTypes.topMouseOver:
                      case topLevelTypes.topMouseUp:
                        EventConstructor = SyntheticMouseEvent;
                        break;

                      case topLevelTypes.topDrag:
                      case topLevelTypes.topDragEnd:
                      case topLevelTypes.topDragEnter:
                      case topLevelTypes.topDragExit:
                      case topLevelTypes.topDragLeave:
                      case topLevelTypes.topDragOver:
                      case topLevelTypes.topDragStart:
                      case topLevelTypes.topDrop:
                        EventConstructor = SyntheticDragEvent;
                        break;

                      case topLevelTypes.topTouchCancel:
                      case topLevelTypes.topTouchEnd:
                      case topLevelTypes.topTouchMove:
                      case topLevelTypes.topTouchStart:
                        EventConstructor = SyntheticTouchEvent;
                        break;

                      case topLevelTypes.topScroll:
                        EventConstructor = SyntheticUIEvent;
                        break;

                      case topLevelTypes.topWheel:
                        EventConstructor = SyntheticWheelEvent;
                        break;

                      case topLevelTypes.topCopy:
                      case topLevelTypes.topCut:
                      case topLevelTypes.topPaste:
                        EventConstructor = SyntheticClipboardEvent;
                        break;
                    }
                    "production" !== process.env.NODE_ENV ? invariant(EventConstructor, "SimpleEventPlugin: Unhandled event type, `%s`.", topLevelType) : invariant(EventConstructor);
                    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
                    EventPropagators.accumulateTwoPhaseDispatches(event);
                    return event;
                }
            };
            module.exports = SimpleEventPlugin;
        }).call(this, require("_process"));
    }, {
        "./EventConstants": 14,
        "./EventPluginUtils": 18,
        "./EventPropagators": 19,
        "./SyntheticClipboardEvent": 92,
        "./SyntheticDragEvent": 94,
        "./SyntheticEvent": 95,
        "./SyntheticFocusEvent": 96,
        "./SyntheticKeyboardEvent": 98,
        "./SyntheticMouseEvent": 99,
        "./SyntheticTouchEvent": 100,
        "./SyntheticUIEvent": 101,
        "./SyntheticWheelEvent": 102,
        "./getEventCharCode": 122,
        "./invariant": 135,
        "./keyOf": 141,
        "./warning": 154,
        _process: 156
    } ],
    92: [ function(require, module, exports) {
        "use strict";
        var SyntheticEvent = require("./SyntheticEvent");
        var ClipboardEventInterface = {
            clipboardData: function(event) {
                return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
        };
        function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
        module.exports = SyntheticClipboardEvent;
    }, {
        "./SyntheticEvent": 95
    } ],
    93: [ function(require, module, exports) {
        "use strict";
        var SyntheticEvent = require("./SyntheticEvent");
        var CompositionEventInterface = {
            data: null
        };
        function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
        module.exports = SyntheticCompositionEvent;
    }, {
        "./SyntheticEvent": 95
    } ],
    94: [ function(require, module, exports) {
        "use strict";
        var SyntheticMouseEvent = require("./SyntheticMouseEvent");
        var DragEventInterface = {
            dataTransfer: null
        };
        function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
        module.exports = SyntheticDragEvent;
    }, {
        "./SyntheticMouseEvent": 99
    } ],
    95: [ function(require, module, exports) {
        "use strict";
        var PooledClass = require("./PooledClass");
        var assign = require("./Object.assign");
        var emptyFunction = require("./emptyFunction");
        var getEventTarget = require("./getEventTarget");
        var EventInterface = {
            type: null,
            target: getEventTarget,
            currentTarget: emptyFunction.thatReturnsNull,
            eventPhase: null,
            bubbles: null,
            cancelable: null,
            timeStamp: function(event) {
                return event.timeStamp || Date.now();
            },
            defaultPrevented: null,
            isTrusted: null
        };
        function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            this.dispatchConfig = dispatchConfig;
            this.dispatchMarker = dispatchMarker;
            this.nativeEvent = nativeEvent;
            var Interface = this.constructor.Interface;
            for (var propName in Interface) {
                if (!Interface.hasOwnProperty(propName)) {
                    continue;
                }
                var normalize = Interface[propName];
                if (normalize) {
                    this[propName] = normalize(nativeEvent);
                } else {
                    this[propName] = nativeEvent[propName];
                }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
                this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
            } else {
                this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
            }
            this.isPropagationStopped = emptyFunction.thatReturnsFalse;
        }
        assign(SyntheticEvent.prototype, {
            preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (event.preventDefault) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                }
                this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
            },
            stopPropagation: function() {
                var event = this.nativeEvent;
                if (event.stopPropagation) {
                    event.stopPropagation();
                } else {
                    event.cancelBubble = true;
                }
                this.isPropagationStopped = emptyFunction.thatReturnsTrue;
            },
            persist: function() {
                this.isPersistent = emptyFunction.thatReturnsTrue;
            },
            isPersistent: emptyFunction.thatReturnsFalse,
            destructor: function() {
                var Interface = this.constructor.Interface;
                for (var propName in Interface) {
                    this[propName] = null;
                }
                this.dispatchConfig = null;
                this.dispatchMarker = null;
                this.nativeEvent = null;
            }
        });
        SyntheticEvent.Interface = EventInterface;
        SyntheticEvent.augmentClass = function(Class, Interface) {
            var Super = this;
            var prototype = Object.create(Super.prototype);
            assign(prototype, Class.prototype);
            Class.prototype = prototype;
            Class.prototype.constructor = Class;
            Class.Interface = assign({}, Super.Interface, Interface);
            Class.augmentClass = Super.augmentClass;
            PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
        };
        PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
        module.exports = SyntheticEvent;
    }, {
        "./Object.assign": 26,
        "./PooledClass": 27,
        "./emptyFunction": 114,
        "./getEventTarget": 125
    } ],
    96: [ function(require, module, exports) {
        "use strict";
        var SyntheticUIEvent = require("./SyntheticUIEvent");
        var FocusEventInterface = {
            relatedTarget: null
        };
        function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
        module.exports = SyntheticFocusEvent;
    }, {
        "./SyntheticUIEvent": 101
    } ],
    97: [ function(require, module, exports) {
        "use strict";
        var SyntheticEvent = require("./SyntheticEvent");
        var InputEventInterface = {
            data: null
        };
        function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
        module.exports = SyntheticInputEvent;
    }, {
        "./SyntheticEvent": 95
    } ],
    98: [ function(require, module, exports) {
        "use strict";
        var SyntheticUIEvent = require("./SyntheticUIEvent");
        var getEventCharCode = require("./getEventCharCode");
        var getEventKey = require("./getEventKey");
        var getEventModifierState = require("./getEventModifierState");
        var KeyboardEventInterface = {
            key: getEventKey,
            location: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            repeat: null,
            locale: null,
            getModifierState: getEventModifierState,
            charCode: function(event) {
                if (event.type === "keypress") {
                    return getEventCharCode(event);
                }
                return 0;
            },
            keyCode: function(event) {
                if (event.type === "keydown" || event.type === "keyup") {
                    return event.keyCode;
                }
                return 0;
            },
            which: function(event) {
                if (event.type === "keypress") {
                    return getEventCharCode(event);
                }
                if (event.type === "keydown" || event.type === "keyup") {
                    return event.keyCode;
                }
                return 0;
            }
        };
        function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
        module.exports = SyntheticKeyboardEvent;
    }, {
        "./SyntheticUIEvent": 101,
        "./getEventCharCode": 122,
        "./getEventKey": 123,
        "./getEventModifierState": 124
    } ],
    99: [ function(require, module, exports) {
        "use strict";
        var SyntheticUIEvent = require("./SyntheticUIEvent");
        var ViewportMetrics = require("./ViewportMetrics");
        var getEventModifierState = require("./getEventModifierState");
        var MouseEventInterface = {
            screenX: null,
            screenY: null,
            clientX: null,
            clientY: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            getModifierState: getEventModifierState,
            button: function(event) {
                var button = event.button;
                if ("which" in event) {
                    return button;
                }
                return button === 2 ? 2 : button === 4 ? 1 : 0;
            },
            buttons: null,
            relatedTarget: function(event) {
                return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
            },
            pageX: function(event) {
                return "pageX" in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
            },
            pageY: function(event) {
                return "pageY" in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
            }
        };
        function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
        module.exports = SyntheticMouseEvent;
    }, {
        "./SyntheticUIEvent": 101,
        "./ViewportMetrics": 104,
        "./getEventModifierState": 124
    } ],
    100: [ function(require, module, exports) {
        "use strict";
        var SyntheticUIEvent = require("./SyntheticUIEvent");
        var getEventModifierState = require("./getEventModifierState");
        var TouchEventInterface = {
            touches: null,
            targetTouches: null,
            changedTouches: null,
            altKey: null,
            metaKey: null,
            ctrlKey: null,
            shiftKey: null,
            getModifierState: getEventModifierState
        };
        function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
        module.exports = SyntheticTouchEvent;
    }, {
        "./SyntheticUIEvent": 101,
        "./getEventModifierState": 124
    } ],
    101: [ function(require, module, exports) {
        "use strict";
        var SyntheticEvent = require("./SyntheticEvent");
        var getEventTarget = require("./getEventTarget");
        var UIEventInterface = {
            view: function(event) {
                if (event.view) {
                    return event.view;
                }
                var target = getEventTarget(event);
                if (target != null && target.window === target) {
                    return target;
                }
                var doc = target.ownerDocument;
                if (doc) {
                    return doc.defaultView || doc.parentWindow;
                } else {
                    return window;
                }
            },
            detail: function(event) {
                return event.detail || 0;
            }
        };
        function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
        module.exports = SyntheticUIEvent;
    }, {
        "./SyntheticEvent": 95,
        "./getEventTarget": 125
    } ],
    102: [ function(require, module, exports) {
        "use strict";
        var SyntheticMouseEvent = require("./SyntheticMouseEvent");
        var WheelEventInterface = {
            deltaX: function(event) {
                return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
                return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: null,
            deltaMode: null
        };
        function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
            SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
        }
        SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
        module.exports = SyntheticWheelEvent;
    }, {
        "./SyntheticMouseEvent": 99
    } ],
    103: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            var Mixin = {
                reinitializeTransaction: function() {
                    this.transactionWrappers = this.getTransactionWrappers();
                    if (!this.wrapperInitData) {
                        this.wrapperInitData = [];
                    } else {
                        this.wrapperInitData.length = 0;
                    }
                    this._isInTransaction = false;
                },
                _isInTransaction: false,
                getTransactionWrappers: null,
                isInTransaction: function() {
                    return !!this._isInTransaction;
                },
                perform: function(method, scope, a, b, c, d, e, f) {
                    "production" !== process.env.NODE_ENV ? invariant(!this.isInTransaction(), "Transaction.perform(...): Cannot initialize a transaction when there " + "is already an outstanding transaction.") : invariant(!this.isInTransaction());
                    var errorThrown;
                    var ret;
                    try {
                        this._isInTransaction = true;
                        errorThrown = true;
                        this.initializeAll(0);
                        ret = method.call(scope, a, b, c, d, e, f);
                        errorThrown = false;
                    } finally {
                        try {
                            if (errorThrown) {
                                try {
                                    this.closeAll(0);
                                } catch (err) {}
                            } else {
                                this.closeAll(0);
                            }
                        } finally {
                            this._isInTransaction = false;
                        }
                    }
                    return ret;
                },
                initializeAll: function(startIndex) {
                    var transactionWrappers = this.transactionWrappers;
                    for (var i = startIndex; i < transactionWrappers.length; i++) {
                        var wrapper = transactionWrappers[i];
                        try {
                            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
                            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
                        } finally {
                            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
                                try {
                                    this.initializeAll(i + 1);
                                } catch (err) {}
                            }
                        }
                    }
                },
                closeAll: function(startIndex) {
                    "production" !== process.env.NODE_ENV ? invariant(this.isInTransaction(), "Transaction.closeAll(): Cannot close transaction when none are open.") : invariant(this.isInTransaction());
                    var transactionWrappers = this.transactionWrappers;
                    for (var i = startIndex; i < transactionWrappers.length; i++) {
                        var wrapper = transactionWrappers[i];
                        var initData = this.wrapperInitData[i];
                        var errorThrown;
                        try {
                            errorThrown = true;
                            if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
                                wrapper.close.call(this, initData);
                            }
                            errorThrown = false;
                        } finally {
                            if (errorThrown) {
                                try {
                                    this.closeAll(i + 1);
                                } catch (e) {}
                            }
                        }
                    }
                    this.wrapperInitData.length = 0;
                }
            };
            var Transaction = {
                Mixin: Mixin,
                OBSERVED_ERROR: {}
            };
            module.exports = Transaction;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    104: [ function(require, module, exports) {
        "use strict";
        var ViewportMetrics = {
            currentScrollLeft: 0,
            currentScrollTop: 0,
            refreshScrollValues: function(scrollPosition) {
                ViewportMetrics.currentScrollLeft = scrollPosition.x;
                ViewportMetrics.currentScrollTop = scrollPosition.y;
            }
        };
        module.exports = ViewportMetrics;
    }, {} ],
    105: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            function accumulateInto(current, next) {
                "production" !== process.env.NODE_ENV ? invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.") : invariant(next != null);
                if (current == null) {
                    return next;
                }
                var currentIsArray = Array.isArray(current);
                var nextIsArray = Array.isArray(next);
                if (currentIsArray && nextIsArray) {
                    current.push.apply(current, next);
                    return current;
                }
                if (currentIsArray) {
                    current.push(next);
                    return current;
                }
                if (nextIsArray) {
                    return [ current ].concat(next);
                }
                return [ current, next ];
            }
            module.exports = accumulateInto;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    106: [ function(require, module, exports) {
        "use strict";
        var MOD = 65521;
        function adler32(data) {
            var a = 1;
            var b = 0;
            for (var i = 0; i < data.length; i++) {
                a = (a + data.charCodeAt(i)) % MOD;
                b = (b + a) % MOD;
            }
            return a | b << 16;
        }
        module.exports = adler32;
    }, {} ],
    107: [ function(require, module, exports) {
        var _hyphenPattern = /-(.)/g;
        function camelize(string) {
            return string.replace(_hyphenPattern, function(_, character) {
                return character.toUpperCase();
            });
        }
        module.exports = camelize;
    }, {} ],
    108: [ function(require, module, exports) {
        "use strict";
        var camelize = require("./camelize");
        var msPattern = /^-ms-/;
        function camelizeStyleName(string) {
            return camelize(string.replace(msPattern, "ms-"));
        }
        module.exports = camelizeStyleName;
    }, {
        "./camelize": 107
    } ],
    109: [ function(require, module, exports) {
        var isTextNode = require("./isTextNode");
        function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
                return false;
            } else if (outerNode === innerNode) {
                return true;
            } else if (isTextNode(outerNode)) {
                return false;
            } else if (isTextNode(innerNode)) {
                return containsNode(outerNode, innerNode.parentNode);
            } else if (outerNode.contains) {
                return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
                return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
                return false;
            }
        }
        module.exports = containsNode;
    }, {
        "./isTextNode": 139
    } ],
    110: [ function(require, module, exports) {
        var toArray = require("./toArray");
        function hasArrayNature(obj) {
            return !!obj && (typeof obj == "object" || typeof obj == "function") && "length" in obj && !("setInterval" in obj) && typeof obj.nodeType != "number" && (Array.isArray(obj) || "callee" in obj || "item" in obj);
        }
        function createArrayFromMixed(obj) {
            if (!hasArrayNature(obj)) {
                return [ obj ];
            } else if (Array.isArray(obj)) {
                return obj.slice();
            } else {
                return toArray(obj);
            }
        }
        module.exports = createArrayFromMixed;
    }, {
        "./toArray": 152
    } ],
    111: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactClass = require("./ReactClass");
            var ReactElement = require("./ReactElement");
            var invariant = require("./invariant");
            function createFullPageComponent(tag) {
                var elementFactory = ReactElement.createFactory(tag);
                var FullPageComponent = ReactClass.createClass({
                    tagName: tag.toUpperCase(),
                    displayName: "ReactFullPageComponent" + tag,
                    componentWillUnmount: function() {
                        "production" !== process.env.NODE_ENV ? invariant(false, "%s tried to unmount. Because of cross-browser quirks it is " + "impossible to unmount some top-level components (eg <html>, <head>, " + "and <body>) reliably and efficiently. To fix this, have a single " + "top-level component that never unmounts render these elements.", this.constructor.displayName) : invariant(false);
                    },
                    render: function() {
                        return elementFactory(this.props);
                    }
                });
                return FullPageComponent;
            }
            module.exports = createFullPageComponent;
        }).call(this, require("_process"));
    }, {
        "./ReactClass": 33,
        "./ReactElement": 57,
        "./invariant": 135,
        _process: 156
    } ],
    112: [ function(require, module, exports) {
        (function(process) {
            var ExecutionEnvironment = require("./ExecutionEnvironment");
            var createArrayFromMixed = require("./createArrayFromMixed");
            var getMarkupWrap = require("./getMarkupWrap");
            var invariant = require("./invariant");
            var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null;
            var nodeNamePattern = /^\s*<(\w+)/;
            function getNodeName(markup) {
                var nodeNameMatch = markup.match(nodeNamePattern);
                return nodeNameMatch && nodeNameMatch[1].toLowerCase();
            }
            function createNodesFromMarkup(markup, handleScript) {
                var node = dummyNode;
                "production" !== process.env.NODE_ENV ? invariant(!!dummyNode, "createNodesFromMarkup dummy not initialized") : invariant(!!dummyNode);
                var nodeName = getNodeName(markup);
                var wrap = nodeName && getMarkupWrap(nodeName);
                if (wrap) {
                    node.innerHTML = wrap[1] + markup + wrap[2];
                    var wrapDepth = wrap[0];
                    while (wrapDepth--) {
                        node = node.lastChild;
                    }
                } else {
                    node.innerHTML = markup;
                }
                var scripts = node.getElementsByTagName("script");
                if (scripts.length) {
                    "production" !== process.env.NODE_ENV ? invariant(handleScript, "createNodesFromMarkup(...): Unexpected <script> element rendered.") : invariant(handleScript);
                    createArrayFromMixed(scripts).forEach(handleScript);
                }
                var nodes = createArrayFromMixed(node.childNodes);
                while (node.lastChild) {
                    node.removeChild(node.lastChild);
                }
                return nodes;
            }
            module.exports = createNodesFromMarkup;
        }).call(this, require("_process"));
    }, {
        "./ExecutionEnvironment": 20,
        "./createArrayFromMixed": 110,
        "./getMarkupWrap": 127,
        "./invariant": 135,
        _process: 156
    } ],
    113: [ function(require, module, exports) {
        "use strict";
        var CSSProperty = require("./CSSProperty");
        var isUnitlessNumber = CSSProperty.isUnitlessNumber;
        function dangerousStyleValue(name, value) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
                return "";
            }
            var isNonNumeric = isNaN(value);
            if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
                return "" + value;
            }
            if (typeof value === "string") {
                value = value.trim();
            }
            return value + "px";
        }
        module.exports = dangerousStyleValue;
    }, {
        "./CSSProperty": 3
    } ],
    114: [ function(require, module, exports) {
        function makeEmptyFunction(arg) {
            return function() {
                return arg;
            };
        }
        function emptyFunction() {}
        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);
        emptyFunction.thatReturnsThis = function() {
            return this;
        };
        emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
        };
        module.exports = emptyFunction;
    }, {} ],
    115: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyObject = {};
            if ("production" !== process.env.NODE_ENV) {
                Object.freeze(emptyObject);
            }
            module.exports = emptyObject;
        }).call(this, require("_process"));
    }, {
        _process: 156
    } ],
    116: [ function(require, module, exports) {
        "use strict";
        var ESCAPE_LOOKUP = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;",
            "'": "&#x27;"
        };
        var ESCAPE_REGEX = /[&><"']/g;
        function escaper(match) {
            return ESCAPE_LOOKUP[match];
        }
        function escapeTextContentForBrowser(text) {
            return ("" + text).replace(ESCAPE_REGEX, escaper);
        }
        module.exports = escapeTextContentForBrowser;
    }, {} ],
    117: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactCurrentOwner = require("./ReactCurrentOwner");
            var ReactInstanceMap = require("./ReactInstanceMap");
            var ReactMount = require("./ReactMount");
            var invariant = require("./invariant");
            var isNode = require("./isNode");
            var warning = require("./warning");
            function findDOMNode(componentOrElement) {
                if ("production" !== process.env.NODE_ENV) {
                    var owner = ReactCurrentOwner.current;
                    if (owner !== null) {
                        "production" !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, "%s is accessing getDOMNode or findDOMNode inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", owner.getName() || "A component") : null;
                        owner._warnedAboutRefsInRender = true;
                    }
                }
                if (componentOrElement == null) {
                    return null;
                }
                if (isNode(componentOrElement)) {
                    return componentOrElement;
                }
                if (ReactInstanceMap.has(componentOrElement)) {
                    return ReactMount.getNodeFromInstance(componentOrElement);
                }
                "production" !== process.env.NODE_ENV ? invariant(componentOrElement.render == null || typeof componentOrElement.render !== "function", "Component (with keys: %s) contains `render` method " + "but is not mounted in the DOM", Object.keys(componentOrElement)) : invariant(componentOrElement.render == null || typeof componentOrElement.render !== "function");
                "production" !== process.env.NODE_ENV ? invariant(false, "Element appears to be neither ReactComponent nor DOMNode (keys: %s)", Object.keys(componentOrElement)) : invariant(false);
            }
            module.exports = findDOMNode;
        }).call(this, require("_process"));
    }, {
        "./ReactCurrentOwner": 39,
        "./ReactInstanceMap": 67,
        "./ReactMount": 70,
        "./invariant": 135,
        "./isNode": 137,
        "./warning": 154,
        _process: 156
    } ],
    118: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var traverseAllChildren = require("./traverseAllChildren");
            var warning = require("./warning");
            function flattenSingleChildIntoContext(traverseContext, child, name) {
                var result = traverseContext;
                var keyUnique = !result.hasOwnProperty(name);
                if ("production" !== process.env.NODE_ENV) {
                    "production" !== process.env.NODE_ENV ? warning(keyUnique, "flattenChildren(...): Encountered two children with the same key, " + "`%s`. Child keys must be unique; when two children share a key, only " + "the first child will be used.", name) : null;
                }
                if (keyUnique && child != null) {
                    result[name] = child;
                }
            }
            function flattenChildren(children) {
                if (children == null) {
                    return children;
                }
                var result = {};
                traverseAllChildren(children, flattenSingleChildIntoContext, result);
                return result;
            }
            module.exports = flattenChildren;
        }).call(this, require("_process"));
    }, {
        "./traverseAllChildren": 153,
        "./warning": 154,
        _process: 156
    } ],
    119: [ function(require, module, exports) {
        "use strict";
        function focusNode(node) {
            try {
                node.focus();
            } catch (e) {}
        }
        module.exports = focusNode;
    }, {} ],
    120: [ function(require, module, exports) {
        "use strict";
        var forEachAccumulated = function(arr, cb, scope) {
            if (Array.isArray(arr)) {
                arr.forEach(cb, scope);
            } else if (arr) {
                cb.call(scope, arr);
            }
        };
        module.exports = forEachAccumulated;
    }, {} ],
    121: [ function(require, module, exports) {
        function getActiveElement() {
            try {
                return document.activeElement || document.body;
            } catch (e) {
                return document.body;
            }
        }
        module.exports = getActiveElement;
    }, {} ],
    122: [ function(require, module, exports) {
        "use strict";
        function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
                charCode = nativeEvent.charCode;
                if (charCode === 0 && keyCode === 13) {
                    charCode = 13;
                }
            } else {
                charCode = keyCode;
            }
            if (charCode >= 32 || charCode === 13) {
                return charCode;
            }
            return 0;
        }
        module.exports = getEventCharCode;
    }, {} ],
    123: [ function(require, module, exports) {
        "use strict";
        var getEventCharCode = require("./getEventCharCode");
        var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        };
        function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if (key !== "Unidentified") {
                    return key;
                }
            }
            if (nativeEvent.type === "keypress") {
                var charCode = getEventCharCode(nativeEvent);
                return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
                return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
        }
        module.exports = getEventKey;
    }, {
        "./getEventCharCode": 122
    } ],
    124: [ function(require, module, exports) {
        "use strict";
        var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
                return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
        }
        module.exports = getEventModifierState;
    }, {} ],
    125: [ function(require, module, exports) {
        "use strict";
        function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            return target.nodeType === 3 ? target.parentNode : target;
        }
        module.exports = getEventTarget;
    }, {} ],
    126: [ function(require, module, exports) {
        "use strict";
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
            var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
            if (typeof iteratorFn === "function") {
                return iteratorFn;
            }
        }
        module.exports = getIteratorFn;
    }, {} ],
    127: [ function(require, module, exports) {
        (function(process) {
            var ExecutionEnvironment = require("./ExecutionEnvironment");
            var invariant = require("./invariant");
            var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null;
            var shouldWrap = {
                circle: true,
                clipPath: true,
                defs: true,
                ellipse: true,
                g: true,
                line: true,
                linearGradient: true,
                path: true,
                polygon: true,
                polyline: true,
                radialGradient: true,
                rect: true,
                stop: true,
                text: true
            };
            var selectWrap = [ 1, '<select multiple="true">', "</select>" ];
            var tableWrap = [ 1, "<table>", "</table>" ];
            var trWrap = [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ];
            var svgWrap = [ 1, "<svg>", "</svg>" ];
            var markupWrap = {
                "*": [ 1, "?<div>", "</div>" ],
                area: [ 1, "<map>", "</map>" ],
                col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
                legend: [ 1, "<fieldset>", "</fieldset>" ],
                param: [ 1, "<object>", "</object>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                optgroup: selectWrap,
                option: selectWrap,
                caption: tableWrap,
                colgroup: tableWrap,
                tbody: tableWrap,
                tfoot: tableWrap,
                thead: tableWrap,
                td: trWrap,
                th: trWrap,
                circle: svgWrap,
                clipPath: svgWrap,
                defs: svgWrap,
                ellipse: svgWrap,
                g: svgWrap,
                line: svgWrap,
                linearGradient: svgWrap,
                path: svgWrap,
                polygon: svgWrap,
                polyline: svgWrap,
                radialGradient: svgWrap,
                rect: svgWrap,
                stop: svgWrap,
                text: svgWrap
            };
            function getMarkupWrap(nodeName) {
                "production" !== process.env.NODE_ENV ? invariant(!!dummyNode, "Markup wrapping node not initialized") : invariant(!!dummyNode);
                if (!markupWrap.hasOwnProperty(nodeName)) {
                    nodeName = "*";
                }
                if (!shouldWrap.hasOwnProperty(nodeName)) {
                    if (nodeName === "*") {
                        dummyNode.innerHTML = "<link />";
                    } else {
                        dummyNode.innerHTML = "<" + nodeName + "></" + nodeName + ">";
                    }
                    shouldWrap[nodeName] = !dummyNode.firstChild;
                }
                return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
            }
            module.exports = getMarkupWrap;
        }).call(this, require("_process"));
    }, {
        "./ExecutionEnvironment": 20,
        "./invariant": 135,
        _process: 156
    } ],
    128: [ function(require, module, exports) {
        "use strict";
        function getLeafNode(node) {
            while (node && node.firstChild) {
                node = node.firstChild;
            }
            return node;
        }
        function getSiblingNode(node) {
            while (node) {
                if (node.nextSibling) {
                    return node.nextSibling;
                }
                node = node.parentNode;
            }
        }
        function getNodeForCharacterOffset(root, offset) {
            var node = getLeafNode(root);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
                if (node.nodeType === 3) {
                    nodeEnd = nodeStart + node.textContent.length;
                    if (nodeStart <= offset && nodeEnd >= offset) {
                        return {
                            node: node,
                            offset: offset - nodeStart
                        };
                    }
                    nodeStart = nodeEnd;
                }
                node = getLeafNode(getSiblingNode(node));
            }
        }
        module.exports = getNodeForCharacterOffset;
    }, {} ],
    129: [ function(require, module, exports) {
        "use strict";
        var DOC_NODE_TYPE = 9;
        function getReactRootElementInContainer(container) {
            if (!container) {
                return null;
            }
            if (container.nodeType === DOC_NODE_TYPE) {
                return container.documentElement;
            } else {
                return container.firstChild;
            }
        }
        module.exports = getReactRootElementInContainer;
    }, {} ],
    130: [ function(require, module, exports) {
        "use strict";
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var contentKey = null;
        function getTextContentAccessor() {
            if (!contentKey && ExecutionEnvironment.canUseDOM) {
                contentKey = "textContent" in document.documentElement ? "textContent" : "innerText";
            }
            return contentKey;
        }
        module.exports = getTextContentAccessor;
    }, {
        "./ExecutionEnvironment": 20
    } ],
    131: [ function(require, module, exports) {
        "use strict";
        function getUnboundedScrollPosition(scrollable) {
            if (scrollable === window) {
                return {
                    x: window.pageXOffset || document.documentElement.scrollLeft,
                    y: window.pageYOffset || document.documentElement.scrollTop
                };
            }
            return {
                x: scrollable.scrollLeft,
                y: scrollable.scrollTop
            };
        }
        module.exports = getUnboundedScrollPosition;
    }, {} ],
    132: [ function(require, module, exports) {
        var _uppercasePattern = /([A-Z])/g;
        function hyphenate(string) {
            return string.replace(_uppercasePattern, "-$1").toLowerCase();
        }
        module.exports = hyphenate;
    }, {} ],
    133: [ function(require, module, exports) {
        "use strict";
        var hyphenate = require("./hyphenate");
        var msPattern = /^ms-/;
        function hyphenateStyleName(string) {
            return hyphenate(string).replace(msPattern, "-ms-");
        }
        module.exports = hyphenateStyleName;
    }, {
        "./hyphenate": 132
    } ],
    134: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactCompositeComponent = require("./ReactCompositeComponent");
            var ReactEmptyComponent = require("./ReactEmptyComponent");
            var ReactNativeComponent = require("./ReactNativeComponent");
            var assign = require("./Object.assign");
            var invariant = require("./invariant");
            var warning = require("./warning");
            var ReactCompositeComponentWrapper = function() {};
            assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
                _instantiateReactComponent: instantiateReactComponent
            });
            function isInternalComponentType(type) {
                return typeof type === "function" && typeof type.prototype !== "undefined" && typeof type.prototype.mountComponent === "function" && typeof type.prototype.receiveComponent === "function";
            }
            function instantiateReactComponent(node, parentCompositeType) {
                var instance;
                if (node === null || node === false) {
                    node = ReactEmptyComponent.emptyElement;
                }
                if (typeof node === "object") {
                    var element = node;
                    if ("production" !== process.env.NODE_ENV) {
                        "production" !== process.env.NODE_ENV ? warning(element && (typeof element.type === "function" || typeof element.type === "string"), "Only functions or strings can be mounted as React components.") : null;
                    }
                    if (parentCompositeType === element.type && typeof element.type === "string") {
                        instance = ReactNativeComponent.createInternalComponent(element);
                    } else if (isInternalComponentType(element.type)) {
                        instance = new element.type(element);
                    } else {
                        instance = new ReactCompositeComponentWrapper();
                    }
                } else if (typeof node === "string" || typeof node === "number") {
                    instance = ReactNativeComponent.createInstanceForText(node);
                } else {
                    "production" !== process.env.NODE_ENV ? invariant(false, "Encountered invalid React node of type %s", typeof node) : invariant(false);
                }
                if ("production" !== process.env.NODE_ENV) {
                    "production" !== process.env.NODE_ENV ? warning(typeof instance.construct === "function" && typeof instance.mountComponent === "function" && typeof instance.receiveComponent === "function" && typeof instance.unmountComponent === "function", "Only React Components can be mounted.") : null;
                }
                instance.construct(node);
                instance._mountIndex = 0;
                instance._mountImage = null;
                if ("production" !== process.env.NODE_ENV) {
                    instance._isOwnerNecessary = false;
                    instance._warnedAboutRefsInRender = false;
                }
                if ("production" !== process.env.NODE_ENV) {
                    if (Object.preventExtensions) {
                        Object.preventExtensions(instance);
                    }
                }
                return instance;
            }
            module.exports = instantiateReactComponent;
        }).call(this, require("_process"));
    }, {
        "./Object.assign": 26,
        "./ReactCompositeComponent": 37,
        "./ReactEmptyComponent": 59,
        "./ReactNativeComponent": 73,
        "./invariant": 135,
        "./warning": 154,
        _process: 156
    } ],
    135: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = function(condition, format, a, b, c, d, e, f) {
                if ("production" !== process.env.NODE_ENV) {
                    if (format === undefined) {
                        throw new Error("invariant requires an error message argument");
                    }
                }
                if (!condition) {
                    var error;
                    if (format === undefined) {
                        error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
                    } else {
                        var args = [ a, b, c, d, e, f ];
                        var argIndex = 0;
                        error = new Error("Invariant Violation: " + format.replace(/%s/g, function() {
                            return args[argIndex++];
                        }));
                    }
                    error.framesToPop = 1;
                    throw error;
                }
            };
            module.exports = invariant;
        }).call(this, require("_process"));
    }, {
        _process: 156
    } ],
    136: [ function(require, module, exports) {
        "use strict";
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var useHasFeature;
        if (ExecutionEnvironment.canUseDOM) {
            useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true;
        }
        function isEventSupported(eventNameSuffix, capture) {
            if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener" in document)) {
                return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
                var element = document.createElement("div");
                element.setAttribute(eventName, "return;");
                isSupported = typeof element[eventName] === "function";
            }
            if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
                isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
            }
            return isSupported;
        }
        module.exports = isEventSupported;
    }, {
        "./ExecutionEnvironment": 20
    } ],
    137: [ function(require, module, exports) {
        function isNode(object) {
            return !!(object && (typeof Node === "function" ? object instanceof Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"));
        }
        module.exports = isNode;
    }, {} ],
    138: [ function(require, module, exports) {
        "use strict";
        var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
        };
        function isTextInputElement(elem) {
            return elem && (elem.nodeName === "INPUT" && supportedInputTypes[elem.type] || elem.nodeName === "TEXTAREA");
        }
        module.exports = isTextInputElement;
    }, {} ],
    139: [ function(require, module, exports) {
        var isNode = require("./isNode");
        function isTextNode(object) {
            return isNode(object) && object.nodeType == 3;
        }
        module.exports = isTextNode;
    }, {
        "./isNode": 137
    } ],
    140: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            var keyMirror = function(obj) {
                var ret = {};
                var key;
                "production" !== process.env.NODE_ENV ? invariant(obj instanceof Object && !Array.isArray(obj), "keyMirror(...): Argument must be an object.") : invariant(obj instanceof Object && !Array.isArray(obj));
                for (key in obj) {
                    if (!obj.hasOwnProperty(key)) {
                        continue;
                    }
                    ret[key] = key;
                }
                return ret;
            };
            module.exports = keyMirror;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    141: [ function(require, module, exports) {
        var keyOf = function(oneKeyObj) {
            var key;
            for (key in oneKeyObj) {
                if (!oneKeyObj.hasOwnProperty(key)) {
                    continue;
                }
                return key;
            }
            return null;
        };
        module.exports = keyOf;
    }, {} ],
    142: [ function(require, module, exports) {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function mapObject(object, callback, context) {
            if (!object) {
                return null;
            }
            var result = {};
            for (var name in object) {
                if (hasOwnProperty.call(object, name)) {
                    result[name] = callback.call(context, object[name], name, object);
                }
            }
            return result;
        }
        module.exports = mapObject;
    }, {} ],
    143: [ function(require, module, exports) {
        "use strict";
        function memoizeStringOnly(callback) {
            var cache = {};
            return function(string) {
                if (!cache.hasOwnProperty(string)) {
                    cache[string] = callback.call(this, string);
                }
                return cache[string];
            };
        }
        module.exports = memoizeStringOnly;
    }, {} ],
    144: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactElement = require("./ReactElement");
            var invariant = require("./invariant");
            function onlyChild(children) {
                "production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(children), "onlyChild must be passed a children with exactly one child.") : invariant(ReactElement.isValidElement(children));
                return children;
            }
            module.exports = onlyChild;
        }).call(this, require("_process"));
    }, {
        "./ReactElement": 57,
        "./invariant": 135,
        _process: 156
    } ],
    145: [ function(require, module, exports) {
        "use strict";
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var performance;
        if (ExecutionEnvironment.canUseDOM) {
            performance = window.performance || window.msPerformance || window.webkitPerformance;
        }
        module.exports = performance || {};
    }, {
        "./ExecutionEnvironment": 20
    } ],
    146: [ function(require, module, exports) {
        var performance = require("./performance");
        if (!performance || !performance.now) {
            performance = Date;
        }
        var performanceNow = performance.now.bind(performance);
        module.exports = performanceNow;
    }, {
        "./performance": 145
    } ],
    147: [ function(require, module, exports) {
        "use strict";
        var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
        function quoteAttributeValueForBrowser(value) {
            return '"' + escapeTextContentForBrowser(value) + '"';
        }
        module.exports = quoteAttributeValueForBrowser;
    }, {
        "./escapeTextContentForBrowser": 116
    } ],
    148: [ function(require, module, exports) {
        "use strict";
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var WHITESPACE_TEST = /^[ \r\n\t\f]/;
        var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
        var setInnerHTML = function(node, html) {
            node.innerHTML = html;
        };
        if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            setInnerHTML = function(node, html) {
                MSApp.execUnsafeLocalFunction(function() {
                    node.innerHTML = html;
                });
            };
        }
        if (ExecutionEnvironment.canUseDOM) {
            var testElement = document.createElement("div");
            testElement.innerHTML = " ";
            if (testElement.innerHTML === "") {
                setInnerHTML = function(node, html) {
                    if (node.parentNode) {
                        node.parentNode.replaceChild(node, node);
                    }
                    if (WHITESPACE_TEST.test(html) || html[0] === "<" && NONVISIBLE_TEST.test(html)) {
                        node.innerHTML = "\ufeff" + html;
                        var textNode = node.firstChild;
                        if (textNode.data.length === 1) {
                            node.removeChild(textNode);
                        } else {
                            textNode.deleteData(0, 1);
                        }
                    } else {
                        node.innerHTML = html;
                    }
                };
            }
        }
        module.exports = setInnerHTML;
    }, {
        "./ExecutionEnvironment": 20
    } ],
    149: [ function(require, module, exports) {
        "use strict";
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
        var setInnerHTML = require("./setInnerHTML");
        var setTextContent = function(node, text) {
            node.textContent = text;
        };
        if (ExecutionEnvironment.canUseDOM) {
            if (!("textContent" in document.documentElement)) {
                setTextContent = function(node, text) {
                    setInnerHTML(node, escapeTextContentForBrowser(text));
                };
            }
        }
        module.exports = setTextContent;
    }, {
        "./ExecutionEnvironment": 20,
        "./escapeTextContentForBrowser": 116,
        "./setInnerHTML": 148
    } ],
    150: [ function(require, module, exports) {
        "use strict";
        function shallowEqual(objA, objB) {
            if (objA === objB) {
                return true;
            }
            var key;
            for (key in objA) {
                if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
                    return false;
                }
            }
            for (key in objB) {
                if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        }
        module.exports = shallowEqual;
    }, {} ],
    151: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var warning = require("./warning");
            function shouldUpdateReactComponent(prevElement, nextElement) {
                if (prevElement != null && nextElement != null) {
                    var prevType = typeof prevElement;
                    var nextType = typeof nextElement;
                    if (prevType === "string" || prevType === "number") {
                        return nextType === "string" || nextType === "number";
                    } else {
                        if (nextType === "object" && prevElement.type === nextElement.type && prevElement.key === nextElement.key) {
                            var ownersMatch = prevElement._owner === nextElement._owner;
                            var prevName = null;
                            var nextName = null;
                            var nextDisplayName = null;
                            if ("production" !== process.env.NODE_ENV) {
                                if (!ownersMatch) {
                                    if (prevElement._owner != null && prevElement._owner.getPublicInstance() != null && prevElement._owner.getPublicInstance().constructor != null) {
                                        prevName = prevElement._owner.getPublicInstance().constructor.displayName;
                                    }
                                    if (nextElement._owner != null && nextElement._owner.getPublicInstance() != null && nextElement._owner.getPublicInstance().constructor != null) {
                                        nextName = nextElement._owner.getPublicInstance().constructor.displayName;
                                    }
                                    if (nextElement.type != null && nextElement.type.displayName != null) {
                                        nextDisplayName = nextElement.type.displayName;
                                    }
                                    if (nextElement.type != null && typeof nextElement.type === "string") {
                                        nextDisplayName = nextElement.type;
                                    }
                                    if (typeof nextElement.type !== "string" || nextElement.type === "input" || nextElement.type === "textarea") {
                                        if (prevElement._owner != null && prevElement._owner._isOwnerNecessary === false || nextElement._owner != null && nextElement._owner._isOwnerNecessary === false) {
                                            if (prevElement._owner != null) {
                                                prevElement._owner._isOwnerNecessary = true;
                                            }
                                            if (nextElement._owner != null) {
                                                nextElement._owner._isOwnerNecessary = true;
                                            }
                                            "production" !== process.env.NODE_ENV ? warning(false, "<%s /> is being rendered by both %s and %s using the same " + "key (%s) in the same place. Currently, this means that " + "they don't preserve state. This behavior should be very " + "rare so we're considering deprecating it. Please contact " + "the React team and explain your use case so that we can " + "take that into consideration.", nextDisplayName || "Unknown Component", prevName || "[Unknown]", nextName || "[Unknown]", prevElement.key) : null;
                                        }
                                    }
                                }
                            }
                            return ownersMatch;
                        }
                    }
                }
                return false;
            }
            module.exports = shouldUpdateReactComponent;
        }).call(this, require("_process"));
    }, {
        "./warning": 154,
        _process: 156
    } ],
    152: [ function(require, module, exports) {
        (function(process) {
            var invariant = require("./invariant");
            function toArray(obj) {
                var length = obj.length;
                "production" !== process.env.NODE_ENV ? invariant(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function"), "toArray: Array-like object expected") : invariant(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function"));
                "production" !== process.env.NODE_ENV ? invariant(typeof length === "number", "toArray: Object needs a length property") : invariant(typeof length === "number");
                "production" !== process.env.NODE_ENV ? invariant(length === 0 || length - 1 in obj, "toArray: Object should have keys for indices") : invariant(length === 0 || length - 1 in obj);
                if (obj.hasOwnProperty) {
                    try {
                        return Array.prototype.slice.call(obj);
                    } catch (e) {}
                }
                var ret = Array(length);
                for (var ii = 0; ii < length; ii++) {
                    ret[ii] = obj[ii];
                }
                return ret;
            }
            module.exports = toArray;
        }).call(this, require("_process"));
    }, {
        "./invariant": 135,
        _process: 156
    } ],
    153: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var ReactElement = require("./ReactElement");
            var ReactFragment = require("./ReactFragment");
            var ReactInstanceHandles = require("./ReactInstanceHandles");
            var getIteratorFn = require("./getIteratorFn");
            var invariant = require("./invariant");
            var warning = require("./warning");
            var SEPARATOR = ReactInstanceHandles.SEPARATOR;
            var SUBSEPARATOR = ":";
            var userProvidedKeyEscaperLookup = {
                "=": "=0",
                ".": "=1",
                ":": "=2"
            };
            var userProvidedKeyEscapeRegex = /[=.:]/g;
            var didWarnAboutMaps = false;
            function userProvidedKeyEscaper(match) {
                return userProvidedKeyEscaperLookup[match];
            }
            function getComponentKey(component, index) {
                if (component && component.key != null) {
                    return wrapUserProvidedKey(component.key);
                }
                return index.toString(36);
            }
            function escapeUserProvidedKey(text) {
                return ("" + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
            }
            function wrapUserProvidedKey(key) {
                return "$" + escapeUserProvidedKey(key);
            }
            function traverseAllChildrenImpl(children, nameSoFar, indexSoFar, callback, traverseContext) {
                var type = typeof children;
                if (type === "undefined" || type === "boolean") {
                    children = null;
                }
                if (children === null || type === "string" || type === "number" || ReactElement.isValidElement(children)) {
                    callback(traverseContext, children, nameSoFar === "" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, indexSoFar);
                    return 1;
                }
                var child, nextName, nextIndex;
                var subtreeCount = 0;
                if (Array.isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        nextName = (nameSoFar !== "" ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);
                        nextIndex = indexSoFar + subtreeCount;
                        subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
                    }
                } else {
                    var iteratorFn = getIteratorFn(children);
                    if (iteratorFn) {
                        var iterator = iteratorFn.call(children);
                        var step;
                        if (iteratorFn !== children.entries) {
                            var ii = 0;
                            while (!(step = iterator.next()).done) {
                                child = step.value;
                                nextName = (nameSoFar !== "" ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, ii++);
                                nextIndex = indexSoFar + subtreeCount;
                                subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
                            }
                        } else {
                            if ("production" !== process.env.NODE_ENV) {
                                "production" !== process.env.NODE_ENV ? warning(didWarnAboutMaps, "Using Maps as children is not yet fully supported. It is an " + "experimental feature that might be removed. Convert it to a " + "sequence / iterable of keyed ReactElements instead.") : null;
                                didWarnAboutMaps = true;
                            }
                            while (!(step = iterator.next()).done) {
                                var entry = step.value;
                                if (entry) {
                                    child = entry[1];
                                    nextName = (nameSoFar !== "" ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                                    nextIndex = indexSoFar + subtreeCount;
                                    subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
                                }
                            }
                        }
                    } else if (type === "object") {
                        "production" !== process.env.NODE_ENV ? invariant(children.nodeType !== 1, "traverseAllChildren(...): Encountered an invalid child; DOM " + "elements are not valid children of React components.") : invariant(children.nodeType !== 1);
                        var fragment = ReactFragment.extract(children);
                        for (var key in fragment) {
                            if (fragment.hasOwnProperty(key)) {
                                child = fragment[key];
                                nextName = (nameSoFar !== "" ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(child, 0);
                                nextIndex = indexSoFar + subtreeCount;
                                subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
                            }
                        }
                    }
                }
                return subtreeCount;
            }
            function traverseAllChildren(children, callback, traverseContext) {
                if (children == null) {
                    return 0;
                }
                return traverseAllChildrenImpl(children, "", 0, callback, traverseContext);
            }
            module.exports = traverseAllChildren;
        }).call(this, require("_process"));
    }, {
        "./ReactElement": 57,
        "./ReactFragment": 63,
        "./ReactInstanceHandles": 66,
        "./getIteratorFn": 126,
        "./invariant": 135,
        "./warning": 154,
        _process: 156
    } ],
    154: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyFunction = require("./emptyFunction");
            var warning = emptyFunction;
            if ("production" !== process.env.NODE_ENV) {
                warning = function(condition, format) {
                    for (var args = [], $__0 = 2, $__1 = arguments.length; $__0 < $__1; $__0++) args.push(arguments[$__0]);
                    if (format === undefined) {
                        throw new Error("`warning(condition, format, ...args)` requires a warning " + "message argument");
                    }
                    if (format.length < 10 || /^[s\W]*$/.test(format)) {
                        throw new Error("The warning format should be able to uniquely identify this " + "warning. Please, use a more descriptive format than: " + format);
                    }
                    if (format.indexOf("Failed Composite propType: ") === 0) {
                        return;
                    }
                    if (!condition) {
                        var argIndex = 0;
                        var message = "Warning: " + format.replace(/%s/g, function() {
                            return args[argIndex++];
                        });
                        console.warn(message);
                        try {
                            throw new Error(message);
                        } catch (x) {}
                    }
                };
            }
            module.exports = warning;
        }).call(this, require("_process"));
    }, {
        "./emptyFunction": 114,
        _process: 156
    } ],
    155: [ function(require, module, exports) {
        module.exports = require("./lib/React");
    }, {
        "./lib/React": 28
    } ],
    156: [ function(require, module, exports) {
        var process = module.exports = {};
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }
        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = setTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    currentQueue[queueIndex].run();
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            clearTimeout(timeout);
        }
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                setTimeout(drainQueue, 0);
            }
        };
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.binding = function(name) {
            throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
            return "/";
        };
        process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
            return 0;
        };
    }, {} ],
    157: [ function(require, module, exports) {
        var paper = new function(undefined) {
            var Base = new function() {
                var hidden = /^(statics|enumerable|beans|preserve)$/, forEach = [].forEach || function(iter, bind) {
                    for (var i = 0, l = this.length; i < l; i++) iter.call(bind, this[i], i, this);
                }, forIn = function(iter, bind) {
                    for (var i in this) if (this.hasOwnProperty(i)) iter.call(bind, this[i], i, this);
                }, create = Object.create || function(proto) {
                    return {
                        __proto__: proto
                    };
                }, describe = Object.getOwnPropertyDescriptor || function(obj, name) {
                    var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
                    return get ? {
                        get: get,
                        set: obj.__lookupSetter__(name),
                        enumerable: true,
                        configurable: true
                    } : obj.hasOwnProperty(name) ? {
                        value: obj[name],
                        enumerable: true,
                        configurable: true,
                        writable: true
                    } : null;
                }, _define = Object.defineProperty || function(obj, name, desc) {
                    if ((desc.get || desc.set) && obj.__defineGetter__) {
                        if (desc.get) obj.__defineGetter__(name, desc.get);
                        if (desc.set) obj.__defineSetter__(name, desc.set);
                    } else {
                        obj[name] = desc.value;
                    }
                    return obj;
                }, define = function(obj, name, desc) {
                    delete obj[name];
                    return _define(obj, name, desc);
                };
                function inject(dest, src, enumerable, beans, preserve) {
                    var beansNames = {};
                    function field(name, val) {
                        val = val || (val = describe(src, name)) && (val.get ? val : val.value);
                        if (typeof val === "string" && val[0] === "#") val = dest[val.substring(1)] || val;
                        var isFunc = typeof val === "function", res = val, prev = preserve || isFunc ? val && val.get ? name in dest : dest[name] : null, bean;
                        if (!preserve || !prev) {
                            if (isFunc && prev) val.base = prev;
                            if (isFunc && beans !== false && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/))) beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
                            if (!res || isFunc || !res.get || typeof res.get !== "function" || !Base.isPlainObject(res)) res = {
                                value: res,
                                writable: true
                            };
                            if ((describe(dest, name) || {
                                configurable: true
                            }).configurable) {
                                res.configurable = true;
                                res.enumerable = enumerable;
                            }
                            define(dest, name, res);
                        }
                    }
                    if (src) {
                        for (var name in src) {
                            if (src.hasOwnProperty(name) && !hidden.test(name)) field(name);
                        }
                        for (var name in beansNames) {
                            var part = beansNames[name], set = dest["set" + part], get = dest["get" + part] || set && dest["is" + part];
                            if (get && (beans === true || get.length === 0)) field(name, {
                                get: get,
                                set: set
                            });
                        }
                    }
                    return dest;
                }
                function each(obj, iter, bind) {
                    if (obj) ("length" in obj && !obj.getLength && typeof obj.length === "number" ? forEach : forIn).call(obj, iter, bind = bind || obj);
                    return bind;
                }
                function set(obj, props, exclude) {
                    for (var key in props) if (props.hasOwnProperty(key) && !(exclude && exclude[key])) obj[key] = props[key];
                    return obj;
                }
                return inject(function Base() {
                    for (var i = 0, l = arguments.length; i < l; i++) set(this, arguments[i]);
                }, {
                    inject: function(src) {
                        if (src) {
                            var statics = src.statics === true ? src : src.statics, beans = src.beans, preserve = src.preserve;
                            if (statics !== src) inject(this.prototype, src, src.enumerable, beans, preserve);
                            inject(this, statics, true, beans, preserve);
                        }
                        for (var i = 1, l = arguments.length; i < l; i++) this.inject(arguments[i]);
                        return this;
                    },
                    extend: function() {
                        var base = this, ctor, proto;
                        for (var i = 0, l = arguments.length; i < l; i++) if (ctor = arguments[i].initialize) break;
                        ctor = ctor || function() {
                            base.apply(this, arguments);
                        };
                        proto = ctor.prototype = create(this.prototype);
                        define(proto, "constructor", {
                            value: ctor,
                            writable: true,
                            configurable: true
                        });
                        inject(ctor, this, true);
                        if (arguments.length) this.inject.apply(ctor, arguments);
                        ctor.base = base;
                        return ctor;
                    }
                }, true).inject({
                    inject: function() {
                        for (var i = 0, l = arguments.length; i < l; i++) {
                            var src = arguments[i];
                            if (src) inject(this, src, src.enumerable, src.beans, src.preserve);
                        }
                        return this;
                    },
                    extend: function() {
                        var res = create(this);
                        return res.inject.apply(res, arguments);
                    },
                    each: function(iter, bind) {
                        return each(this, iter, bind);
                    },
                    set: function(props) {
                        return set(this, props);
                    },
                    clone: function() {
                        return new this.constructor(this);
                    },
                    statics: {
                        each: each,
                        create: create,
                        define: define,
                        describe: describe,
                        set: set,
                        clone: function(obj) {
                            return set(new obj.constructor(), obj);
                        },
                        isPlainObject: function(obj) {
                            var ctor = obj != null && obj.constructor;
                            return ctor && (ctor === Object || ctor === Base || ctor.name === "Object");
                        },
                        pick: function(a, b) {
                            return a !== undefined ? a : b;
                        }
                    }
                });
            }();
            if (typeof module !== "undefined") module.exports = Base;
            Base.inject({
                toString: function() {
                    return this._id != null ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + Base.each(this, function(value, key) {
                        if (!/^_/.test(key)) {
                            var type = typeof value;
                            this.push(key + ": " + (type === "number" ? Formatter.instance.number(value) : type === "string" ? "'" + value + "'" : value));
                        }
                    }, []).join(", ") + " }";
                },
                getClassName: function() {
                    return this._class || "";
                },
                exportJSON: function(options) {
                    return Base.exportJSON(this, options);
                },
                toJSON: function() {
                    return Base.serialize(this);
                },
                _set: function(props, exclude, dontCheck) {
                    if (props && (dontCheck || Base.isPlainObject(props))) {
                        var orig = props._filtering || props;
                        for (var key in orig) {
                            if (orig.hasOwnProperty(key) && !(exclude && exclude[key])) {
                                var value = props[key];
                                if (value !== undefined) this[key] = value;
                            }
                        }
                        return true;
                    }
                },
                statics: {
                    exports: {
                        enumerable: true
                    },
                    extend: function extend() {
                        var res = extend.base.apply(this, arguments), name = res.prototype._class;
                        if (name && !Base.exports[name]) Base.exports[name] = res;
                        return res;
                    },
                    equals: function(obj1, obj2) {
                        function checkKeys(o1, o2) {
                            for (var i in o1) if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i)) return false;
                            return true;
                        }
                        if (obj1 === obj2) return true;
                        if (obj1 && obj1.equals) return obj1.equals(obj2);
                        if (obj2 && obj2.equals) return obj2.equals(obj1);
                        if (Array.isArray(obj1) && Array.isArray(obj2)) {
                            if (obj1.length !== obj2.length) return false;
                            for (var i = 0, l = obj1.length; i < l; i++) {
                                if (!Base.equals(obj1[i], obj2[i])) return false;
                            }
                            return true;
                        }
                        if (obj1 && typeof obj1 === "object" && obj2 && typeof obj2 === "object") {
                            if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1)) return false;
                            for (var i in obj1) {
                                if (obj1.hasOwnProperty(i) && !Base.equals(obj1[i], obj2[i])) return false;
                            }
                            return true;
                        }
                        return false;
                    },
                    read: function(list, start, options, length) {
                        if (this === Base) {
                            var value = this.peek(list, start);
                            list.__index++;
                            return value;
                        }
                        var proto = this.prototype, readIndex = proto._readIndex, index = start || readIndex && list.__index || 0;
                        if (!length) length = list.length - index;
                        var obj = list[index];
                        if (obj instanceof this || options && options.readNull && obj == null && length <= 1) {
                            if (readIndex) list.__index = index + 1;
                            return obj && options && options.clone ? obj.clone() : obj;
                        }
                        obj = Base.create(this.prototype);
                        if (readIndex) obj.__read = true;
                        obj = obj.initialize.apply(obj, index > 0 || length < list.length ? Array.prototype.slice.call(list, index, index + length) : list) || obj;
                        if (readIndex) {
                            list.__index = index + obj.__read;
                            obj.__read = undefined;
                        }
                        return obj;
                    },
                    peek: function(list, start) {
                        return list[list.__index = start || list.__index || 0];
                    },
                    remain: function(list) {
                        return list.length - (list.__index || 0);
                    },
                    readAll: function(list, start, options) {
                        var res = [], entry;
                        for (var i = start || 0, l = list.length; i < l; i++) {
                            res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));
                        }
                        return res;
                    },
                    readNamed: function(list, name, start, options, length) {
                        var value = this.getNamed(list, name), hasObject = value !== undefined;
                        if (hasObject) {
                            var filtered = list._filtered;
                            if (!filtered) {
                                filtered = list._filtered = Base.create(list[0]);
                                filtered._filtering = list[0];
                            }
                            filtered[name] = undefined;
                        }
                        return this.read(hasObject ? [ value ] : list, start, options, length);
                    },
                    getNamed: function(list, name) {
                        var arg = list[0];
                        if (list._hasObject === undefined) list._hasObject = list.length === 1 && Base.isPlainObject(arg);
                        if (list._hasObject) return name ? arg[name] : list._filtered || arg;
                    },
                    hasNamed: function(list, name) {
                        return !!this.getNamed(list, name);
                    },
                    isPlainValue: function(obj, asString) {
                        return this.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === "string";
                    },
                    serialize: function(obj, options, compact, dictionary) {
                        options = options || {};
                        var root = !dictionary, res;
                        if (root) {
                            options.formatter = new Formatter(options.precision);
                            dictionary = {
                                length: 0,
                                definitions: {},
                                references: {},
                                add: function(item, create) {
                                    var id = "#" + item._id, ref = this.references[id];
                                    if (!ref) {
                                        this.length++;
                                        var res = create.call(item), name = item._class;
                                        if (name && res[0] !== name) res.unshift(name);
                                        this.definitions[id] = res;
                                        ref = this.references[id] = [ id ];
                                    }
                                    return ref;
                                }
                            };
                        }
                        if (obj && obj._serialize) {
                            res = obj._serialize(options, dictionary);
                            var name = obj._class;
                            if (name && !compact && !res._compact && res[0] !== name) res.unshift(name);
                        } else if (Array.isArray(obj)) {
                            res = [];
                            for (var i = 0, l = obj.length; i < l; i++) res[i] = Base.serialize(obj[i], options, compact, dictionary);
                            if (compact) res._compact = true;
                        } else if (Base.isPlainObject(obj)) {
                            res = {};
                            for (var i in obj) if (obj.hasOwnProperty(i)) res[i] = Base.serialize(obj[i], options, compact, dictionary);
                        } else if (typeof obj === "number") {
                            res = options.formatter.number(obj, options.precision);
                        } else {
                            res = obj;
                        }
                        return root && dictionary.length > 0 ? [ [ "dictionary", dictionary.definitions ], res ] : res;
                    },
                    deserialize: function(json, create, _data, _isDictionary) {
                        var res = json, isRoot = !_data;
                        _data = _data || {};
                        if (Array.isArray(json)) {
                            var type = json[0], isDictionary = type === "dictionary";
                            if (json.length == 1 && /^#/.test(type)) return _data.dictionary[type];
                            type = Base.exports[type];
                            res = [];
                            if (_isDictionary) _data.dictionary = res;
                            for (var i = type ? 1 : 0, l = json.length; i < l; i++) res.push(Base.deserialize(json[i], create, _data, isDictionary));
                            if (type) {
                                var args = res;
                                if (create) {
                                    res = create(type, args);
                                } else {
                                    res = Base.create(type.prototype);
                                    type.apply(res, args);
                                }
                            }
                        } else if (Base.isPlainObject(json)) {
                            res = {};
                            if (_isDictionary) _data.dictionary = res;
                            for (var key in json) res[key] = Base.deserialize(json[key], create, _data);
                        }
                        return isRoot && json && json.length && json[0][0] === "dictionary" ? res[1] : res;
                    },
                    exportJSON: function(obj, options) {
                        var json = Base.serialize(obj, options);
                        return options && options.asString === false ? json : JSON.stringify(json);
                    },
                    importJSON: function(json, target) {
                        return Base.deserialize(typeof json === "string" ? JSON.parse(json) : json, function(type, args) {
                            var obj = target && target.constructor === type ? target : Base.create(type.prototype), isTarget = obj === target;
                            if (args.length === 1 && obj instanceof Item && (isTarget || !(obj instanceof Layer))) {
                                var arg = args[0];
                                if (Base.isPlainObject(arg)) arg.insert = false;
                            }
                            type.apply(obj, args);
                            if (isTarget) target = null;
                            return obj;
                        });
                    },
                    splice: function(list, items, index, remove) {
                        var amount = items && items.length, append = index === undefined;
                        index = append ? list.length : index;
                        if (index > list.length) index = list.length;
                        for (var i = 0; i < amount; i++) items[i]._index = index + i;
                        if (append) {
                            list.push.apply(list, items);
                            return [];
                        } else {
                            var args = [ index, remove ];
                            if (items) args.push.apply(args, items);
                            var removed = list.splice.apply(list, args);
                            for (var i = 0, l = removed.length; i < l; i++) removed[i]._index = undefined;
                            for (var i = index + amount, l = list.length; i < l; i++) list[i]._index = i;
                            return removed;
                        }
                    },
                    capitalize: function(str) {
                        return str.replace(/\b[a-z]/g, function(match) {
                            return match.toUpperCase();
                        });
                    },
                    camelize: function(str) {
                        return str.replace(/-(.)/g, function(all, chr) {
                            return chr.toUpperCase();
                        });
                    },
                    hyphenate: function(str) {
                        return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                    }
                }
            });
            var Emitter = {
                on: function(type, func) {
                    if (typeof type !== "string") {
                        Base.each(type, function(value, key) {
                            this.on(key, value);
                        }, this);
                    } else {
                        var types = this._eventTypes, entry = types && types[type], handlers = this._callbacks = this._callbacks || {};
                        handlers = handlers[type] = handlers[type] || [];
                        if (handlers.indexOf(func) === -1) {
                            handlers.push(func);
                            if (entry && entry.install && handlers.length == 1) entry.install.call(this, type);
                        }
                    }
                    return this;
                },
                off: function(type, func) {
                    if (typeof type !== "string") {
                        Base.each(type, function(value, key) {
                            this.off(key, value);
                        }, this);
                        return;
                    }
                    var types = this._eventTypes, entry = types && types[type], handlers = this._callbacks && this._callbacks[type], index;
                    if (handlers) {
                        if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {
                            if (entry && entry.uninstall) entry.uninstall.call(this, type);
                            delete this._callbacks[type];
                        } else if (index !== -1) {
                            handlers.splice(index, 1);
                        }
                    }
                    return this;
                },
                once: function(type, func) {
                    return this.on(type, function() {
                        func.apply(this, arguments);
                        this.off(type, func);
                    });
                },
                emit: function(type, event) {
                    var handlers = this._callbacks && this._callbacks[type];
                    if (!handlers) return false;
                    var args = [].slice.call(arguments, 1);
                    handlers = handlers.slice();
                    for (var i = 0, l = handlers.length; i < l; i++) {
                        if (handlers[i].apply(this, args) === false) {
                            if (event && event.stop) event.stop();
                            break;
                        }
                    }
                    return true;
                },
                responds: function(type) {
                    return !!(this._callbacks && this._callbacks[type]);
                },
                attach: "#on",
                detach: "#off",
                fire: "#emit",
                _installEvents: function(install) {
                    var handlers = this._callbacks, key = install ? "install" : "uninstall";
                    for (var type in handlers) {
                        if (handlers[type].length > 0) {
                            var types = this._eventTypes, entry = types && types[type], func = entry && entry[key];
                            if (func) func.call(this, type);
                        }
                    }
                },
                statics: {
                    inject: function inject(src) {
                        var events = src._events;
                        if (events) {
                            var types = {};
                            Base.each(events, function(entry, key) {
                                var isString = typeof entry === "string", name = isString ? entry : key, part = Base.capitalize(name), type = name.substring(2).toLowerCase();
                                types[type] = isString ? {} : entry;
                                name = "_" + name;
                                src["get" + part] = function() {
                                    return this[name];
                                };
                                src["set" + part] = function(func) {
                                    var prev = this[name];
                                    if (prev) this.off(type, prev);
                                    if (func) this.on(type, func);
                                    this[name] = func;
                                };
                            });
                            src._eventTypes = types;
                        }
                        return inject.base.apply(this, arguments);
                    }
                }
            };
            var PaperScope = Base.extend({
                _class: "PaperScope",
                initialize: function PaperScope() {
                    paper = this;
                    this.settings = new Base({
                        applyMatrix: true,
                        handleSize: 4,
                        hitTolerance: 0
                    });
                    this.project = null;
                    this.projects = [];
                    this.tools = [];
                    this.palettes = [];
                    this._id = PaperScope._id++;
                    PaperScope._scopes[this._id] = this;
                    var proto = PaperScope.prototype;
                    if (!this.support) {
                        var ctx = CanvasProvider.getContext(1, 1);
                        proto.support = {
                            nativeDash: "setLineDash" in ctx || "mozDash" in ctx,
                            nativeBlendModes: BlendMode.nativeModes
                        };
                        CanvasProvider.release(ctx);
                    }
                    if (!this.browser) {
                        var browser = proto.browser = {};
                        navigator.userAgent.toLowerCase().replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g, function(all, n, v1, v2, rv) {
                            if (!browser.chrome) {
                                var v = n === "opera" ? v2 : v1;
                                if (n === "trident") {
                                    v = rv;
                                    n = "msie";
                                }
                                browser.version = v;
                                browser.versionNumber = parseFloat(v);
                                browser.name = n;
                                browser[n] = true;
                            }
                        });
                        if (browser.chrome) delete browser.webkit;
                        if (browser.atom) delete browser.chrome;
                    }
                },
                version: "0.9.23",
                getView: function() {
                    return this.project && this.project.getView();
                },
                getPaper: function() {
                    return this;
                },
                execute: function(code, url, options) {
                    paper.PaperScript.execute(code, this, url, options);
                    View.updateFocus();
                },
                install: function(scope) {
                    var that = this;
                    Base.each([ "project", "view", "tool" ], function(key) {
                        Base.define(scope, key, {
                            configurable: true,
                            get: function() {
                                return that[key];
                            }
                        });
                    });
                    for (var key in this) if (!/^_/.test(key) && this[key]) scope[key] = this[key];
                },
                setup: function(element) {
                    paper = this;
                    this.project = new Project(element);
                    return this;
                },
                activate: function() {
                    paper = this;
                },
                clear: function() {
                    for (var i = this.projects.length - 1; i >= 0; i--) this.projects[i].remove();
                    for (var i = this.tools.length - 1; i >= 0; i--) this.tools[i].remove();
                    for (var i = this.palettes.length - 1; i >= 0; i--) this.palettes[i].remove();
                },
                remove: function() {
                    this.clear();
                    delete PaperScope._scopes[this._id];
                },
                statics: new function() {
                    function handleAttribute(name) {
                        name += "Attribute";
                        return function(el, attr) {
                            return el[name](attr) || el[name]("data-paper-" + attr);
                        };
                    }
                    return {
                        _scopes: {},
                        _id: 0,
                        get: function(id) {
                            return this._scopes[id] || null;
                        },
                        getAttribute: handleAttribute("get"),
                        hasAttribute: handleAttribute("has")
                    };
                }()
            });
            var PaperScopeItem = Base.extend(Emitter, {
                initialize: function(activate) {
                    this._scope = paper;
                    this._index = this._scope[this._list].push(this) - 1;
                    if (activate || !this._scope[this._reference]) this.activate();
                },
                activate: function() {
                    if (!this._scope) return false;
                    var prev = this._scope[this._reference];
                    if (prev && prev !== this) prev.emit("deactivate");
                    this._scope[this._reference] = this;
                    this.emit("activate", prev);
                    return true;
                },
                isActive: function() {
                    return this._scope[this._reference] === this;
                },
                remove: function() {
                    if (this._index == null) return false;
                    Base.splice(this._scope[this._list], null, this._index, 1);
                    if (this._scope[this._reference] == this) this._scope[this._reference] = null;
                    this._scope = null;
                    return true;
                }
            });
            var Formatter = Base.extend({
                initialize: function(precision) {
                    this.precision = precision || 5;
                    this.multiplier = Math.pow(10, this.precision);
                },
                number: function(val) {
                    return Math.round(val * this.multiplier) / this.multiplier;
                },
                pair: function(val1, val2, separator) {
                    return this.number(val1) + (separator || ",") + this.number(val2);
                },
                point: function(val, separator) {
                    return this.number(val.x) + (separator || ",") + this.number(val.y);
                },
                size: function(val, separator) {
                    return this.number(val.width) + (separator || ",") + this.number(val.height);
                },
                rectangle: function(val, separator) {
                    return this.point(val, separator) + (separator || ",") + this.size(val, separator);
                }
            });
            Formatter.instance = new Formatter();
            var Numerical = new function() {
                var abscissas = [ [ .5773502691896257 ], [ 0, .7745966692414834 ], [ .33998104358485626, .8611363115940526 ], [ 0, .5384693101056831, .906179845938664 ], [ .2386191860831969, .6612093864662645, .932469514203152 ], [ 0, .4058451513773972, .7415311855993945, .9491079123427585 ], [ .1834346424956498, .525532409916329, .7966664774136267, .9602898564975363 ], [ 0, .3242534234038089, .6133714327005904, .8360311073266358, .9681602395076261 ], [ .14887433898163122, .4333953941292472, .6794095682990244, .8650633666889845, .9739065285171717 ], [ 0, .26954315595234496, .5190961292068118, .7301520055740494, .8870625997680953, .978228658146057 ], [ .1252334085114689, .3678314989981802, .5873179542866175, .7699026741943047, .9041172563704749, .9815606342467192 ], [ 0, .2304583159551348, .44849275103644687, .6423493394403402, .8015780907333099, .9175983992229779, .9841830547185881 ], [ .10805494870734367, .31911236892788974, .5152486363581541, .6872929048116855, .827201315069765, .9284348836635735, .9862838086968123 ], [ 0, .20119409399743451, .3941513470775634, .5709721726085388, .7244177313601701, .8482065834104272, .937273392400706, .9879925180204854 ], [ .09501250983763744, .2816035507792589, .45801677765722737, .6178762444026438, .755404408355003, .8656312023878318, .9445750230732326, .9894009349916499 ] ];
                var weights = [ [ 1 ], [ .8888888888888888, .5555555555555556 ], [ .6521451548625461, .34785484513745385 ], [ .5688888888888889, .47862867049936647, .23692688505618908 ], [ .46791393457269104, .3607615730481386, .17132449237917036 ], [ .4179591836734694, .3818300505051189, .27970539148927664, .1294849661688697 ], [ .362683783378362, .31370664587788727, .22238103445337448, .10122853629037626 ], [ .3302393550012598, .31234707704000286, .26061069640293544, .1806481606948574, .08127438836157441 ], [ .29552422471475287, .26926671930999635, .21908636251598204, .1494513491505806, .06667134430868814 ], [ .2729250867779006, .26280454451024665, .23319376459199048, .18629021092773426, .1255803694649046, .05566856711617366 ], [ .24914704581340277, .2334925365383548, .20316742672306592, .16007832854334622, .10693932599531843, .04717533638651183 ], [ .2325515532308739, .22628318026289723, .2078160475368885, .17814598076194574, .13887351021978725, .09212149983772845, .04048400476531588 ], [ .2152638534631578, .2051984637212956, .18553839747793782, .15720316715819355, .12151857068790319, .08015808715976021, .03511946033175186 ], [ .2025782419255613, .19843148532711158, .1861610000155622, .16626920581699392, .13957067792615432, .10715922046717194, .07036604748810812, .03075324199611727 ], [ .1894506104550685, .18260341504492358, .16915651939500254, .14959598881657674, .12462897125553388, .09515851168249279, .062253523938647894, .027152459411754096 ] ];
                var abs = Math.abs, sqrt = Math.sqrt, pow = Math.pow, TOLERANCE = 1e-6, EPSILON = 1e-12, MACHINE_EPSILON = 1.12e-16;
                return {
                    TOLERANCE: TOLERANCE,
                    EPSILON: EPSILON,
                    MACHINE_EPSILON: MACHINE_EPSILON,
                    KAPPA: 4 * (sqrt(2) - 1) / 3,
                    isZero: function(val) {
                        return abs(val) <= EPSILON;
                    },
                    integrate: function(f, a, b, n) {
                        var x = abscissas[n - 2], w = weights[n - 2], A = (b - a) * .5, B = A + a, i = 0, m = n + 1 >> 1, sum = n & 1 ? w[i++] * f(B) : 0;
                        while (i < m) {
                            var Ax = A * x[i];
                            sum += w[i++] * (f(B + Ax) + f(B - Ax));
                        }
                        return A * sum;
                    },
                    findRoot: function(f, df, x, a, b, n, tolerance) {
                        for (var i = 0; i < n; i++) {
                            var fx = f(x), dx = fx / df(x), nx = x - dx;
                            if (abs(dx) < tolerance) return nx;
                            if (fx > 0) {
                                b = x;
                                x = nx <= a ? (a + b) * .5 : nx;
                            } else {
                                a = x;
                                x = nx >= b ? (a + b) * .5 : nx;
                            }
                        }
                        return x;
                    },
                    solveQuadratic: function(a, b, c, roots, min, max) {
                        var count = 0, x1, x2 = Infinity, B = b, D;
                        b /= 2;
                        D = b * b - a * c;
                        if (D !== 0 && abs(D) < MACHINE_EPSILON) {
                            var pow = Math.pow, gmC = pow(abs(a * b * c), 1 / 3);
                            if (gmC < 1e-8) {
                                var mult = pow(10, abs(Math.floor(Math.log(gmC) * Math.LOG10E)));
                                if (!isFinite(mult)) mult = 0;
                                a *= mult;
                                b *= mult;
                                c *= mult;
                                D = b * b - a * c;
                            }
                        }
                        if (abs(a) < MACHINE_EPSILON) {
                            if (abs(B) < MACHINE_EPSILON) return abs(c) < MACHINE_EPSILON ? -1 : 0;
                            x1 = -c / B;
                        } else {
                            if (D >= -MACHINE_EPSILON) {
                                D = D < 0 ? 0 : D;
                                var R = sqrt(D);
                                if (b >= MACHINE_EPSILON && b <= MACHINE_EPSILON) {
                                    x1 = abs(a) >= abs(c) ? R / a : -c / R;
                                    x2 = -x1;
                                } else {
                                    var q = -(b + (b < 0 ? -1 : 1) * R);
                                    x1 = q / a;
                                    x2 = c / q;
                                }
                            }
                        }
                        if (isFinite(x1) && (min == null || x1 >= min && x1 <= max)) roots[count++] = x1;
                        if (x2 !== x1 && isFinite(x2) && (min == null || x2 >= min && x2 <= max)) roots[count++] = x2;
                        return count;
                    },
                    solveCubic: function(a, b, c, d, roots, min, max) {
                        var x, b1, c2, count = 0;
                        if (a === 0) {
                            a = b;
                            b1 = c;
                            c2 = d;
                            x = Infinity;
                        } else if (d === 0) {
                            b1 = b;
                            c2 = c;
                            x = 0;
                        } else {
                            var ec = 1 + MACHINE_EPSILON, x0, q, qd, t, r, s, tmp;
                            x = -(b / a) / 3;
                            tmp = a * x, b1 = tmp + b, c2 = b1 * x + c, qd = (tmp + b1) * x + c2, q = c2 * x + d;
                            t = q / a;
                            r = pow(abs(t), 1 / 3);
                            s = t < 0 ? -1 : 1;
                            t = -qd / a;
                            r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
                            x0 = x - s * r;
                            if (x0 !== x) {
                                do {
                                    x = x0;
                                    tmp = a * x, b1 = tmp + b, c2 = b1 * x + c, qd = (tmp + b1) * x + c2, q = c2 * x + d;
                                    x0 = qd === 0 ? x : x - q / qd / ec;
                                    if (x0 === x) {
                                        x = x0;
                                        break;
                                    }
                                } while (s * x0 > s * x);
                                if (abs(a) * x * x > abs(d / x)) {
                                    c2 = -d / x;
                                    b1 = (c2 - c) / x;
                                }
                            }
                        }
                        var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
                        if (isFinite(x) && (count === 0 || x !== roots[count - 1]) && (min == null || x >= min && x <= max)) roots[count++] = x;
                        return count;
                    }
                };
            }();
            var UID = {
                _id: 1,
                _pools: {},
                get: function(ctor) {
                    if (ctor) {
                        var name = ctor._class, pool = this._pools[name];
                        if (!pool) pool = this._pools[name] = {
                            _id: 1
                        };
                        return pool._id++;
                    } else {
                        return this._id++;
                    }
                }
            };
            var Point = Base.extend({
                _class: "Point",
                _readIndex: true,
                initialize: function Point(arg0, arg1) {
                    var type = typeof arg0;
                    if (type === "number") {
                        var hasY = typeof arg1 === "number";
                        this.x = arg0;
                        this.y = hasY ? arg1 : arg0;
                        if (this.__read) this.__read = hasY ? 2 : 1;
                    } else if (type === "undefined" || arg0 === null) {
                        this.x = this.y = 0;
                        if (this.__read) this.__read = arg0 === null ? 1 : 0;
                    } else {
                        if (Array.isArray(arg0)) {
                            this.x = arg0[0];
                            this.y = arg0.length > 1 ? arg0[1] : arg0[0];
                        } else if (arg0.x != null) {
                            this.x = arg0.x;
                            this.y = arg0.y;
                        } else if (arg0.width != null) {
                            this.x = arg0.width;
                            this.y = arg0.height;
                        } else if (arg0.angle != null) {
                            this.x = arg0.length;
                            this.y = 0;
                            this.setAngle(arg0.angle);
                        } else {
                            this.x = this.y = 0;
                            if (this.__read) this.__read = 0;
                        }
                        if (this.__read) this.__read = 1;
                    }
                },
                set: function(x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                },
                equals: function(point) {
                    return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;
                },
                clone: function() {
                    return new Point(this.x, this.y);
                },
                toString: function() {
                    var f = Formatter.instance;
                    return "{ x: " + f.number(this.x) + ", y: " + f.number(this.y) + " }";
                },
                _serialize: function(options) {
                    var f = options.formatter;
                    return [ f.number(this.x), f.number(this.y) ];
                },
                getLength: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                },
                setLength: function(length) {
                    if (this.isZero()) {
                        var angle = this._angle || 0;
                        this.set(Math.cos(angle) * length, Math.sin(angle) * length);
                    } else {
                        var scale = length / this.getLength();
                        if (Numerical.isZero(scale)) this.getAngle();
                        this.set(this.x * scale, this.y * scale);
                    }
                },
                getAngle: function() {
                    return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
                },
                setAngle: function(angle) {
                    this.setAngleInRadians.call(this, angle * Math.PI / 180);
                },
                getAngleInDegrees: "#getAngle",
                setAngleInDegrees: "#setAngle",
                getAngleInRadians: function() {
                    if (!arguments.length) {
                        return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
                    } else {
                        var point = Point.read(arguments), div = this.getLength() * point.getLength();
                        if (Numerical.isZero(div)) {
                            return NaN;
                        } else {
                            var a = this.dot(point) / div;
                            return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
                        }
                    }
                },
                setAngleInRadians: function(angle) {
                    this._angle = angle;
                    if (!this.isZero()) {
                        var length = this.getLength();
                        this.set(Math.cos(angle) * length, Math.sin(angle) * length);
                    }
                },
                getQuadrant: function() {
                    return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
                }
            }, {
                beans: false,
                getDirectedAngle: function() {
                    var point = Point.read(arguments);
                    return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
                },
                getDistance: function() {
                    var point = Point.read(arguments), x = point.x - this.x, y = point.y - this.y, d = x * x + y * y, squared = Base.read(arguments);
                    return squared ? d : Math.sqrt(d);
                },
                normalize: function(length) {
                    if (length === undefined) length = 1;
                    var current = this.getLength(), scale = current !== 0 ? length / current : 0, point = new Point(this.x * scale, this.y * scale);
                    if (scale >= 0) point._angle = this._angle;
                    return point;
                },
                rotate: function(angle, center) {
                    if (angle === 0) return this.clone();
                    angle = angle * Math.PI / 180;
                    var point = center ? this.subtract(center) : this, s = Math.sin(angle), c = Math.cos(angle);
                    point = new Point(point.x * c - point.y * s, point.x * s + point.y * c);
                    return center ? point.add(center) : point;
                },
                transform: function(matrix) {
                    return matrix ? matrix._transformPoint(this) : this;
                },
                add: function() {
                    var point = Point.read(arguments);
                    return new Point(this.x + point.x, this.y + point.y);
                },
                subtract: function() {
                    var point = Point.read(arguments);
                    return new Point(this.x - point.x, this.y - point.y);
                },
                multiply: function() {
                    var point = Point.read(arguments);
                    return new Point(this.x * point.x, this.y * point.y);
                },
                divide: function() {
                    var point = Point.read(arguments);
                    return new Point(this.x / point.x, this.y / point.y);
                },
                modulo: function() {
                    var point = Point.read(arguments);
                    return new Point(this.x % point.x, this.y % point.y);
                },
                negate: function() {
                    return new Point(-this.x, -this.y);
                },
                isInside: function() {
                    return Rectangle.read(arguments).contains(this);
                },
                isClose: function(point, tolerance) {
                    return this.getDistance(point) < tolerance;
                },
                isCollinear: function(point) {
                    return Math.abs(this.cross(point)) < 1e-6;
                },
                isColinear: "#isCollinear",
                isOrthogonal: function(point) {
                    return Math.abs(this.dot(point)) < 1e-6;
                },
                isZero: function() {
                    return Numerical.isZero(this.x) && Numerical.isZero(this.y);
                },
                isNaN: function() {
                    return isNaN(this.x) || isNaN(this.y);
                },
                dot: function() {
                    var point = Point.read(arguments);
                    return this.x * point.x + this.y * point.y;
                },
                cross: function() {
                    var point = Point.read(arguments);
                    return this.x * point.y - this.y * point.x;
                },
                project: function() {
                    var point = Point.read(arguments);
                    if (point.isZero()) {
                        return new Point(0, 0);
                    } else {
                        var scale = this.dot(point) / point.dot(point);
                        return new Point(point.x * scale, point.y * scale);
                    }
                },
                statics: {
                    min: function() {
                        var point1 = Point.read(arguments), point2 = Point.read(arguments);
                        return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
                    },
                    max: function() {
                        var point1 = Point.read(arguments), point2 = Point.read(arguments);
                        return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
                    },
                    random: function() {
                        return new Point(Math.random(), Math.random());
                    }
                }
            }, Base.each([ "round", "ceil", "floor", "abs" ], function(name) {
                var op = Math[name];
                this[name] = function() {
                    return new Point(op(this.x), op(this.y));
                };
            }, {}));
            var LinkedPoint = Point.extend({
                initialize: function Point(x, y, owner, setter) {
                    this._x = x;
                    this._y = y;
                    this._owner = owner;
                    this._setter = setter;
                },
                set: function(x, y, _dontNotify) {
                    this._x = x;
                    this._y = y;
                    if (!_dontNotify) this._owner[this._setter](this);
                    return this;
                },
                getX: function() {
                    return this._x;
                },
                setX: function(x) {
                    this._x = x;
                    this._owner[this._setter](this);
                },
                getY: function() {
                    return this._y;
                },
                setY: function(y) {
                    this._y = y;
                    this._owner[this._setter](this);
                }
            });
            var Size = Base.extend({
                _class: "Size",
                _readIndex: true,
                initialize: function Size(arg0, arg1) {
                    var type = typeof arg0;
                    if (type === "number") {
                        var hasHeight = typeof arg1 === "number";
                        this.width = arg0;
                        this.height = hasHeight ? arg1 : arg0;
                        if (this.__read) this.__read = hasHeight ? 2 : 1;
                    } else if (type === "undefined" || arg0 === null) {
                        this.width = this.height = 0;
                        if (this.__read) this.__read = arg0 === null ? 1 : 0;
                    } else {
                        if (Array.isArray(arg0)) {
                            this.width = arg0[0];
                            this.height = arg0.length > 1 ? arg0[1] : arg0[0];
                        } else if (arg0.width != null) {
                            this.width = arg0.width;
                            this.height = arg0.height;
                        } else if (arg0.x != null) {
                            this.width = arg0.x;
                            this.height = arg0.y;
                        } else {
                            this.width = this.height = 0;
                            if (this.__read) this.__read = 0;
                        }
                        if (this.__read) this.__read = 1;
                    }
                },
                set: function(width, height) {
                    this.width = width;
                    this.height = height;
                    return this;
                },
                equals: function(size) {
                    return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;
                },
                clone: function() {
                    return new Size(this.width, this.height);
                },
                toString: function() {
                    var f = Formatter.instance;
                    return "{ width: " + f.number(this.width) + ", height: " + f.number(this.height) + " }";
                },
                _serialize: function(options) {
                    var f = options.formatter;
                    return [ f.number(this.width), f.number(this.height) ];
                },
                add: function() {
                    var size = Size.read(arguments);
                    return new Size(this.width + size.width, this.height + size.height);
                },
                subtract: function() {
                    var size = Size.read(arguments);
                    return new Size(this.width - size.width, this.height - size.height);
                },
                multiply: function() {
                    var size = Size.read(arguments);
                    return new Size(this.width * size.width, this.height * size.height);
                },
                divide: function() {
                    var size = Size.read(arguments);
                    return new Size(this.width / size.width, this.height / size.height);
                },
                modulo: function() {
                    var size = Size.read(arguments);
                    return new Size(this.width % size.width, this.height % size.height);
                },
                negate: function() {
                    return new Size(-this.width, -this.height);
                },
                isZero: function() {
                    return Numerical.isZero(this.width) && Numerical.isZero(this.height);
                },
                isNaN: function() {
                    return isNaN(this.width) || isNaN(this.height);
                },
                statics: {
                    min: function(size1, size2) {
                        return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));
                    },
                    max: function(size1, size2) {
                        return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));
                    },
                    random: function() {
                        return new Size(Math.random(), Math.random());
                    }
                }
            }, Base.each([ "round", "ceil", "floor", "abs" ], function(name) {
                var op = Math[name];
                this[name] = function() {
                    return new Size(op(this.width), op(this.height));
                };
            }, {}));
            var LinkedSize = Size.extend({
                initialize: function Size(width, height, owner, setter) {
                    this._width = width;
                    this._height = height;
                    this._owner = owner;
                    this._setter = setter;
                },
                set: function(width, height, _dontNotify) {
                    this._width = width;
                    this._height = height;
                    if (!_dontNotify) this._owner[this._setter](this);
                    return this;
                },
                getWidth: function() {
                    return this._width;
                },
                setWidth: function(width) {
                    this._width = width;
                    this._owner[this._setter](this);
                },
                getHeight: function() {
                    return this._height;
                },
                setHeight: function(height) {
                    this._height = height;
                    this._owner[this._setter](this);
                }
            });
            var Rectangle = Base.extend({
                _class: "Rectangle",
                _readIndex: true,
                beans: true,
                initialize: function Rectangle(arg0, arg1, arg2, arg3) {
                    var type = typeof arg0, read = 0;
                    if (type === "number") {
                        this.x = arg0;
                        this.y = arg1;
                        this.width = arg2;
                        this.height = arg3;
                        read = 4;
                    } else if (type === "undefined" || arg0 === null) {
                        this.x = this.y = this.width = this.height = 0;
                        read = arg0 === null ? 1 : 0;
                    } else if (arguments.length === 1) {
                        if (Array.isArray(arg0)) {
                            this.x = arg0[0];
                            this.y = arg0[1];
                            this.width = arg0[2];
                            this.height = arg0[3];
                            read = 1;
                        } else if (arg0.x !== undefined || arg0.width !== undefined) {
                            this.x = arg0.x || 0;
                            this.y = arg0.y || 0;
                            this.width = arg0.width || 0;
                            this.height = arg0.height || 0;
                            read = 1;
                        } else if (arg0.from === undefined && arg0.to === undefined) {
                            this.x = this.y = this.width = this.height = 0;
                            this._set(arg0);
                            read = 1;
                        }
                    }
                    if (!read) {
                        var point = Point.readNamed(arguments, "from"), next = Base.peek(arguments);
                        this.x = point.x;
                        this.y = point.y;
                        if (next && next.x !== undefined || Base.hasNamed(arguments, "to")) {
                            var to = Point.readNamed(arguments, "to");
                            this.width = to.x - point.x;
                            this.height = to.y - point.y;
                            if (this.width < 0) {
                                this.x = to.x;
                                this.width = -this.width;
                            }
                            if (this.height < 0) {
                                this.y = to.y;
                                this.height = -this.height;
                            }
                        } else {
                            var size = Size.read(arguments);
                            this.width = size.width;
                            this.height = size.height;
                        }
                        read = arguments.__index;
                    }
                    if (this.__read) this.__read = read;
                },
                set: function(x, y, width, height) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    return this;
                },
                clone: function() {
                    return new Rectangle(this.x, this.y, this.width, this.height);
                },
                equals: function(rect) {
                    var rt = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;
                    return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || false;
                },
                toString: function() {
                    var f = Formatter.instance;
                    return "{ x: " + f.number(this.x) + ", y: " + f.number(this.y) + ", width: " + f.number(this.width) + ", height: " + f.number(this.height) + " }";
                },
                _serialize: function(options) {
                    var f = options.formatter;
                    return [ f.number(this.x), f.number(this.y), f.number(this.width), f.number(this.height) ];
                },
                getPoint: function(_dontLink) {
                    var ctor = _dontLink ? Point : LinkedPoint;
                    return new ctor(this.x, this.y, this, "setPoint");
                },
                setPoint: function() {
                    var point = Point.read(arguments);
                    this.x = point.x;
                    this.y = point.y;
                },
                getSize: function(_dontLink) {
                    var ctor = _dontLink ? Size : LinkedSize;
                    return new ctor(this.width, this.height, this, "setSize");
                },
                setSize: function() {
                    var size = Size.read(arguments);
                    if (this._fixX) this.x += (this.width - size.width) * this._fixX;
                    if (this._fixY) this.y += (this.height - size.height) * this._fixY;
                    this.width = size.width;
                    this.height = size.height;
                    this._fixW = 1;
                    this._fixH = 1;
                },
                getLeft: function() {
                    return this.x;
                },
                setLeft: function(left) {
                    if (!this._fixW) this.width -= left - this.x;
                    this.x = left;
                    this._fixX = 0;
                },
                getTop: function() {
                    return this.y;
                },
                setTop: function(top) {
                    if (!this._fixH) this.height -= top - this.y;
                    this.y = top;
                    this._fixY = 0;
                },
                getRight: function() {
                    return this.x + this.width;
                },
                setRight: function(right) {
                    if (this._fixX !== undefined && this._fixX !== 1) this._fixW = 0;
                    if (this._fixW) this.x = right - this.width; else this.width = right - this.x;
                    this._fixX = 1;
                },
                getBottom: function() {
                    return this.y + this.height;
                },
                setBottom: function(bottom) {
                    if (this._fixY !== undefined && this._fixY !== 1) this._fixH = 0;
                    if (this._fixH) this.y = bottom - this.height; else this.height = bottom - this.y;
                    this._fixY = 1;
                },
                getCenterX: function() {
                    return this.x + this.width * .5;
                },
                setCenterX: function(x) {
                    this.x = x - this.width * .5;
                    this._fixX = .5;
                },
                getCenterY: function() {
                    return this.y + this.height * .5;
                },
                setCenterY: function(y) {
                    this.y = y - this.height * .5;
                    this._fixY = .5;
                },
                getCenter: function(_dontLink) {
                    var ctor = _dontLink ? Point : LinkedPoint;
                    return new ctor(this.getCenterX(), this.getCenterY(), this, "setCenter");
                },
                setCenter: function() {
                    var point = Point.read(arguments);
                    this.setCenterX(point.x);
                    this.setCenterY(point.y);
                    return this;
                },
                getArea: function() {
                    return this.width * this.height;
                },
                isEmpty: function() {
                    return this.width === 0 || this.height === 0;
                },
                contains: function(arg) {
                    return arg && arg.width !== undefined || (Array.isArray(arg) ? arg : arguments).length == 4 ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));
                },
                _containsPoint: function(point) {
                    var x = point.x, y = point.y;
                    return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
                },
                _containsRectangle: function(rect) {
                    var x = rect.x, y = rect.y;
                    return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height;
                },
                intersects: function() {
                    var rect = Rectangle.read(arguments);
                    return rect.x + rect.width > this.x && rect.y + rect.height > this.y && rect.x < this.x + this.width && rect.y < this.y + this.height;
                },
                touches: function() {
                    var rect = Rectangle.read(arguments);
                    return rect.x + rect.width >= this.x && rect.y + rect.height >= this.y && rect.x <= this.x + this.width && rect.y <= this.y + this.height;
                },
                intersect: function() {
                    var rect = Rectangle.read(arguments), x1 = Math.max(this.x, rect.x), y1 = Math.max(this.y, rect.y), x2 = Math.min(this.x + this.width, rect.x + rect.width), y2 = Math.min(this.y + this.height, rect.y + rect.height);
                    return new Rectangle(x1, y1, x2 - x1, y2 - y1);
                },
                unite: function() {
                    var rect = Rectangle.read(arguments), x1 = Math.min(this.x, rect.x), y1 = Math.min(this.y, rect.y), x2 = Math.max(this.x + this.width, rect.x + rect.width), y2 = Math.max(this.y + this.height, rect.y + rect.height);
                    return new Rectangle(x1, y1, x2 - x1, y2 - y1);
                },
                include: function() {
                    var point = Point.read(arguments);
                    var x1 = Math.min(this.x, point.x), y1 = Math.min(this.y, point.y), x2 = Math.max(this.x + this.width, point.x), y2 = Math.max(this.y + this.height, point.y);
                    return new Rectangle(x1, y1, x2 - x1, y2 - y1);
                },
                expand: function() {
                    var amount = Size.read(arguments), hor = amount.width, ver = amount.height;
                    return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);
                },
                scale: function(hor, ver) {
                    return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height);
                }
            }, Base.each([ [ "Top", "Left" ], [ "Top", "Right" ], [ "Bottom", "Left" ], [ "Bottom", "Right" ], [ "Left", "Center" ], [ "Top", "Center" ], [ "Right", "Center" ], [ "Bottom", "Center" ] ], function(parts, index) {
                var part = parts.join("");
                var xFirst = /^[RL]/.test(part);
                if (index >= 4) parts[1] += xFirst ? "Y" : "X";
                var x = parts[xFirst ? 0 : 1], y = parts[xFirst ? 1 : 0], getX = "get" + x, getY = "get" + y, setX = "set" + x, setY = "set" + y, get = "get" + part, set = "set" + part;
                this[get] = function(_dontLink) {
                    var ctor = _dontLink ? Point : LinkedPoint;
                    return new ctor(this[getX](), this[getY](), this, set);
                };
                this[set] = function() {
                    var point = Point.read(arguments);
                    this[setX](point.x);
                    this[setY](point.y);
                };
            }, {
                beans: true
            }));
            var LinkedRectangle = Rectangle.extend({
                initialize: function Rectangle(x, y, width, height, owner, setter) {
                    this.set(x, y, width, height, true);
                    this._owner = owner;
                    this._setter = setter;
                },
                set: function(x, y, width, height, _dontNotify) {
                    this._x = x;
                    this._y = y;
                    this._width = width;
                    this._height = height;
                    if (!_dontNotify) this._owner[this._setter](this);
                    return this;
                }
            }, new function() {
                var proto = Rectangle.prototype;
                return Base.each([ "x", "y", "width", "height" ], function(key) {
                    var part = Base.capitalize(key);
                    var internal = "_" + key;
                    this["get" + part] = function() {
                        return this[internal];
                    };
                    this["set" + part] = function(value) {
                        this[internal] = value;
                        if (!this._dontNotify) this._owner[this._setter](this);
                    };
                }, Base.each([ "Point", "Size", "Center", "Left", "Top", "Right", "Bottom", "CenterX", "CenterY", "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter" ], function(key) {
                    var name = "set" + key;
                    this[name] = function() {
                        this._dontNotify = true;
                        proto[name].apply(this, arguments);
                        this._dontNotify = false;
                        this._owner[this._setter](this);
                    };
                }, {
                    isSelected: function() {
                        return this._owner._boundsSelected;
                    },
                    setSelected: function(selected) {
                        var owner = this._owner;
                        if (owner.setSelected) {
                            owner._boundsSelected = selected;
                            owner.setSelected(selected || owner._selectedSegmentState > 0);
                        }
                    }
                }));
            }());
            var Matrix = Base.extend({
                _class: "Matrix",
                initialize: function Matrix(arg) {
                    var count = arguments.length, ok = true;
                    if (count === 6) {
                        this.set.apply(this, arguments);
                    } else if (count === 1) {
                        if (arg instanceof Matrix) {
                            this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
                        } else if (Array.isArray(arg)) {
                            this.set.apply(this, arg);
                        } else {
                            ok = false;
                        }
                    } else if (count === 0) {
                        this.reset();
                    } else {
                        ok = false;
                    }
                    if (!ok) throw new Error("Unsupported matrix parameters");
                },
                set: function(a, c, b, d, tx, ty, _dontNotify) {
                    this._a = a;
                    this._c = c;
                    this._b = b;
                    this._d = d;
                    this._tx = tx;
                    this._ty = ty;
                    if (!_dontNotify) this._changed();
                    return this;
                },
                _serialize: function(options) {
                    return Base.serialize(this.getValues(), options);
                },
                _changed: function() {
                    var owner = this._owner;
                    if (owner) {
                        if (owner._applyMatrix) {
                            owner.transform(null, true);
                        } else {
                            owner._changed(9);
                        }
                    }
                },
                clone: function() {
                    return new Matrix(this._a, this._c, this._b, this._d, this._tx, this._ty);
                },
                equals: function(mx) {
                    return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty || false;
                },
                toString: function() {
                    var f = Formatter.instance;
                    return "[[" + [ f.number(this._a), f.number(this._b), f.number(this._tx) ].join(", ") + "], [" + [ f.number(this._c), f.number(this._d), f.number(this._ty) ].join(", ") + "]]";
                },
                reset: function(_dontNotify) {
                    this._a = this._d = 1;
                    this._c = this._b = this._tx = this._ty = 0;
                    if (!_dontNotify) this._changed();
                    return this;
                },
                apply: function(recursively, _setApplyMatrix) {
                    var owner = this._owner;
                    if (owner) {
                        owner.transform(null, true, Base.pick(recursively, true), _setApplyMatrix);
                        return this.isIdentity();
                    }
                    return false;
                },
                translate: function() {
                    var point = Point.read(arguments), x = point.x, y = point.y;
                    this._tx += x * this._a + y * this._b;
                    this._ty += x * this._c + y * this._d;
                    this._changed();
                    return this;
                },
                scale: function() {
                    var scale = Point.read(arguments), center = Point.read(arguments, 0, {
                        readNull: true
                    });
                    if (center) this.translate(center);
                    this._a *= scale.x;
                    this._c *= scale.x;
                    this._b *= scale.y;
                    this._d *= scale.y;
                    if (center) this.translate(center.negate());
                    this._changed();
                    return this;
                },
                rotate: function(angle) {
                    angle *= Math.PI / 180;
                    var center = Point.read(arguments, 1), x = center.x, y = center.y, cos = Math.cos(angle), sin = Math.sin(angle), tx = x - x * cos + y * sin, ty = y - x * sin - y * cos, a = this._a, b = this._b, c = this._c, d = this._d;
                    this._a = cos * a + sin * b;
                    this._b = -sin * a + cos * b;
                    this._c = cos * c + sin * d;
                    this._d = -sin * c + cos * d;
                    this._tx += tx * a + ty * b;
                    this._ty += tx * c + ty * d;
                    this._changed();
                    return this;
                },
                shear: function() {
                    var shear = Point.read(arguments), center = Point.read(arguments, 0, {
                        readNull: true
                    });
                    if (center) this.translate(center);
                    var a = this._a, c = this._c;
                    this._a += shear.y * this._b;
                    this._c += shear.y * this._d;
                    this._b += shear.x * a;
                    this._d += shear.x * c;
                    if (center) this.translate(center.negate());
                    this._changed();
                    return this;
                },
                skew: function() {
                    var skew = Point.read(arguments), center = Point.read(arguments, 0, {
                        readNull: true
                    }), toRadians = Math.PI / 180, shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
                    return this.shear(shear, center);
                },
                concatenate: function(mx) {
                    var a1 = this._a, b1 = this._b, c1 = this._c, d1 = this._d, a2 = mx._a, b2 = mx._b, c2 = mx._c, d2 = mx._d, tx2 = mx._tx, ty2 = mx._ty;
                    this._a = a2 * a1 + c2 * b1;
                    this._b = b2 * a1 + d2 * b1;
                    this._c = a2 * c1 + c2 * d1;
                    this._d = b2 * c1 + d2 * d1;
                    this._tx += tx2 * a1 + ty2 * b1;
                    this._ty += tx2 * c1 + ty2 * d1;
                    this._changed();
                    return this;
                },
                preConcatenate: function(mx) {
                    var a1 = this._a, b1 = this._b, c1 = this._c, d1 = this._d, tx1 = this._tx, ty1 = this._ty, a2 = mx._a, b2 = mx._b, c2 = mx._c, d2 = mx._d, tx2 = mx._tx, ty2 = mx._ty;
                    this._a = a2 * a1 + b2 * c1;
                    this._b = a2 * b1 + b2 * d1;
                    this._c = c2 * a1 + d2 * c1;
                    this._d = c2 * b1 + d2 * d1;
                    this._tx = a2 * tx1 + b2 * ty1 + tx2;
                    this._ty = c2 * tx1 + d2 * ty1 + ty2;
                    this._changed();
                    return this;
                },
                chain: function(mx) {
                    var a1 = this._a, b1 = this._b, c1 = this._c, d1 = this._d, tx1 = this._tx, ty1 = this._ty, a2 = mx._a, b2 = mx._b, c2 = mx._c, d2 = mx._d, tx2 = mx._tx, ty2 = mx._ty;
                    return new Matrix(a2 * a1 + c2 * b1, a2 * c1 + c2 * d1, b2 * a1 + d2 * b1, b2 * c1 + d2 * d1, tx1 + tx2 * a1 + ty2 * b1, ty1 + tx2 * c1 + ty2 * d1);
                },
                isIdentity: function() {
                    return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
                },
                orNullIfIdentity: function() {
                    return this.isIdentity() ? null : this;
                },
                isInvertible: function() {
                    return !!this._getDeterminant();
                },
                isSingular: function() {
                    return !this._getDeterminant();
                },
                transform: function(src, dst, count) {
                    return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);
                },
                _transformPoint: function(point, dest, _dontNotify) {
                    var x = point.x, y = point.y;
                    if (!dest) dest = new Point();
                    return dest.set(x * this._a + y * this._b + this._tx, x * this._c + y * this._d + this._ty, _dontNotify);
                },
                _transformCoordinates: function(src, dst, count) {
                    var i = 0, j = 0, max = 2 * count;
                    while (i < max) {
                        var x = src[i++], y = src[i++];
                        dst[j++] = x * this._a + y * this._b + this._tx;
                        dst[j++] = x * this._c + y * this._d + this._ty;
                    }
                    return dst;
                },
                _transformCorners: function(rect) {
                    var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
                    return this._transformCoordinates(coords, coords, 4);
                },
                _transformBounds: function(bounds, dest, _dontNotify) {
                    var coords = this._transformCorners(bounds), min = coords.slice(0, 2), max = coords.slice();
                    for (var i = 2; i < 8; i++) {
                        var val = coords[i], j = i & 1;
                        if (val < min[j]) min[j] = val; else if (val > max[j]) max[j] = val;
                    }
                    if (!dest) dest = new Rectangle();
                    return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);
                },
                inverseTransform: function() {
                    return this._inverseTransform(Point.read(arguments));
                },
                _getDeterminant: function() {
                    var det = this._a * this._d - this._b * this._c;
                    return isFinite(det) && !Numerical.isZero(det) && isFinite(this._tx) && isFinite(this._ty) ? det : null;
                },
                _inverseTransform: function(point, dest, _dontNotify) {
                    var det = this._getDeterminant();
                    if (!det) return null;
                    var x = point.x - this._tx, y = point.y - this._ty;
                    if (!dest) dest = new Point();
                    return dest.set((x * this._d - y * this._b) / det, (y * this._a - x * this._c) / det, _dontNotify);
                },
                decompose: function() {
                    var a = this._a, b = this._b, c = this._c, d = this._d;
                    if (Numerical.isZero(a * d - b * c)) return null;
                    var scaleX = Math.sqrt(a * a + b * b);
                    a /= scaleX;
                    b /= scaleX;
                    var shear = a * c + b * d;
                    c -= a * shear;
                    d -= b * shear;
                    var scaleY = Math.sqrt(c * c + d * d);
                    c /= scaleY;
                    d /= scaleY;
                    shear /= scaleY;
                    if (a * d < b * c) {
                        a = -a;
                        b = -b;
                        shear = -shear;
                        scaleX = -scaleX;
                    }
                    return {
                        scaling: new Point(scaleX, scaleY),
                        rotation: -Math.atan2(b, a) * 180 / Math.PI,
                        shearing: shear
                    };
                },
                getValues: function() {
                    return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
                },
                getTranslation: function() {
                    return new Point(this._tx, this._ty);
                },
                getScaling: function() {
                    return (this.decompose() || {}).scaling;
                },
                getRotation: function() {
                    return (this.decompose() || {}).rotation;
                },
                inverted: function() {
                    var det = this._getDeterminant();
                    return det && new Matrix(this._d / det, -this._c / det, -this._b / det, this._a / det, (this._b * this._ty - this._d * this._tx) / det, (this._c * this._tx - this._a * this._ty) / det);
                },
                shiftless: function() {
                    return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
                },
                applyToContext: function(ctx) {
                    ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
                }
            }, Base.each([ "a", "c", "b", "d", "tx", "ty" ], function(name) {
                var part = Base.capitalize(name), prop = "_" + name;
                this["get" + part] = function() {
                    return this[prop];
                };
                this["set" + part] = function(value) {
                    this[prop] = value;
                    this._changed();
                };
            }, {}));
            var Line = Base.extend({
                _class: "Line",
                initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
                    var asVector = false;
                    if (arguments.length >= 4) {
                        this._px = arg0;
                        this._py = arg1;
                        this._vx = arg2;
                        this._vy = arg3;
                        asVector = arg4;
                    } else {
                        this._px = arg0.x;
                        this._py = arg0.y;
                        this._vx = arg1.x;
                        this._vy = arg1.y;
                        asVector = arg2;
                    }
                    if (!asVector) {
                        this._vx -= this._px;
                        this._vy -= this._py;
                    }
                },
                getPoint: function() {
                    return new Point(this._px, this._py);
                },
                getVector: function() {
                    return new Point(this._vx, this._vy);
                },
                getLength: function() {
                    return this.getVector().getLength();
                },
                intersect: function(line, isInfinite) {
                    return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);
                },
                getSide: function(point) {
                    return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true);
                },
                getDistance: function(point) {
                    return Math.abs(Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true));
                },
                statics: {
                    intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector, isInfinite) {
                        if (!asVector) {
                            avx -= apx;
                            avy -= apy;
                            bvx -= bpx;
                            bvy -= bpy;
                        }
                        var cross = avx * bvy - avy * bvx;
                        if (!Numerical.isZero(cross)) {
                            var dx = apx - bpx, dy = apy - bpy, ta = (bvx * dy - bvy * dx) / cross, tb = (avx * dy - avy * dx) / cross;
                            if (isInfinite || 0 <= ta && ta <= 1 && 0 <= tb && tb <= 1) return new Point(apx + ta * avx, apy + ta * avy);
                        }
                    },
                    getSide: function(px, py, vx, vy, x, y, asVector) {
                        if (!asVector) {
                            vx -= px;
                            vy -= py;
                        }
                        var v2x = x - px, v2y = y - py, ccw = v2x * vy - v2y * vx;
                        if (ccw === 0) {
                            ccw = v2x * vx + v2y * vy;
                            if (ccw > 0) {
                                v2x -= vx;
                                v2y -= vy;
                                ccw = v2x * vx + v2y * vy;
                                if (ccw < 0) ccw = 0;
                            }
                        }
                        return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
                    },
                    getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
                        if (!asVector) {
                            vx -= px;
                            vy -= py;
                        }
                        return Numerical.isZero(vx) ? vy >= 0 ? px - x : x - px : Numerical.isZero(vy) ? vx >= 0 ? y - py : py - y : (vx * (y - py) - vy * (x - px)) / Math.sqrt(vx * vx + vy * vy);
                    }
                }
            });
            var Project = PaperScopeItem.extend({
                _class: "Project",
                _list: "projects",
                _reference: "project",
                initialize: function Project(element) {
                    PaperScopeItem.call(this, true);
                    this.layers = [];
                    this._activeLayer = null;
                    this.symbols = [];
                    this._currentStyle = new Style(null, null, this);
                    this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));
                    this._selectedItems = {};
                    this._selectedItemCount = 0;
                    this._updateVersion = 0;
                },
                _serialize: function(options, dictionary) {
                    return Base.serialize(this.layers, options, true, dictionary);
                },
                clear: function() {
                    for (var i = this.layers.length - 1; i >= 0; i--) this.layers[i].remove();
                    this.symbols = [];
                },
                isEmpty: function() {
                    return this.layers.length === 0;
                },
                remove: function remove() {
                    if (!remove.base.call(this)) return false;
                    if (this._view) this._view.remove();
                    return true;
                },
                getView: function() {
                    return this._view;
                },
                getCurrentStyle: function() {
                    return this._currentStyle;
                },
                setCurrentStyle: function(style) {
                    this._currentStyle.initialize(style);
                },
                getIndex: function() {
                    return this._index;
                },
                getOptions: function() {
                    return this._scope.settings;
                },
                getActiveLayer: function() {
                    return this._activeLayer || new Layer({
                        project: this
                    });
                },
                getSelectedItems: function() {
                    var items = [];
                    for (var id in this._selectedItems) {
                        var item = this._selectedItems[id];
                        if (item.isInserted()) items.push(item);
                    }
                    return items;
                },
                insertChild: function(index, item, _preserve) {
                    if (item instanceof Layer) {
                        item._remove(false, true);
                        Base.splice(this.layers, [ item ], index, 0);
                        item._setProject(this, true);
                        if (this._changes) item._changed(5);
                        if (!this._activeLayer) this._activeLayer = item;
                    } else if (item instanceof Item) {
                        (this._activeLayer || this.insertChild(index, new Layer(Item.NO_INSERT))).insertChild(index, item, _preserve);
                    } else {
                        item = null;
                    }
                    return item;
                },
                addChild: function(item, _preserve) {
                    return this.insertChild(undefined, item, _preserve);
                },
                _updateSelection: function(item) {
                    var id = item._id, selectedItems = this._selectedItems;
                    if (item._selected) {
                        if (selectedItems[id] !== item) {
                            this._selectedItemCount++;
                            selectedItems[id] = item;
                        }
                    } else if (selectedItems[id] === item) {
                        this._selectedItemCount--;
                        delete selectedItems[id];
                    }
                },
                selectAll: function() {
                    var layers = this.layers;
                    for (var i = 0, l = layers.length; i < l; i++) layers[i].setFullySelected(true);
                },
                deselectAll: function() {
                    var selectedItems = this._selectedItems;
                    for (var i in selectedItems) selectedItems[i].setFullySelected(false);
                },
                hitTest: function() {
                    var point = Point.read(arguments), options = HitResult.getOptions(Base.read(arguments));
                    for (var i = this.layers.length - 1; i >= 0; i--) {
                        var res = this.layers[i]._hitTest(point, options);
                        if (res) return res;
                    }
                    return null;
                },
                getItems: function(match) {
                    return Item._getItems(this.layers, match);
                },
                getItem: function(match) {
                    return Item._getItems(this.layers, match, null, null, true)[0] || null;
                },
                importJSON: function(json) {
                    this.activate();
                    var layer = this._activeLayer;
                    return Base.importJSON(json, layer && layer.isEmpty() && layer);
                },
                draw: function(ctx, matrix, pixelRatio) {
                    this._updateVersion++;
                    ctx.save();
                    matrix.applyToContext(ctx);
                    var param = new Base({
                        offset: new Point(0, 0),
                        pixelRatio: pixelRatio,
                        viewMatrix: matrix.isIdentity() ? null : matrix,
                        matrices: [ new Matrix() ],
                        updateMatrix: true
                    });
                    for (var i = 0, layers = this.layers, l = layers.length; i < l; i++) layers[i].draw(ctx, param);
                    ctx.restore();
                    if (this._selectedItemCount > 0) {
                        ctx.save();
                        ctx.strokeWidth = 1;
                        var items = this._selectedItems, size = this._scope.settings.handleSize, version = this._updateVersion;
                        for (var id in items) items[id]._drawSelection(ctx, matrix, size, items, version);
                        ctx.restore();
                    }
                }
            });
            var Symbol = Base.extend({
                _class: "Symbol",
                initialize: function Symbol(item, dontCenter) {
                    this._id = UID.get();
                    this.project = paper.project;
                    this.project.symbols.push(this);
                    if (item) this.setDefinition(item, dontCenter);
                },
                _serialize: function(options, dictionary) {
                    return dictionary.add(this, function() {
                        return Base.serialize([ this._class, this._definition ], options, false, dictionary);
                    });
                },
                _changed: function(flags) {
                    if (flags & 8) {
                        Item._clearBoundsCache(this);
                    }
                    if (flags & 1) {
                        this.project._needsUpdate = true;
                    }
                },
                getDefinition: function() {
                    return this._definition;
                },
                setDefinition: function(item, _dontCenter) {
                    if (item._parentSymbol) item = item.clone();
                    if (this._definition) this._definition._parentSymbol = null;
                    this._definition = item;
                    item.remove();
                    item.setSelected(false);
                    if (!_dontCenter) item.setPosition(new Point());
                    item._parentSymbol = this;
                    this._changed(9);
                },
                place: function(position) {
                    return new PlacedSymbol(this, position);
                },
                clone: function() {
                    return new Symbol(this._definition.clone(false));
                },
                equals: function(symbol) {
                    return symbol === this || symbol && this.definition.equals(symbol.definition) || false;
                }
            });
            var Item = Base.extend(Emitter, {
                statics: {
                    extend: function extend(src) {
                        if (src._serializeFields) src._serializeFields = new Base(this.prototype._serializeFields, src._serializeFields);
                        return extend.base.apply(this, arguments);
                    },
                    NO_INSERT: {
                        insert: false
                    }
                },
                _class: "Item",
                _applyMatrix: true,
                _canApplyMatrix: true,
                _boundsSelected: false,
                _selectChildren: false,
                _serializeFields: {
                    name: null,
                    applyMatrix: null,
                    matrix: new Matrix(),
                    pivot: null,
                    locked: false,
                    visible: true,
                    blendMode: "normal",
                    opacity: 1,
                    guide: false,
                    selected: false,
                    clipMask: false,
                    data: {}
                },
                initialize: function Item() {},
                _initialize: function(props, point) {
                    var hasProps = props && Base.isPlainObject(props), internal = hasProps && props.internal === true, matrix = this._matrix = new Matrix(), project = hasProps && props.project || paper.project;
                    if (!internal) this._id = UID.get();
                    this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
                    if (point) matrix.translate(point);
                    matrix._owner = this;
                    this._style = new Style(project._currentStyle, this, project);
                    if (!this._project) {
                        if (internal || hasProps && props.insert === false) {
                            this._setProject(project);
                        } else if (hasProps && props.parent) {
                            this.setParent(props.parent);
                        } else {
                            (project._activeLayer || new Layer()).addChild(this);
                        }
                    }
                    if (hasProps && props !== Item.NO_INSERT) this._set(props, {
                        insert: true,
                        parent: true
                    }, true);
                    return hasProps;
                },
                _events: new function() {
                    var mouseFlags = {
                        mousedown: {
                            mousedown: 1,
                            mousedrag: 1,
                            click: 1,
                            doubleclick: 1
                        },
                        mouseup: {
                            mouseup: 1,
                            mousedrag: 1,
                            click: 1,
                            doubleclick: 1
                        },
                        mousemove: {
                            mousedrag: 1,
                            mousemove: 1,
                            mouseenter: 1,
                            mouseleave: 1
                        }
                    };
                    var mouseEvent = {
                        install: function(type) {
                            var counters = this.getView()._eventCounters;
                            if (counters) {
                                for (var key in mouseFlags) {
                                    counters[key] = (counters[key] || 0) + (mouseFlags[key][type] || 0);
                                }
                            }
                        },
                        uninstall: function(type) {
                            var counters = this.getView()._eventCounters;
                            if (counters) {
                                for (var key in mouseFlags) counters[key] -= mouseFlags[key][type] || 0;
                            }
                        }
                    };
                    return Base.each([ "onMouseDown", "onMouseUp", "onMouseDrag", "onClick", "onDoubleClick", "onMouseMove", "onMouseEnter", "onMouseLeave" ], function(name) {
                        this[name] = mouseEvent;
                    }, {
                        onFrame: {
                            install: function() {
                                this._animateItem(true);
                            },
                            uninstall: function() {
                                this._animateItem(false);
                            }
                        },
                        onLoad: {}
                    });
                }(),
                _animateItem: function(animate) {
                    this.getView()._animateItem(this, animate);
                },
                _serialize: function(options, dictionary) {
                    var props = {}, that = this;
                    function serialize(fields) {
                        for (var key in fields) {
                            var value = that[key];
                            if (!Base.equals(value, key === "leading" ? fields.fontSize * 1.2 : fields[key])) {
                                props[key] = Base.serialize(value, options, key !== "data", dictionary);
                            }
                        }
                    }
                    serialize(this._serializeFields);
                    if (!(this instanceof Group)) serialize(this._style._defaults);
                    return [ this._class, props ];
                },
                _changed: function(flags) {
                    var symbol = this._parentSymbol, cacheParent = this._parent || symbol, project = this._project;
                    if (flags & 8) {
                        this._bounds = this._position = this._decomposed = this._globalMatrix = this._currentPath = undefined;
                    }
                    if (cacheParent && flags & 40) {
                        Item._clearBoundsCache(cacheParent);
                    }
                    if (flags & 2) {
                        Item._clearBoundsCache(this);
                    }
                    if (project) {
                        if (flags & 1) {
                            project._needsUpdate = true;
                        }
                        if (project._changes) {
                            var entry = project._changesById[this._id];
                            if (entry) {
                                entry.flags |= flags;
                            } else {
                                entry = {
                                    item: this,
                                    flags: flags
                                };
                                project._changesById[this._id] = entry;
                                project._changes.push(entry);
                            }
                        }
                    }
                    if (symbol) symbol._changed(flags);
                },
                set: function(props) {
                    if (props) this._set(props);
                    return this;
                },
                getId: function() {
                    return this._id;
                },
                getName: function() {
                    return this._name;
                },
                setName: function(name, unique) {
                    if (this._name) this._removeNamed();
                    if (name === +name + "") throw new Error("Names consisting only of numbers are not supported.");
                    var parent = this._parent;
                    if (name && parent) {
                        var children = parent._children, namedChildren = parent._namedChildren, orig = name, i = 1;
                        while (unique && children[name]) name = orig + " " + i++;
                        (namedChildren[name] = namedChildren[name] || []).push(this);
                        children[name] = this;
                    }
                    this._name = name || undefined;
                    this._changed(128);
                },
                getStyle: function() {
                    return this._style;
                },
                setStyle: function(style) {
                    this.getStyle().set(style);
                }
            }, Base.each([ "locked", "visible", "blendMode", "opacity", "guide" ], function(name) {
                var part = Base.capitalize(name), name = "_" + name;
                this["get" + part] = function() {
                    return this[name];
                };
                this["set" + part] = function(value) {
                    if (value != this[name]) {
                        this[name] = value;
                        this._changed(name === "_locked" ? 128 : 129);
                    }
                };
            }, {}), {
                beans: true,
                _locked: false,
                _visible: true,
                _blendMode: "normal",
                _opacity: 1,
                _guide: false,
                isSelected: function() {
                    if (this._selectChildren) {
                        var children = this._children;
                        for (var i = 0, l = children.length; i < l; i++) if (children[i].isSelected()) return true;
                    }
                    return this._selected;
                },
                setSelected: function(selected, noChildren) {
                    if (!noChildren && this._selectChildren) {
                        var children = this._children;
                        for (var i = 0, l = children.length; i < l; i++) children[i].setSelected(selected);
                    }
                    if ((selected = !!selected) ^ this._selected) {
                        this._selected = selected;
                        this._project._updateSelection(this);
                        this._changed(129);
                    }
                },
                _selected: false,
                isFullySelected: function() {
                    var children = this._children;
                    if (children && this._selected) {
                        for (var i = 0, l = children.length; i < l; i++) if (!children[i].isFullySelected()) return false;
                        return true;
                    }
                    return this._selected;
                },
                setFullySelected: function(selected) {
                    var children = this._children;
                    if (children) {
                        for (var i = 0, l = children.length; i < l; i++) children[i].setFullySelected(selected);
                    }
                    this.setSelected(selected, true);
                },
                isClipMask: function() {
                    return this._clipMask;
                },
                setClipMask: function(clipMask) {
                    if (this._clipMask != (clipMask = !!clipMask)) {
                        this._clipMask = clipMask;
                        if (clipMask) {
                            this.setFillColor(null);
                            this.setStrokeColor(null);
                        }
                        this._changed(129);
                        if (this._parent) this._parent._changed(1024);
                    }
                },
                _clipMask: false,
                getData: function() {
                    if (!this._data) this._data = {};
                    return this._data;
                },
                setData: function(data) {
                    this._data = data;
                },
                getPosition: function(_dontLink) {
                    var position = this._position, ctor = _dontLink ? Point : LinkedPoint;
                    if (!position) {
                        var pivot = this._pivot;
                        position = this._position = pivot ? this._matrix._transformPoint(pivot) : this.getBounds().getCenter(true);
                    }
                    return new ctor(position.x, position.y, this, "setPosition");
                },
                setPosition: function() {
                    this.translate(Point.read(arguments).subtract(this.getPosition(true)));
                },
                getPivot: function(_dontLink) {
                    var pivot = this._pivot;
                    if (pivot) {
                        var ctor = _dontLink ? Point : LinkedPoint;
                        pivot = new ctor(pivot.x, pivot.y, this, "setPivot");
                    }
                    return pivot;
                },
                setPivot: function() {
                    this._pivot = Point.read(arguments);
                    this._position = undefined;
                },
                _pivot: null,
                getRegistration: "#getPivot",
                setRegistration: "#setPivot"
            }, Base.each([ "bounds", "strokeBounds", "handleBounds", "roughBounds", "internalBounds", "internalRoughBounds" ], function(key) {
                var getter = "get" + Base.capitalize(key), match = key.match(/^internal(.*)$/), internalGetter = match ? "get" + match[1] : null;
                this[getter] = function(_matrix) {
                    var boundsGetter = this._boundsGetter, name = !internalGetter && (typeof boundsGetter === "string" ? boundsGetter : boundsGetter && boundsGetter[getter]) || getter, bounds = this._getCachedBounds(name, _matrix, this, internalGetter);
                    return key === "bounds" ? new LinkedRectangle(bounds.x, bounds.y, bounds.width, bounds.height, this, "setBounds") : bounds;
                };
            }, {
                beans: true,
                _getBounds: function(getter, matrix, cacheItem) {
                    var children = this._children;
                    if (!children || children.length == 0) return new Rectangle();
                    Item._updateBoundsCache(this, cacheItem);
                    var x1 = Infinity, x2 = -x1, y1 = x1, y2 = x2;
                    for (var i = 0, l = children.length; i < l; i++) {
                        var child = children[i];
                        if (child._visible && !child.isEmpty()) {
                            var rect = child._getCachedBounds(getter, matrix && matrix.chain(child._matrix), cacheItem);
                            x1 = Math.min(rect.x, x1);
                            y1 = Math.min(rect.y, y1);
                            x2 = Math.max(rect.x + rect.width, x2);
                            y2 = Math.max(rect.y + rect.height, y2);
                        }
                    }
                    return isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle();
                },
                setBounds: function() {
                    var rect = Rectangle.read(arguments), bounds = this.getBounds(), matrix = new Matrix(), center = rect.getCenter();
                    matrix.translate(center);
                    if (rect.width != bounds.width || rect.height != bounds.height) {
                        matrix.scale(bounds.width != 0 ? rect.width / bounds.width : 1, bounds.height != 0 ? rect.height / bounds.height : 1);
                    }
                    center = bounds.getCenter();
                    matrix.translate(-center.x, -center.y);
                    this.transform(matrix);
                },
                _getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
                    matrix = matrix && matrix.orNullIfIdentity();
                    var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(), cache = (!matrix || matrix.equals(_matrix)) && getter;
                    Item._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);
                    if (cache && this._bounds && this._bounds[cache]) return this._bounds[cache].clone();
                    var bounds = this._getBounds(internalGetter || getter, matrix || _matrix, cacheItem);
                    if (cache) {
                        if (!this._bounds) this._bounds = {};
                        var cached = this._bounds[cache] = bounds.clone();
                        cached._internal = !!internalGetter;
                    }
                    return bounds;
                },
                statics: {
                    _updateBoundsCache: function(parent, item) {
                        if (parent) {
                            var id = item._id, ref = parent._boundsCache = parent._boundsCache || {
                                ids: {},
                                list: []
                            };
                            if (!ref.ids[id]) {
                                ref.list.push(item);
                                ref.ids[id] = item;
                            }
                        }
                    },
                    _clearBoundsCache: function(item) {
                        var cache = item._boundsCache;
                        if (cache) {
                            item._bounds = item._position = item._boundsCache = undefined;
                            for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
                                var other = list[i];
                                if (other !== item) {
                                    other._bounds = other._position = undefined;
                                    if (other._boundsCache) Item._clearBoundsCache(other);
                                }
                            }
                        }
                    }
                }
            }), {
                beans: true,
                _decompose: function() {
                    return this._decomposed = this._matrix.decompose();
                },
                getRotation: function() {
                    var decomposed = this._decomposed || this._decompose();
                    return decomposed && decomposed.rotation;
                },
                setRotation: function(rotation) {
                    var current = this.getRotation();
                    if (current != null && rotation != null) {
                        var decomposed = this._decomposed;
                        this.rotate(rotation - current);
                        decomposed.rotation = rotation;
                        this._decomposed = decomposed;
                    }
                },
                getScaling: function(_dontLink) {
                    var decomposed = this._decomposed || this._decompose(), scaling = decomposed && decomposed.scaling, ctor = _dontLink ? Point : LinkedPoint;
                    return scaling && new ctor(scaling.x, scaling.y, this, "setScaling");
                },
                setScaling: function() {
                    var current = this.getScaling();
                    if (current) {
                        var scaling = Point.read(arguments, 0, {
                            clone: true
                        }), decomposed = this._decomposed;
                        this.scale(scaling.x / current.x, scaling.y / current.y);
                        decomposed.scaling = scaling;
                        this._decomposed = decomposed;
                    }
                },
                getMatrix: function() {
                    return this._matrix;
                },
                setMatrix: function(matrix) {
                    this._matrix.initialize(matrix);
                    if (this._applyMatrix) {
                        this.transform(null, true);
                    } else {
                        this._changed(9);
                    }
                },
                getGlobalMatrix: function(_dontClone) {
                    var matrix = this._globalMatrix, updateVersion = this._project._updateVersion;
                    if (matrix && matrix._updateVersion !== updateVersion) matrix = null;
                    if (!matrix) {
                        matrix = this._globalMatrix = this._matrix.clone();
                        var parent = this._parent;
                        if (parent) matrix.preConcatenate(parent.getGlobalMatrix(true));
                        matrix._updateVersion = updateVersion;
                    }
                    return _dontClone ? matrix : matrix.clone();
                },
                getApplyMatrix: function() {
                    return this._applyMatrix;
                },
                setApplyMatrix: function(apply) {
                    if (this._applyMatrix = this._canApplyMatrix && !!apply) this.transform(null, true);
                },
                getTransformContent: "#getApplyMatrix",
                setTransformContent: "#setApplyMatrix"
            }, {
                getProject: function() {
                    return this._project;
                },
                _setProject: function(project, installEvents) {
                    if (this._project !== project) {
                        if (this._project) this._installEvents(false);
                        this._project = project;
                        var children = this._children;
                        for (var i = 0, l = children && children.length; i < l; i++) children[i]._setProject(project);
                        installEvents = true;
                    }
                    if (installEvents) this._installEvents(true);
                },
                getView: function() {
                    return this._project.getView();
                },
                _installEvents: function _installEvents(install) {
                    _installEvents.base.call(this, install);
                    var children = this._children;
                    for (var i = 0, l = children && children.length; i < l; i++) children[i]._installEvents(install);
                },
                getLayer: function() {
                    var parent = this;
                    while (parent = parent._parent) {
                        if (parent instanceof Layer) return parent;
                    }
                    return null;
                },
                getParent: function() {
                    return this._parent;
                },
                setParent: function(item) {
                    return item.addChild(this);
                },
                getChildren: function() {
                    return this._children;
                },
                setChildren: function(items) {
                    this.removeChildren();
                    this.addChildren(items);
                },
                getFirstChild: function() {
                    return this._children && this._children[0] || null;
                },
                getLastChild: function() {
                    return this._children && this._children[this._children.length - 1] || null;
                },
                getNextSibling: function() {
                    return this._parent && this._parent._children[this._index + 1] || null;
                },
                getPreviousSibling: function() {
                    return this._parent && this._parent._children[this._index - 1] || null;
                },
                getIndex: function() {
                    return this._index;
                },
                equals: function(item) {
                    return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;
                },
                _equals: function(item) {
                    return Base.equals(this._children, item._children);
                },
                clone: function(insert) {
                    return this._clone(new this.constructor(Item.NO_INSERT), insert);
                },
                _clone: function(copy, insert, includeMatrix) {
                    var keys = [ "_locked", "_visible", "_blendMode", "_opacity", "_clipMask", "_guide" ], children = this._children;
                    copy.setStyle(this._style);
                    for (var i = 0, l = children && children.length; i < l; i++) {
                        copy.addChild(children[i].clone(false), true);
                    }
                    for (var i = 0, l = keys.length; i < l; i++) {
                        var key = keys[i];
                        if (this.hasOwnProperty(key)) copy[key] = this[key];
                    }
                    if (includeMatrix !== false) copy._matrix.initialize(this._matrix);
                    copy.setApplyMatrix(this._applyMatrix);
                    copy.setSelected(this._selected);
                    copy._data = this._data ? Base.clone(this._data) : null;
                    if (insert || insert === undefined) copy.insertAbove(this);
                    if (this._name) copy.setName(this._name, true);
                    return copy;
                },
                copyTo: function(itemOrProject) {
                    return itemOrProject.addChild(this.clone(false));
                },
                rasterize: function(resolution) {
                    var bounds = this.getStrokeBounds(), scale = (resolution || this.getView().getResolution()) / 72, topLeft = bounds.getTopLeft().floor(), bottomRight = bounds.getBottomRight().ceil(), size = new Size(bottomRight.subtract(topLeft)), canvas = CanvasProvider.getCanvas(size.multiply(scale)), ctx = canvas.getContext("2d"), matrix = new Matrix().scale(scale).translate(topLeft.negate());
                    ctx.save();
                    matrix.applyToContext(ctx);
                    this.draw(ctx, new Base({
                        matrices: [ matrix ]
                    }));
                    ctx.restore();
                    var raster = new Raster(Item.NO_INSERT);
                    raster.setCanvas(canvas);
                    raster.transform(new Matrix().translate(topLeft.add(size.divide(2))).scale(1 / scale));
                    raster.insertAbove(this);
                    return raster;
                },
                contains: function() {
                    return !!this._contains(this._matrix._inverseTransform(Point.read(arguments)));
                },
                _contains: function(point) {
                    if (this._children) {
                        for (var i = this._children.length - 1; i >= 0; i--) {
                            if (this._children[i].contains(point)) return true;
                        }
                        return false;
                    }
                    return point.isInside(this.getInternalBounds());
                },
                isInside: function() {
                    return Rectangle.read(arguments).contains(this.getBounds());
                },
                _asPathItem: function() {
                    return new Path.Rectangle({
                        rectangle: this.getInternalBounds(),
                        matrix: this._matrix,
                        insert: false
                    });
                },
                intersects: function(item, _matrix) {
                    if (!(item instanceof Item)) return false;
                    return this._asPathItem().getIntersections(item._asPathItem(), _matrix || item._matrix).length > 0;
                },
                hitTest: function() {
                    return this._hitTest(Point.read(arguments), HitResult.getOptions(Base.read(arguments)));
                },
                _hitTest: function(point, options) {
                    if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) return null;
                    var matrix = this._matrix, parentTotalMatrix = options._totalMatrix, view = this.getView(), totalMatrix = options._totalMatrix = parentTotalMatrix ? parentTotalMatrix.chain(matrix) : this.getGlobalMatrix().preConcatenate(view._matrix), tolerancePadding = options._tolerancePadding = new Size(Path._getPenPadding(1, totalMatrix.inverted())).multiply(Math.max(options.tolerance, 1e-6));
                    point = matrix._inverseTransform(point);
                    if (!this._children && !this.getInternalRoughBounds().expand(tolerancePadding.multiply(2))._containsPoint(point)) return null;
                    var checkSelf = !(options.guides && !this._guide || options.selected && !this._selected || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)), that = this, res;
                    function checkBounds(type, part) {
                        var pt = bounds["get" + part]();
                        if (point.subtract(pt).divide(tolerancePadding).length <= 1) return new HitResult(type, that, {
                            name: Base.hyphenate(part),
                            point: pt
                        });
                    }
                    if (checkSelf && (options.center || options.bounds) && this._parent) {
                        var bounds = this.getInternalBounds();
                        if (options.center) res = checkBounds("center", "Center");
                        if (!res && options.bounds) {
                            var points = [ "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter" ];
                            for (var i = 0; i < 8 && !res; i++) res = checkBounds("bounds", points[i]);
                        }
                    }
                    var children = !res && this._children;
                    if (children) {
                        var opts = this._getChildHitTestOptions(options);
                        for (var i = children.length - 1; i >= 0 && !res; i--) res = children[i]._hitTest(point, opts);
                    }
                    if (!res && checkSelf) res = this._hitTestSelf(point, options);
                    if (res && res.point) res.point = matrix.transform(res.point);
                    options._totalMatrix = parentTotalMatrix;
                    return res;
                },
                _getChildHitTestOptions: function(options) {
                    return options;
                },
                _hitTestSelf: function(point, options) {
                    if (options.fill && this.hasFill() && this._contains(point)) return new HitResult("fill", this);
                },
                matches: function(name, compare) {
                    function matchObject(obj1, obj2) {
                        for (var i in obj1) {
                            if (obj1.hasOwnProperty(i)) {
                                var val1 = obj1[i], val2 = obj2[i];
                                if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
                                    if (!matchObject(val1, val2)) return false;
                                } else if (!Base.equals(val1, val2)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    if (typeof name === "object") {
                        for (var key in name) {
                            if (name.hasOwnProperty(key) && !this.matches(key, name[key])) return false;
                        }
                    } else {
                        var value = /^(empty|editable)$/.test(name) ? this["is" + Base.capitalize(name)]() : name === "type" ? Base.hyphenate(this._class) : this[name];
                        if (/^(constructor|class)$/.test(name)) {
                            if (!(this instanceof compare)) return false;
                        } else if (compare instanceof RegExp) {
                            if (!compare.test(value)) return false;
                        } else if (typeof compare === "function") {
                            if (!compare(value)) return false;
                        } else if (Base.isPlainObject(compare)) {
                            if (!matchObject(compare, value)) return false;
                        } else if (!Base.equals(value, compare)) {
                            return false;
                        }
                    }
                    return true;
                },
                getItems: function(match) {
                    return Item._getItems(this._children, match, this._matrix);
                },
                getItem: function(match) {
                    return Item._getItems(this._children, match, this._matrix, null, true)[0] || null;
                },
                statics: {
                    _getItems: function _getItems(children, match, matrix, param, firstOnly) {
                        if (!param) {
                            var overlapping = match.overlapping, inside = match.inside, bounds = overlapping || inside, rect = bounds && Rectangle.read([ bounds ]);
                            param = {
                                items: [],
                                inside: rect,
                                overlapping: overlapping && new Path.Rectangle({
                                    rectangle: rect,
                                    insert: false
                                })
                            };
                            if (bounds) match = Base.set({}, match, {
                                inside: true,
                                overlapping: true
                            });
                        }
                        var items = param.items, inside = param.inside, overlapping = param.overlapping;
                        matrix = inside && (matrix || new Matrix());
                        for (var i = 0, l = children && children.length; i < l; i++) {
                            var child = children[i], childMatrix = matrix && matrix.chain(child._matrix), add = true;
                            if (inside) {
                                var bounds = child.getBounds(childMatrix);
                                if (!inside.intersects(bounds)) continue;
                                if (!(inside && inside.contains(bounds)) && !(overlapping && overlapping.intersects(child, childMatrix))) add = false;
                            }
                            if (add && child.matches(match)) {
                                items.push(child);
                                if (firstOnly) break;
                            }
                            _getItems(child._children, match, childMatrix, param, firstOnly);
                            if (firstOnly && items.length > 0) break;
                        }
                        return items;
                    }
                }
            }, {
                importJSON: function(json) {
                    var res = Base.importJSON(json, this);
                    return res !== this ? this.addChild(res) : res;
                },
                addChild: function(item, _preserve) {
                    return this.insertChild(undefined, item, _preserve);
                },
                insertChild: function(index, item, _preserve) {
                    var res = item ? this.insertChildren(index, [ item ], _preserve) : null;
                    return res && res[0];
                },
                addChildren: function(items, _preserve) {
                    return this.insertChildren(this._children.length, items, _preserve);
                },
                insertChildren: function(index, items, _preserve, _proto) {
                    var children = this._children;
                    if (children && items && items.length > 0) {
                        items = Array.prototype.slice.apply(items);
                        for (var i = items.length - 1; i >= 0; i--) {
                            var item = items[i];
                            if (_proto && !(item instanceof _proto)) {
                                items.splice(i, 1);
                            } else {
                                var shift = item._parent === this && item._index < index;
                                if (item._remove(false, true) && shift) index--;
                            }
                        }
                        Base.splice(children, items, index, 0);
                        var project = this._project, notifySelf = project && project._changes;
                        for (var i = 0, l = items.length; i < l; i++) {
                            var item = items[i];
                            item._parent = this;
                            item._setProject(this._project, true);
                            if (item._name) item.setName(item._name);
                            if (notifySelf) this._changed(5);
                        }
                        this._changed(11);
                    } else {
                        items = null;
                    }
                    return items;
                },
                _insertSibling: function(index, item, _preserve) {
                    return this._parent ? this._parent.insertChild(index, item, _preserve) : null;
                },
                insertAbove: function(item, _preserve) {
                    return item._insertSibling(item._index + 1, this, _preserve);
                },
                insertBelow: function(item, _preserve) {
                    return item._insertSibling(item._index, this, _preserve);
                },
                sendToBack: function() {
                    return (this._parent || this instanceof Layer && this._project).insertChild(0, this);
                },
                bringToFront: function() {
                    return (this._parent || this instanceof Layer && this._project).addChild(this);
                },
                appendTop: "#addChild",
                appendBottom: function(item) {
                    return this.insertChild(0, item);
                },
                moveAbove: "#insertAbove",
                moveBelow: "#insertBelow",
                reduce: function() {
                    if (this._children && this._children.length === 1) {
                        var child = this._children[0].reduce();
                        child.insertAbove(this);
                        child.setStyle(this._style);
                        this.remove();
                        return child;
                    }
                    return this;
                },
                _removeNamed: function() {
                    var parent = this._parent;
                    if (parent) {
                        var children = parent._children, namedChildren = parent._namedChildren, name = this._name, namedArray = namedChildren[name], index = namedArray ? namedArray.indexOf(this) : -1;
                        if (index !== -1) {
                            if (children[name] == this) delete children[name];
                            namedArray.splice(index, 1);
                            if (namedArray.length) {
                                children[name] = namedArray[namedArray.length - 1];
                            } else {
                                delete namedChildren[name];
                            }
                        }
                    }
                },
                _remove: function(notifySelf, notifyParent) {
                    var parent = this._parent;
                    if (parent) {
                        if (this._name) this._removeNamed();
                        if (this._index != null) Base.splice(parent._children, null, this._index, 1);
                        this._installEvents(false);
                        if (notifySelf) {
                            var project = this._project;
                            if (project && project._changes) this._changed(5);
                        }
                        if (notifyParent) parent._changed(11);
                        this._parent = null;
                        return true;
                    }
                    return false;
                },
                remove: function() {
                    return this._remove(true, true);
                },
                replaceWith: function(item) {
                    var ok = item && item.insertBelow(this);
                    if (ok) this.remove();
                    return ok;
                },
                removeChildren: function(from, to) {
                    if (!this._children) return null;
                    from = from || 0;
                    to = Base.pick(to, this._children.length);
                    var removed = Base.splice(this._children, null, from, to - from);
                    for (var i = removed.length - 1; i >= 0; i--) {
                        removed[i]._remove(true, false);
                    }
                    if (removed.length > 0) this._changed(11);
                    return removed;
                },
                clear: "#removeChildren",
                reverseChildren: function() {
                    if (this._children) {
                        this._children.reverse();
                        for (var i = 0, l = this._children.length; i < l; i++) this._children[i]._index = i;
                        this._changed(11);
                    }
                },
                isEmpty: function() {
                    return !this._children || this._children.length === 0;
                },
                isEditable: function() {
                    var item = this;
                    while (item) {
                        if (!item._visible || item._locked) return false;
                        item = item._parent;
                    }
                    return true;
                },
                hasFill: function() {
                    return this.getStyle().hasFill();
                },
                hasStroke: function() {
                    return this.getStyle().hasStroke();
                },
                hasShadow: function() {
                    return this.getStyle().hasShadow();
                },
                _getOrder: function(item) {
                    function getList(item) {
                        var list = [];
                        do {
                            list.unshift(item);
                        } while (item = item._parent);
                        return list;
                    }
                    var list1 = getList(this), list2 = getList(item);
                    for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
                        if (list1[i] != list2[i]) {
                            return list1[i]._index < list2[i]._index ? 1 : -1;
                        }
                    }
                    return 0;
                },
                hasChildren: function() {
                    return this._children && this._children.length > 0;
                },
                isInserted: function() {
                    return this._parent ? this._parent.isInserted() : false;
                },
                isAbove: function(item) {
                    return this._getOrder(item) === -1;
                },
                isBelow: function(item) {
                    return this._getOrder(item) === 1;
                },
                isParent: function(item) {
                    return this._parent === item;
                },
                isChild: function(item) {
                    return item && item._parent === this;
                },
                isDescendant: function(item) {
                    var parent = this;
                    while (parent = parent._parent) {
                        if (parent == item) return true;
                    }
                    return false;
                },
                isAncestor: function(item) {
                    return item ? item.isDescendant(this) : false;
                },
                isGroupedWith: function(item) {
                    var parent = this._parent;
                    while (parent) {
                        if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent)) return true;
                        parent = parent._parent;
                    }
                    return false;
                },
                translate: function() {
                    var mx = new Matrix();
                    return this.transform(mx.translate.apply(mx, arguments));
                },
                rotate: function(angle) {
                    return this.transform(new Matrix().rotate(angle, Point.read(arguments, 1, {
                        readNull: true
                    }) || this.getPosition(true)));
                }
            }, Base.each([ "scale", "shear", "skew" ], function(name) {
                this[name] = function() {
                    var point = Point.read(arguments), center = Point.read(arguments, 0, {
                        readNull: true
                    });
                    return this.transform(new Matrix()[name](point, center || this.getPosition(true)));
                };
            }, {}), {
                transform: function(matrix, _applyMatrix, _applyRecursively, _setApplyMatrix) {
                    if (matrix && matrix.isIdentity()) matrix = null;
                    var _matrix = this._matrix, applyMatrix = (_applyMatrix || this._applyMatrix) && (!_matrix.isIdentity() || matrix || _applyMatrix && _applyRecursively && this._children);
                    if (!matrix && !applyMatrix) return this;
                    if (matrix) _matrix.preConcatenate(matrix);
                    if (applyMatrix = applyMatrix && this._transformContent(_matrix, _applyRecursively, _setApplyMatrix)) {
                        var pivot = this._pivot, style = this._style, fillColor = style.getFillColor(true), strokeColor = style.getStrokeColor(true);
                        if (pivot) _matrix._transformPoint(pivot, pivot, true);
                        if (fillColor) fillColor.transform(_matrix);
                        if (strokeColor) strokeColor.transform(_matrix);
                        _matrix.reset(true);
                        if (_setApplyMatrix && this._canApplyMatrix) this._applyMatrix = true;
                    }
                    var bounds = this._bounds, position = this._position;
                    this._changed(9);
                    var decomp = bounds && matrix && matrix.decompose();
                    if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
                        for (var key in bounds) {
                            var rect = bounds[key];
                            if (applyMatrix || !rect._internal) matrix._transformBounds(rect, rect);
                        }
                        var getter = this._boundsGetter, rect = bounds[getter && getter.getBounds || getter || "getBounds"];
                        if (rect) this._position = rect.getCenter(true);
                        this._bounds = bounds;
                    } else if (matrix && position) {
                        this._position = matrix._transformPoint(position, position);
                    }
                    return this;
                },
                _transformContent: function(matrix, applyRecursively, setApplyMatrix) {
                    var children = this._children;
                    if (children) {
                        for (var i = 0, l = children.length; i < l; i++) children[i].transform(matrix, true, applyRecursively, setApplyMatrix);
                        return true;
                    }
                },
                globalToLocal: function() {
                    return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));
                },
                localToGlobal: function() {
                    return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));
                },
                parentToLocal: function() {
                    return this._matrix._inverseTransform(Point.read(arguments));
                },
                localToParent: function() {
                    return this._matrix._transformPoint(Point.read(arguments));
                },
                fitBounds: function(rectangle, fill) {
                    rectangle = Rectangle.read(arguments);
                    var bounds = this.getBounds(), itemRatio = bounds.height / bounds.width, rectRatio = rectangle.height / rectangle.width, scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height, newBounds = new Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));
                    newBounds.setCenter(rectangle.getCenter());
                    this.setBounds(newBounds);
                },
                _setStyles: function(ctx) {
                    var style = this._style, fillColor = style.getFillColor(), strokeColor = style.getStrokeColor(), shadowColor = style.getShadowColor();
                    if (fillColor) ctx.fillStyle = fillColor.toCanvasStyle(ctx);
                    if (strokeColor) {
                        var strokeWidth = style.getStrokeWidth();
                        if (strokeWidth > 0) {
                            ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
                            ctx.lineWidth = strokeWidth;
                            var strokeJoin = style.getStrokeJoin(), strokeCap = style.getStrokeCap(), miterLimit = style.getMiterLimit();
                            if (strokeJoin) ctx.lineJoin = strokeJoin;
                            if (strokeCap) ctx.lineCap = strokeCap;
                            if (miterLimit) ctx.miterLimit = miterLimit;
                            if (paper.support.nativeDash) {
                                var dashArray = style.getDashArray(), dashOffset = style.getDashOffset();
                                if (dashArray && dashArray.length) {
                                    if ("setLineDash" in ctx) {
                                        ctx.setLineDash(dashArray);
                                        ctx.lineDashOffset = dashOffset;
                                    } else {
                                        ctx.mozDash = dashArray;
                                        ctx.mozDashOffset = dashOffset;
                                    }
                                }
                            }
                        }
                    }
                    if (shadowColor) {
                        var shadowBlur = style.getShadowBlur();
                        if (shadowBlur > 0) {
                            ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
                            ctx.shadowBlur = shadowBlur;
                            var offset = this.getShadowOffset();
                            ctx.shadowOffsetX = offset.x;
                            ctx.shadowOffsetY = offset.y;
                        }
                    }
                },
                draw: function(ctx, param, parentStrokeMatrix) {
                    var updateVersion = this._updateVersion = this._project._updateVersion;
                    if (!this._visible || this._opacity === 0) return;
                    var matrices = param.matrices, viewMatrix = param.viewMatrix, matrix = this._matrix, globalMatrix = matrices[matrices.length - 1].chain(matrix);
                    if (!globalMatrix.isInvertible()) return;
                    function getViewMatrix(matrix) {
                        return viewMatrix ? viewMatrix.chain(matrix) : matrix;
                    }
                    matrices.push(globalMatrix);
                    if (param.updateMatrix) {
                        globalMatrix._updateVersion = updateVersion;
                        this._globalMatrix = globalMatrix;
                    }
                    var blendMode = this._blendMode, opacity = this._opacity, normalBlend = blendMode === "normal", nativeBlend = BlendMode.nativeModes[blendMode], direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(), pixelRatio = param.pixelRatio, mainCtx, itemOffset, prevOffset;
                    if (!direct) {
                        var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
                        if (!bounds.width || !bounds.height) return;
                        prevOffset = param.offset;
                        itemOffset = param.offset = bounds.getTopLeft().floor();
                        mainCtx = ctx;
                        ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));
                        if (pixelRatio !== 1) ctx.scale(pixelRatio, pixelRatio);
                    }
                    ctx.save();
                    var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.chain(matrix) : !this.getStrokeScaling(true) && getViewMatrix(globalMatrix), clip = !direct && param.clipItem, transform = !strokeMatrix || clip;
                    if (direct) {
                        ctx.globalAlpha = opacity;
                        if (nativeBlend) ctx.globalCompositeOperation = blendMode;
                    } else if (transform) {
                        ctx.translate(-itemOffset.x, -itemOffset.y);
                    }
                    if (transform) (direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
                    if (clip) param.clipItem.draw(ctx, param.extend({
                        clip: true
                    }));
                    if (strokeMatrix) {
                        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                        var offset = param.offset;
                        if (offset) ctx.translate(-offset.x, -offset.y);
                    }
                    this._draw(ctx, param, strokeMatrix);
                    ctx.restore();
                    matrices.pop();
                    if (param.clip && !param.dontFinish) ctx.clip();
                    if (!direct) {
                        BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));
                        CanvasProvider.release(ctx);
                        param.offset = prevOffset;
                    }
                },
                _isUpdated: function(updateVersion) {
                    var parent = this._parent;
                    if (parent instanceof CompoundPath) return parent._isUpdated(updateVersion);
                    var updated = this._updateVersion === updateVersion;
                    if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {
                        this._updateVersion = updateVersion;
                        updated = true;
                    }
                    return updated;
                },
                _drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
                    if ((this._drawSelected || this._boundsSelected) && this._isUpdated(updateVersion)) {
                        var color = this.getSelectedColor(true) || this.getLayer().getSelectedColor(true), mx = matrix.chain(this.getGlobalMatrix(true));
                        ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : "#009dec";
                        if (this._drawSelected) this._drawSelected(ctx, mx, selectedItems);
                        if (this._boundsSelected) {
                            var half = size / 2;
                            coords = mx._transformCorners(this.getInternalBounds());
                            ctx.beginPath();
                            for (var i = 0; i < 8; i++) ctx[i === 0 ? "moveTo" : "lineTo"](coords[i], coords[++i]);
                            ctx.closePath();
                            ctx.stroke();
                            for (var i = 0; i < 8; i++) ctx.fillRect(coords[i] - half, coords[++i] - half, size, size);
                        }
                    }
                },
                _canComposite: function() {
                    return false;
                }
            }, Base.each([ "down", "drag", "up", "move" ], function(name) {
                this["removeOn" + Base.capitalize(name)] = function() {
                    var hash = {};
                    hash[name] = true;
                    return this.removeOn(hash);
                };
            }, {
                removeOn: function(obj) {
                    for (var name in obj) {
                        if (obj[name]) {
                            var key = "mouse" + name, project = this._project, sets = project._removeSets = project._removeSets || {};
                            sets[key] = sets[key] || {};
                            sets[key][this._id] = this;
                        }
                    }
                    return this;
                }
            }));
            var Group = Item.extend({
                _class: "Group",
                _selectChildren: true,
                _serializeFields: {
                    children: []
                },
                initialize: function Group(arg) {
                    this._children = [];
                    this._namedChildren = {};
                    if (!this._initialize(arg)) this.addChildren(Array.isArray(arg) ? arg : arguments);
                },
                _changed: function _changed(flags) {
                    _changed.base.call(this, flags);
                    if (flags & 1026) {
                        this._clipItem = undefined;
                    }
                },
                _getClipItem: function() {
                    var clipItem = this._clipItem;
                    if (clipItem === undefined) {
                        clipItem = null;
                        for (var i = 0, l = this._children.length; i < l; i++) {
                            var child = this._children[i];
                            if (child._clipMask) {
                                clipItem = child;
                                break;
                            }
                        }
                        this._clipItem = clipItem;
                    }
                    return clipItem;
                },
                isClipped: function() {
                    return !!this._getClipItem();
                },
                setClipped: function(clipped) {
                    var child = this.getFirstChild();
                    if (child) child.setClipMask(clipped);
                },
                _draw: function(ctx, param) {
                    var clip = param.clip, clipItem = !clip && this._getClipItem(), draw = true;
                    param = param.extend({
                        clipItem: clipItem,
                        clip: false
                    });
                    if (clip) {
                        if (this._currentPath) {
                            ctx.currentPath = this._currentPath;
                            draw = false;
                        } else {
                            ctx.beginPath();
                            param.dontStart = param.dontFinish = true;
                        }
                    } else if (clipItem) {
                        clipItem.draw(ctx, param.extend({
                            clip: true
                        }));
                    }
                    if (draw) {
                        for (var i = 0, l = this._children.length; i < l; i++) {
                            var item = this._children[i];
                            if (item !== clipItem) item.draw(ctx, param);
                        }
                    }
                    if (clip) {
                        this._currentPath = ctx.currentPath;
                    }
                }
            });
            var Layer = Group.extend({
                _class: "Layer",
                initialize: function Layer(arg) {
                    var props = Base.isPlainObject(arg) ? new Base(arg) : {
                        children: Array.isArray(arg) ? arg : arguments
                    }, insert = props.insert;
                    props.insert = false;
                    Group.call(this, props);
                    if (insert || insert === undefined) {
                        this._project.addChild(this);
                        this.activate();
                    }
                },
                _remove: function _remove(notifySelf, notifyParent) {
                    if (this._parent) return _remove.base.call(this, notifySelf, notifyParent);
                    if (this._index != null) {
                        var project = this._project;
                        if (project._activeLayer === this) project._activeLayer = this.getNextSibling() || this.getPreviousSibling();
                        Base.splice(project.layers, null, this._index, 1);
                        this._installEvents(false);
                        if (notifySelf && project._changes) this._changed(5);
                        if (notifyParent) {
                            project._needsUpdate = true;
                        }
                        return true;
                    }
                    return false;
                },
                getNextSibling: function getNextSibling() {
                    return this._parent ? getNextSibling.base.call(this) : this._project.layers[this._index + 1] || null;
                },
                getPreviousSibling: function getPreviousSibling() {
                    return this._parent ? getPreviousSibling.base.call(this) : this._project.layers[this._index - 1] || null;
                },
                isInserted: function isInserted() {
                    return this._parent ? isInserted.base.call(this) : this._index != null;
                },
                activate: function() {
                    this._project._activeLayer = this;
                },
                _insertSibling: function _insertSibling(index, item, _preserve) {
                    return !this._parent ? this._project.insertChild(index, item, _preserve) : _insertSibling.base.call(this, index, item, _preserve);
                }
            });
            var Shape = Item.extend({
                _class: "Shape",
                _applyMatrix: false,
                _canApplyMatrix: false,
                _boundsSelected: true,
                _serializeFields: {
                    type: null,
                    size: null,
                    radius: null
                },
                initialize: function Shape(props) {
                    this._initialize(props);
                },
                _equals: function(item) {
                    return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);
                },
                clone: function(insert) {
                    var copy = new Shape(Item.NO_INSERT);
                    copy.setType(this._type);
                    copy.setSize(this._size);
                    copy.setRadius(this._radius);
                    return this._clone(copy, insert);
                },
                getType: function() {
                    return this._type;
                },
                setType: function(type) {
                    this._type = type;
                },
                getShape: "#getType",
                setShape: "#setType",
                getSize: function() {
                    var size = this._size;
                    return new LinkedSize(size.width, size.height, this, "setSize");
                },
                setSize: function() {
                    var size = Size.read(arguments);
                    if (!this._size) {
                        this._size = size.clone();
                    } else if (!this._size.equals(size)) {
                        var type = this._type, width = size.width, height = size.height;
                        if (type === "rectangle") {
                            var radius = Size.min(this._radius, size.divide(2));
                            this._radius.set(radius.width, radius.height);
                        } else if (type === "circle") {
                            width = height = (width + height) / 2;
                            this._radius = width / 2;
                        } else if (type === "ellipse") {
                            this._radius.set(width / 2, height / 2);
                        }
                        this._size.set(width, height);
                        this._changed(9);
                    }
                },
                getRadius: function() {
                    var rad = this._radius;
                    return this._type === "circle" ? rad : new LinkedSize(rad.width, rad.height, this, "setRadius");
                },
                setRadius: function(radius) {
                    var type = this._type;
                    if (type === "circle") {
                        if (radius === this._radius) return;
                        var size = radius * 2;
                        this._radius = radius;
                        this._size.set(size, size);
                    } else {
                        radius = Size.read(arguments);
                        if (!this._radius) {
                            this._radius = radius.clone();
                        } else {
                            if (this._radius.equals(radius)) return;
                            this._radius.set(radius.width, radius.height);
                            if (type === "rectangle") {
                                var size = Size.max(this._size, radius.multiply(2));
                                this._size.set(size.width, size.height);
                            } else if (type === "ellipse") {
                                this._size.set(radius.width * 2, radius.height * 2);
                            }
                        }
                    }
                    this._changed(9);
                },
                isEmpty: function() {
                    return false;
                },
                toPath: function(insert) {
                    var path = this._clone(new (Path[Base.capitalize(this._type)])({
                        center: new Point(),
                        size: this._size,
                        radius: this._radius,
                        insert: false
                    }), insert);
                    if (paper.settings.applyMatrix) path.setApplyMatrix(true);
                    return path;
                },
                _draw: function(ctx, param, strokeMatrix) {
                    var style = this._style, hasFill = style.hasFill(), hasStroke = style.hasStroke(), dontPaint = param.dontFinish || param.clip, untransformed = !strokeMatrix;
                    if (hasFill || hasStroke || dontPaint) {
                        var type = this._type, radius = this._radius, isCircle = type === "circle";
                        if (!param.dontStart) ctx.beginPath();
                        if (untransformed && isCircle) {
                            ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
                        } else {
                            var rx = isCircle ? radius : radius.width, ry = isCircle ? radius : radius.height, size = this._size, width = size.width, height = size.height;
                            if (untransformed && type === "rect" && rx === 0 && ry === 0) {
                                ctx.rect(-width / 2, -height / 2, width, height);
                            } else {
                                var x = width / 2, y = height / 2, kappa = 1 - .5522847498307936, cx = rx * kappa, cy = ry * kappa, c = [ -x, -y + ry, -x, -y + cy, -x + cx, -y, -x + rx, -y, x - rx, -y, x - cx, -y, x, -y + cy, x, -y + ry, x, y - ry, x, y - cy, x - cx, y, x - rx, y, -x + rx, y, -x + cx, y, -x, y - cy, -x, y - ry ];
                                if (strokeMatrix) strokeMatrix.transform(c, c, 32);
                                ctx.moveTo(c[0], c[1]);
                                ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
                                if (x !== rx) ctx.lineTo(c[8], c[9]);
                                ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
                                if (y !== ry) ctx.lineTo(c[16], c[17]);
                                ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
                                if (x !== rx) ctx.lineTo(c[24], c[25]);
                                ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
                            }
                        }
                        ctx.closePath();
                    }
                    if (!dontPaint && (hasFill || hasStroke)) {
                        this._setStyles(ctx);
                        if (hasFill) {
                            ctx.fill(style.getWindingRule());
                            ctx.shadowColor = "rgba(0,0,0,0)";
                        }
                        if (hasStroke) ctx.stroke();
                    }
                },
                _canComposite: function() {
                    return !(this.hasFill() && this.hasStroke());
                },
                _getBounds: function(getter, matrix) {
                    var rect = new Rectangle(this._size).setCenter(0, 0);
                    if (getter !== "getBounds" && this.hasStroke()) rect = rect.expand(this.getStrokeWidth());
                    return matrix ? matrix._transformBounds(rect) : rect;
                }
            }, new function() {
                function getCornerCenter(that, point, expand) {
                    var radius = that._radius;
                    if (!radius.isZero()) {
                        var halfSize = that._size.divide(2);
                        for (var i = 0; i < 4; i++) {
                            var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1), corner = dir.multiply(halfSize), center = corner.subtract(dir.multiply(radius)), rect = new Rectangle(corner, center);
                            if ((expand ? rect.expand(expand) : rect).contains(point)) return center;
                        }
                    }
                }
                function getEllipseRadius(point, radius) {
                    var angle = point.getAngleInRadians(), width = radius.width * 2, height = radius.height * 2, x = width * Math.sin(angle), y = height * Math.cos(angle);
                    return width * height / (2 * Math.sqrt(x * x + y * y));
                }
                return {
                    _contains: function _contains(point) {
                        if (this._type === "rectangle") {
                            var center = getCornerCenter(this, point);
                            return center ? point.subtract(center).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);
                        } else {
                            return point.divide(this.size).getLength() <= .5;
                        }
                    },
                    _hitTestSelf: function _hitTestSelf(point, options) {
                        var hit = false;
                        if (this.hasStroke()) {
                            var type = this._type, radius = this._radius, strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
                            if (type === "rectangle") {
                                var center = getCornerCenter(this, point, strokeWidth);
                                if (center) {
                                    var pt = point.subtract(center);
                                    hit = 2 * Math.abs(pt.getLength() - getEllipseRadius(pt, radius)) <= strokeWidth;
                                } else {
                                    var rect = new Rectangle(this._size).setCenter(0, 0), outer = rect.expand(strokeWidth), inner = rect.expand(-strokeWidth);
                                    hit = outer._containsPoint(point) && !inner._containsPoint(point);
                                }
                            } else {
                                if (type === "ellipse") radius = getEllipseRadius(point, radius);
                                hit = 2 * Math.abs(point.getLength() - radius) <= strokeWidth;
                            }
                        }
                        return hit ? new HitResult("stroke", this) : _hitTestSelf.base.apply(this, arguments);
                    }
                };
            }(), {
                statics: new function() {
                    function createShape(type, point, size, radius, args) {
                        var item = new Shape(Base.getNamed(args));
                        item._type = type;
                        item._size = size;
                        item._radius = radius;
                        return item.translate(point);
                    }
                    return {
                        Circle: function() {
                            var center = Point.readNamed(arguments, "center"), radius = Base.readNamed(arguments, "radius");
                            return createShape("circle", center, new Size(radius * 2), radius, arguments);
                        },
                        Rectangle: function() {
                            var rect = Rectangle.readNamed(arguments, "rectangle"), radius = Size.min(Size.readNamed(arguments, "radius"), rect.getSize(true).divide(2));
                            return createShape("rectangle", rect.getCenter(true), rect.getSize(true), radius, arguments);
                        },
                        Ellipse: function() {
                            var ellipse = Shape._readEllipse(arguments), radius = ellipse.radius;
                            return createShape("ellipse", ellipse.center, radius.multiply(2), radius, arguments);
                        },
                        _readEllipse: function(args) {
                            var center, radius;
                            if (Base.hasNamed(args, "radius")) {
                                center = Point.readNamed(args, "center");
                                radius = Size.readNamed(args, "radius");
                            } else {
                                var rect = Rectangle.readNamed(args, "rectangle");
                                center = rect.getCenter(true);
                                radius = rect.getSize(true).divide(2);
                            }
                            return {
                                center: center,
                                radius: radius
                            };
                        }
                    };
                }()
            });
            var Raster = Item.extend({
                _class: "Raster",
                _applyMatrix: false,
                _canApplyMatrix: false,
                _boundsGetter: "getBounds",
                _boundsSelected: true,
                _serializeFields: {
                    source: null
                },
                initialize: function Raster(object, position) {
                    if (!this._initialize(object, position !== undefined && Point.read(arguments, 1))) {
                        if (typeof object === "string") {
                            this.setSource(object);
                        } else {
                            this.setImage(object);
                        }
                    }
                    if (!this._size) {
                        this._size = new Size();
                        this._loaded = false;
                    }
                },
                _equals: function(item) {
                    return this.getSource() === item.getSource();
                },
                clone: function(insert) {
                    var copy = new Raster(Item.NO_INSERT), image = this._image, canvas = this._canvas;
                    if (image) {
                        copy.setImage(image);
                    } else if (canvas) {
                        var copyCanvas = CanvasProvider.getCanvas(this._size);
                        copyCanvas.getContext("2d").drawImage(canvas, 0, 0);
                        copy.setImage(copyCanvas);
                    }
                    return this._clone(copy, insert);
                },
                getSize: function() {
                    var size = this._size;
                    return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, "setSize");
                },
                setSize: function() {
                    var size = Size.read(arguments);
                    if (!size.equals(this._size)) {
                        if (size.width > 0 && size.height > 0) {
                            var element = this.getElement();
                            this.setImage(CanvasProvider.getCanvas(size));
                            if (element) this.getContext(true).drawImage(element, 0, 0, size.width, size.height);
                        } else {
                            if (this._canvas) CanvasProvider.release(this._canvas);
                            this._size = size.clone();
                        }
                    }
                },
                getWidth: function() {
                    return this._size ? this._size.width : 0;
                },
                setWidth: function(width) {
                    this.setSize(width, this.getHeight());
                },
                getHeight: function() {
                    return this._size ? this._size.height : 0;
                },
                setHeight: function(height) {
                    this.setSize(this.getWidth(), height);
                },
                isEmpty: function() {
                    var size = this._size;
                    return !size || size.width === 0 && size.height === 0;
                },
                getResolution: function() {
                    var matrix = this._matrix, orig = new Point(0, 0).transform(matrix), u = new Point(1, 0).transform(matrix).subtract(orig), v = new Point(0, 1).transform(matrix).subtract(orig);
                    return new Size(72 / u.getLength(), 72 / v.getLength());
                },
                getPpi: "#getResolution",
                getImage: function() {
                    return this._image;
                },
                setImage: function(image) {
                    if (this._canvas) CanvasProvider.release(this._canvas);
                    if (image && image.getContext) {
                        this._image = null;
                        this._canvas = image;
                        this._loaded = true;
                    } else {
                        this._image = image;
                        this._canvas = null;
                        this._loaded = image && image.complete;
                    }
                    this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);
                    this._context = null;
                    this._changed(521);
                },
                getCanvas: function() {
                    if (!this._canvas) {
                        var ctx = CanvasProvider.getContext(this._size);
                        try {
                            if (this._image) ctx.drawImage(this._image, 0, 0);
                            this._canvas = ctx.canvas;
                        } catch (e) {
                            CanvasProvider.release(ctx);
                        }
                    }
                    return this._canvas;
                },
                setCanvas: "#setImage",
                getContext: function(modify) {
                    if (!this._context) this._context = this.getCanvas().getContext("2d");
                    if (modify) {
                        this._image = null;
                        this._changed(513);
                    }
                    return this._context;
                },
                setContext: function(context) {
                    this._context = context;
                },
                getSource: function() {
                    return this._image && this._image.src || this.toDataURL();
                },
                setSource: function(src) {
                    var that = this, image;
                    function loaded() {
                        var view = that.getView();
                        if (view) {
                            paper = view._scope;
                            that.setImage(image);
                            that.emit("load");
                            view.update();
                        }
                    }
                    image = document.getElementById(src) || new Image();
                    if (image.naturalWidth && image.naturalHeight) {
                        setTimeout(loaded, 0);
                    } else {
                        DomEvent.add(image, {
                            load: loaded
                        });
                        if (!image.src) image.src = src;
                    }
                    this.setImage(image);
                },
                getElement: function() {
                    return this._canvas || this._loaded && this._image;
                }
            }, {
                beans: false,
                getSubCanvas: function() {
                    var rect = Rectangle.read(arguments), ctx = CanvasProvider.getContext(rect.getSize());
                    ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                    return ctx.canvas;
                },
                getSubRaster: function() {
                    var rect = Rectangle.read(arguments), raster = new Raster(Item.NO_INSERT);
                    raster.setImage(this.getSubCanvas(rect));
                    raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
                    raster._matrix.preConcatenate(this._matrix);
                    raster.insertAbove(this);
                    return raster;
                },
                toDataURL: function() {
                    var src = this._image && this._image.src;
                    if (/^data:/.test(src)) return src;
                    var canvas = this.getCanvas();
                    return canvas ? canvas.toDataURL() : null;
                },
                drawImage: function(image) {
                    var point = Point.read(arguments, 1);
                    this.getContext(true).drawImage(image, point.x, point.y);
                },
                getAverageColor: function(object) {
                    var bounds, path;
                    if (!object) {
                        bounds = this.getBounds();
                    } else if (object instanceof PathItem) {
                        path = object;
                        bounds = object.getBounds();
                    } else if (object.width) {
                        bounds = new Rectangle(object);
                    } else if (object.x) {
                        bounds = new Rectangle(object.x - .5, object.y - .5, 1, 1);
                    }
                    var sampleSize = 32, width = Math.min(bounds.width, sampleSize), height = Math.min(bounds.height, sampleSize);
                    var ctx = Raster._sampleContext;
                    if (!ctx) {
                        ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));
                    } else {
                        ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
                    }
                    ctx.save();
                    var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
                    matrix.applyToContext(ctx);
                    if (path) path.draw(ctx, new Base({
                        clip: true,
                        matrices: [ matrix ]
                    }));
                    this._matrix.applyToContext(ctx);
                    var element = this.getElement(), size = this._size;
                    if (element) ctx.drawImage(element, -size.width / 2, -size.height / 2);
                    ctx.restore();
                    var pixels = ctx.getImageData(.5, .5, Math.ceil(width), Math.ceil(height)).data, channels = [ 0, 0, 0 ], total = 0;
                    for (var i = 0, l = pixels.length; i < l; i += 4) {
                        var alpha = pixels[i + 3];
                        total += alpha;
                        alpha /= 255;
                        channels[0] += pixels[i] * alpha;
                        channels[1] += pixels[i + 1] * alpha;
                        channels[2] += pixels[i + 2] * alpha;
                    }
                    for (var i = 0; i < 3; i++) channels[i] /= total;
                    return total ? Color.read(channels) : null;
                },
                getPixel: function() {
                    var point = Point.read(arguments);
                    var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
                    return new Color("rgb", [ data[0] / 255, data[1] / 255, data[2] / 255 ], data[3] / 255);
                },
                setPixel: function() {
                    var point = Point.read(arguments), color = Color.read(arguments), components = color._convert("rgb"), alpha = color._alpha, ctx = this.getContext(true), imageData = ctx.createImageData(1, 1), data = imageData.data;
                    data[0] = components[0] * 255;
                    data[1] = components[1] * 255;
                    data[2] = components[2] * 255;
                    data[3] = alpha != null ? alpha * 255 : 255;
                    ctx.putImageData(imageData, point.x, point.y);
                },
                createImageData: function() {
                    var size = Size.read(arguments);
                    return this.getContext().createImageData(size.width, size.height);
                },
                getImageData: function() {
                    var rect = Rectangle.read(arguments);
                    if (rect.isEmpty()) rect = new Rectangle(this._size);
                    return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);
                },
                setImageData: function(data) {
                    var point = Point.read(arguments, 1);
                    this.getContext(true).putImageData(data, point.x, point.y);
                },
                _getBounds: function(getter, matrix) {
                    var rect = new Rectangle(this._size).setCenter(0, 0);
                    return matrix ? matrix._transformBounds(rect) : rect;
                },
                _hitTestSelf: function(point) {
                    if (this._contains(point)) {
                        var that = this;
                        return new HitResult("pixel", that, {
                            offset: point.add(that._size.divide(2)).round(),
                            color: {
                                get: function() {
                                    return that.getPixel(this.offset);
                                }
                            }
                        });
                    }
                },
                _draw: function(ctx) {
                    var element = this.getElement();
                    if (element) {
                        ctx.globalAlpha = this._opacity;
                        ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);
                    }
                },
                _canComposite: function() {
                    return true;
                }
            });
            var PlacedSymbol = Item.extend({
                _class: "PlacedSymbol",
                _applyMatrix: false,
                _canApplyMatrix: false,
                _boundsGetter: {
                    getBounds: "getStrokeBounds"
                },
                _boundsSelected: true,
                _serializeFields: {
                    symbol: null
                },
                initialize: function PlacedSymbol(arg0, arg1) {
                    if (!this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1))) this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
                },
                _equals: function(item) {
                    return this._symbol === item._symbol;
                },
                getSymbol: function() {
                    return this._symbol;
                },
                setSymbol: function(symbol) {
                    this._symbol = symbol;
                    this._changed(9);
                },
                clone: function(insert) {
                    var copy = new PlacedSymbol(Item.NO_INSERT);
                    copy.setSymbol(this._symbol);
                    return this._clone(copy, insert);
                },
                isEmpty: function() {
                    return this._symbol._definition.isEmpty();
                },
                _getBounds: function(getter, matrix, cacheItem) {
                    var definition = this.symbol._definition;
                    return definition._getCachedBounds(getter, matrix && matrix.chain(definition._matrix), cacheItem);
                },
                _hitTestSelf: function(point, options) {
                    var res = this._symbol._definition._hitTest(point, options);
                    if (res) res.item = this;
                    return res;
                },
                _draw: function(ctx, param) {
                    this.symbol._definition.draw(ctx, param);
                }
            });
            var HitResult = Base.extend({
                _class: "HitResult",
                initialize: function HitResult(type, item, values) {
                    this.type = type;
                    this.item = item;
                    if (values) {
                        values.enumerable = true;
                        this.inject(values);
                    }
                },
                statics: {
                    getOptions: function(options) {
                        return new Base({
                            type: null,
                            tolerance: paper.settings.hitTolerance,
                            fill: !options,
                            stroke: !options,
                            segments: !options,
                            handles: false,
                            ends: false,
                            center: false,
                            bounds: false,
                            guides: false,
                            selected: false
                        }, options);
                    }
                }
            });
            var Segment = Base.extend({
                _class: "Segment",
                beans: true,
                initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
                    var count = arguments.length, point, handleIn, handleOut;
                    if (count === 0) {} else if (count === 1) {
                        if (arg0.point) {
                            point = arg0.point;
                            handleIn = arg0.handleIn;
                            handleOut = arg0.handleOut;
                        } else {
                            point = arg0;
                        }
                    } else if (count === 2 && typeof arg0 === "number") {
                        point = arguments;
                    } else if (count <= 3) {
                        point = arg0;
                        handleIn = arg1;
                        handleOut = arg2;
                    } else {
                        point = arg0 !== undefined ? [ arg0, arg1 ] : null;
                        handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
                        handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
                    }
                    new SegmentPoint(point, this, "_point");
                    new SegmentPoint(handleIn, this, "_handleIn");
                    new SegmentPoint(handleOut, this, "_handleOut");
                },
                _serialize: function(options) {
                    return Base.serialize(this.isLinear() ? this._point : [ this._point, this._handleIn, this._handleOut ], options, true);
                },
                _changed: function(point) {
                    var path = this._path;
                    if (!path) return;
                    var curves = path._curves, index = this._index, curve;
                    if (curves) {
                        if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null)) curve._changed();
                        if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index])) curve._changed();
                    }
                    path._changed(25);
                },
                getPoint: function() {
                    return this._point;
                },
                setPoint: function() {
                    var point = Point.read(arguments);
                    this._point.set(point.x, point.y);
                },
                getHandleIn: function() {
                    return this._handleIn;
                },
                setHandleIn: function() {
                    var point = Point.read(arguments);
                    this._handleIn.set(point.x, point.y);
                },
                getHandleOut: function() {
                    return this._handleOut;
                },
                setHandleOut: function() {
                    var point = Point.read(arguments);
                    this._handleOut.set(point.x, point.y);
                },
                isLinear: function() {
                    return this._handleIn.isZero() && this._handleOut.isZero();
                },
                setLinear: function(linear) {
                    if (linear) {
                        this._handleIn.set(0, 0);
                        this._handleOut.set(0, 0);
                    } else {}
                },
                isCollinear: function(segment) {
                    var next1 = this.getNext(), next2 = segment.getNext();
                    return this._handleOut.isZero() && next1._handleIn.isZero() && segment._handleOut.isZero() && next2._handleIn.isZero() && next1._point.subtract(this._point).isCollinear(next2._point.subtract(segment._point));
                },
                isColinear: "#isCollinear",
                isOrthogonal: function() {
                    var prev = this.getPrevious(), next = this.getNext();
                    return prev._handleOut.isZero() && this._handleIn.isZero() && this._handleOut.isZero() && next._handleIn.isZero() && this._point.subtract(prev._point).isOrthogonal(next._point.subtract(this._point));
                },
                isArc: function() {
                    var next = this.getNext(), handle1 = this._handleOut, handle2 = next._handleIn, kappa = .5522847498307936;
                    if (handle1.isOrthogonal(handle2)) {
                        var from = this._point, to = next._point, corner = new Line(from, handle1, true).intersect(new Line(to, handle2, true), true);
                        return corner && Numerical.isZero(handle1.getLength() / corner.subtract(from).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(to).getLength() - kappa);
                    }
                    return false;
                },
                _selectionState: 0,
                isSelected: function(_point) {
                    var state = this._selectionState;
                    return !_point ? !!(state & 7) : _point === this._point ? !!(state & 4) : _point === this._handleIn ? !!(state & 1) : _point === this._handleOut ? !!(state & 2) : false;
                },
                setSelected: function(selected, _point) {
                    var path = this._path, selected = !!selected, state = this._selectionState, oldState = state, flag = !_point ? 7 : _point === this._point ? 4 : _point === this._handleIn ? 1 : _point === this._handleOut ? 2 : 0;
                    if (selected) {
                        state |= flag;
                    } else {
                        state &= ~flag;
                    }
                    this._selectionState = state;
                    if (path && state !== oldState) {
                        path._updateSelection(this, oldState, state);
                        path._changed(129);
                    }
                },
                getIndex: function() {
                    return this._index !== undefined ? this._index : null;
                },
                getPath: function() {
                    return this._path || null;
                },
                getCurve: function() {
                    var path = this._path, index = this._index;
                    if (path) {
                        if (index > 0 && !path._closed && index === path._segments.length - 1) index--;
                        return path.getCurves()[index] || null;
                    }
                    return null;
                },
                getLocation: function() {
                    var curve = this.getCurve();
                    return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;
                },
                getNext: function() {
                    var segments = this._path && this._path._segments;
                    return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;
                },
                getPrevious: function() {
                    var segments = this._path && this._path._segments;
                    return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;
                },
                reverse: function() {
                    return new Segment(this._point, this._handleOut, this._handleIn);
                },
                remove: function() {
                    return this._path ? !!this._path.removeSegment(this._index) : false;
                },
                clone: function() {
                    return new Segment(this._point, this._handleIn, this._handleOut);
                },
                equals: function(segment) {
                    return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;
                },
                toString: function() {
                    var parts = [ "point: " + this._point ];
                    if (!this._handleIn.isZero()) parts.push("handleIn: " + this._handleIn);
                    if (!this._handleOut.isZero()) parts.push("handleOut: " + this._handleOut);
                    return "{ " + parts.join(", ") + " }";
                },
                transform: function(matrix) {
                    this._transformCoordinates(matrix, new Array(6), true);
                    this._changed();
                },
                _transformCoordinates: function(matrix, coords, change) {
                    var point = this._point, handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null, handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null, x = point._x, y = point._y, i = 2;
                    coords[0] = x;
                    coords[1] = y;
                    if (handleIn) {
                        coords[i++] = handleIn._x + x;
                        coords[i++] = handleIn._y + y;
                    }
                    if (handleOut) {
                        coords[i++] = handleOut._x + x;
                        coords[i++] = handleOut._y + y;
                    }
                    if (matrix) {
                        matrix._transformCoordinates(coords, coords, i / 2);
                        x = coords[0];
                        y = coords[1];
                        if (change) {
                            point._x = x;
                            point._y = y;
                            i = 2;
                            if (handleIn) {
                                handleIn._x = coords[i++] - x;
                                handleIn._y = coords[i++] - y;
                            }
                            if (handleOut) {
                                handleOut._x = coords[i++] - x;
                                handleOut._y = coords[i++] - y;
                            }
                        } else {
                            if (!handleIn) {
                                coords[i++] = x;
                                coords[i++] = y;
                            }
                            if (!handleOut) {
                                coords[i++] = x;
                                coords[i++] = y;
                            }
                        }
                    }
                    return coords;
                }
            });
            var SegmentPoint = Point.extend({
                initialize: function SegmentPoint(point, owner, key) {
                    var x, y, selected;
                    if (!point) {
                        x = y = 0;
                    } else if ((x = point[0]) !== undefined) {
                        y = point[1];
                    } else {
                        var pt = point;
                        if ((x = pt.x) === undefined) {
                            pt = Point.read(arguments);
                            x = pt.x;
                        }
                        y = pt.y;
                        selected = pt.selected;
                    }
                    this._x = x;
                    this._y = y;
                    this._owner = owner;
                    owner[key] = this;
                    if (selected) this.setSelected(true);
                },
                set: function(x, y) {
                    this._x = x;
                    this._y = y;
                    this._owner._changed(this);
                    return this;
                },
                _serialize: function(options) {
                    var f = options.formatter, x = f.number(this._x), y = f.number(this._y);
                    return this.isSelected() ? {
                        x: x,
                        y: y,
                        selected: true
                    } : [ x, y ];
                },
                getX: function() {
                    return this._x;
                },
                setX: function(x) {
                    this._x = x;
                    this._owner._changed(this);
                },
                getY: function() {
                    return this._y;
                },
                setY: function(y) {
                    this._y = y;
                    this._owner._changed(this);
                },
                isZero: function() {
                    return Numerical.isZero(this._x) && Numerical.isZero(this._y);
                },
                setSelected: function(selected) {
                    this._owner.setSelected(selected, this);
                },
                isSelected: function() {
                    return this._owner.isSelected(this);
                }
            });
            var Curve = Base.extend({
                _class: "Curve",
                initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
                    var count = arguments.length;
                    if (count === 3) {
                        this._path = arg0;
                        this._segment1 = arg1;
                        this._segment2 = arg2;
                    } else if (count === 0) {
                        this._segment1 = new Segment();
                        this._segment2 = new Segment();
                    } else if (count === 1) {
                        this._segment1 = new Segment(arg0.segment1);
                        this._segment2 = new Segment(arg0.segment2);
                    } else if (count === 2) {
                        this._segment1 = new Segment(arg0);
                        this._segment2 = new Segment(arg1);
                    } else {
                        var point1, handle1, handle2, point2;
                        if (count === 4) {
                            point1 = arg0;
                            handle1 = arg1;
                            handle2 = arg2;
                            point2 = arg3;
                        } else if (count === 8) {
                            point1 = [ arg0, arg1 ];
                            point2 = [ arg6, arg7 ];
                            handle1 = [ arg2 - arg0, arg3 - arg1 ];
                            handle2 = [ arg4 - arg6, arg5 - arg7 ];
                        }
                        this._segment1 = new Segment(point1, null, handle1);
                        this._segment2 = new Segment(point2, handle2, null);
                    }
                },
                _changed: function() {
                    this._length = this._bounds = undefined;
                },
                getPoint1: function() {
                    return this._segment1._point;
                },
                setPoint1: function() {
                    var point = Point.read(arguments);
                    this._segment1._point.set(point.x, point.y);
                },
                getPoint2: function() {
                    return this._segment2._point;
                },
                setPoint2: function() {
                    var point = Point.read(arguments);
                    this._segment2._point.set(point.x, point.y);
                },
                getHandle1: function() {
                    return this._segment1._handleOut;
                },
                setHandle1: function() {
                    var point = Point.read(arguments);
                    this._segment1._handleOut.set(point.x, point.y);
                },
                getHandle2: function() {
                    return this._segment2._handleIn;
                },
                setHandle2: function() {
                    var point = Point.read(arguments);
                    this._segment2._handleIn.set(point.x, point.y);
                },
                getSegment1: function() {
                    return this._segment1;
                },
                getSegment2: function() {
                    return this._segment2;
                },
                getPath: function() {
                    return this._path;
                },
                getIndex: function() {
                    return this._segment1._index;
                },
                getNext: function() {
                    var curves = this._path && this._path._curves;
                    return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;
                },
                getPrevious: function() {
                    var curves = this._path && this._path._curves;
                    return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;
                },
                isSelected: function() {
                    return this.getPoint1().isSelected() && this.getHandle2().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
                },
                setSelected: function(selected) {
                    this.getPoint1().setSelected(selected);
                    this.getHandle1().setSelected(selected);
                    this.getHandle2().setSelected(selected);
                    this.getPoint2().setSelected(selected);
                },
                getValues: function(matrix) {
                    return Curve.getValues(this._segment1, this._segment2, matrix);
                },
                getPoints: function() {
                    var coords = this.getValues(), points = [];
                    for (var i = 0; i < 8; i += 2) points.push(new Point(coords[i], coords[i + 1]));
                    return points;
                },
                getLength: function() {
                    if (this._length == null) {
                        this._length = this.isLinear() ? this._segment2._point.getDistance(this._segment1._point) : Curve.getLength(this.getValues(), 0, 1);
                    }
                    return this._length;
                },
                getArea: function() {
                    return Curve.getArea(this.getValues());
                },
                getPart: function(from, to) {
                    return new Curve(Curve.getPart(this.getValues(), from, to));
                },
                getPartLength: function(from, to) {
                    return Curve.getLength(this.getValues(), from, to);
                },
                isLinear: function() {
                    return this._segment1._handleOut.isZero() && this._segment2._handleIn.isZero();
                },
                getIntersections: function(curve) {
                    return Curve.filterIntersections(Curve.getIntersections(this.getValues(), curve.getValues(), this, curve, []));
                },
                _getParameter: function(offset, isParameter) {
                    return isParameter ? offset : offset && offset.curve === this ? offset.parameter : offset === undefined && isParameter === undefined ? .5 : this.getParameterAt(offset, 0);
                },
                divide: function(offset, isParameter, ignoreLinear) {
                    var parameter = this._getParameter(offset, isParameter), tolerance = 1e-6, res = null;
                    if (parameter > tolerance && parameter < 1 - tolerance) {
                        var parts = Curve.subdivide(this.getValues(), parameter), isLinear = ignoreLinear ? false : this.isLinear(), left = parts[0], right = parts[1];
                        if (!isLinear) {
                            this._segment1._handleOut.set(left[2] - left[0], left[3] - left[1]);
                            this._segment2._handleIn.set(right[4] - right[6], right[5] - right[7]);
                        }
                        var x = left[6], y = left[7], segment = new Segment(new Point(x, y), !isLinear && new Point(left[4] - x, left[5] - y), !isLinear && new Point(right[2] - x, right[3] - y));
                        if (this._path) {
                            if (this._segment1._index > 0 && this._segment2._index === 0) {
                                this._path.add(segment);
                            } else {
                                this._path.insert(this._segment2._index, segment);
                            }
                            res = this;
                        } else {
                            var end = this._segment2;
                            this._segment2 = segment;
                            res = new Curve(segment, end);
                        }
                    }
                    return res;
                },
                split: function(offset, isParameter) {
                    return this._path ? this._path.split(this._segment1._index, this._getParameter(offset, isParameter)) : null;
                },
                reverse: function() {
                    return new Curve(this._segment2.reverse(), this._segment1.reverse());
                },
                remove: function() {
                    var removed = false;
                    if (this._path) {
                        var segment2 = this._segment2, handleOut = segment2._handleOut;
                        removed = segment2.remove();
                        if (removed) this._segment1._handleOut.set(handleOut.x, handleOut.y);
                    }
                    return removed;
                },
                clone: function() {
                    return new Curve(this._segment1, this._segment2);
                },
                toString: function() {
                    var parts = [ "point1: " + this._segment1._point ];
                    if (!this._segment1._handleOut.isZero()) parts.push("handle1: " + this._segment1._handleOut);
                    if (!this._segment2._handleIn.isZero()) parts.push("handle2: " + this._segment2._handleIn);
                    parts.push("point2: " + this._segment2._point);
                    return "{ " + parts.join(", ") + " }";
                },
                statics: {
                    getValues: function(segment1, segment2, matrix) {
                        var p1 = segment1._point, h1 = segment1._handleOut, h2 = segment2._handleIn, p2 = segment2._point, values = [ p1._x, p1._y, p1._x + h1._x, p1._y + h1._y, p2._x + h2._x, p2._y + h2._y, p2._x, p2._y ];
                        if (matrix) matrix._transformCoordinates(values, values, 4);
                        return values;
                    },
                    evaluate: function(v, t, type) {
                        if (t == null || t < 0 || t > 1) return null;
                        var p1x = v[0], p1y = v[1], c1x = v[2], c1y = v[3], c2x = v[4], c2y = v[5], p2x = v[6], p2y = v[7], tolerance = 1e-6, x, y;
                        if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
                            var isZero = t < tolerance;
                            x = isZero ? p1x : p2x;
                            y = isZero ? p1y : p2y;
                        } else {
                            var cx = 3 * (c1x - p1x), bx = 3 * (c2x - c1x) - cx, ax = p2x - p1x - cx - bx, cy = 3 * (c1y - p1y), by = 3 * (c2y - c1y) - cy, ay = p2y - p1y - cy - by;
                            if (type === 0) {
                                x = ((ax * t + bx) * t + cx) * t + p1x;
                                y = ((ay * t + by) * t + cy) * t + p1y;
                            } else {
                                if (t < tolerance && c1x === p1x && c1y === p1y || t > 1 - tolerance && c2x === p2x && c2y === p2y) {
                                    x = c2x - c1x;
                                    y = c2y - c1y;
                                } else if (t < tolerance) {
                                    x = cx;
                                    y = cy;
                                } else if (t > 1 - tolerance) {
                                    x = 3 * (p2x - c2x);
                                    y = 3 * (p2y - c2y);
                                } else {
                                    x = (3 * ax * t + 2 * bx) * t + cx;
                                    y = (3 * ay * t + 2 * by) * t + cy;
                                }
                                if (type === 3) {
                                    var x2 = 6 * ax * t + 2 * bx, y2 = 6 * ay * t + 2 * by;
                                    return (x * y2 - y * x2) / Math.pow(x * x + y * y, 3 / 2);
                                }
                            }
                        }
                        return type === 2 ? new Point(y, -x) : new Point(x, y);
                    },
                    subdivide: function(v, t) {
                        var p1x = v[0], p1y = v[1], c1x = v[2], c1y = v[3], c2x = v[4], c2y = v[5], p2x = v[6], p2y = v[7];
                        if (t === undefined) t = .5;
                        var u = 1 - t, p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y, p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y, p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y, p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y, p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y, p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
                        return [ [ p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y ], [ p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y ] ];
                    },
                    solveCubic: function(v, coord, val, roots, min, max) {
                        var p1 = v[coord], c1 = v[coord + 2], c2 = v[coord + 4], p2 = v[coord + 6], c = 3 * (c1 - p1), b = 3 * (c2 - c1) - c, a = p2 - p1 - c - b, isZero = Numerical.isZero;
                        if (isZero(a) && isZero(b)) a = b = 0;
                        return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
                    },
                    getParameterOf: function(v, x, y) {
                        var tolerance = 1e-6;
                        if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance) return 0;
                        if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance) return 1;
                        var txs = [], tys = [], sx = Curve.solveCubic(v, 0, x, txs, 0, 1), sy = Curve.solveCubic(v, 1, y, tys, 0, 1), tx, ty;
                        for (var cx = 0; sx === -1 || cx < sx; ) {
                            if (sx === -1 || (tx = txs[cx++]) > 0 && tx < 1) {
                                for (var cy = 0; sy === -1 || cy < sy; ) {
                                    if (sy === -1 || (ty = tys[cy++]) > 0 && ty < 1) {
                                        if (sx === -1) {
                                            tx = ty;
                                        } else if (sy === -1) {
                                            ty = tx;
                                        }
                                        if (Math.abs(tx - ty) < tolerance) return (tx + ty) * .5;
                                    }
                                }
                                if (sx === -1) break;
                            }
                        }
                        return null;
                    },
                    getPart: function(v, from, to) {
                        if (from > 0) v = Curve.subdivide(v, from)[1];
                        if (to < 1) v = Curve.subdivide(v, (to - from) / (1 - from))[0];
                        return v;
                    },
                    isLinear: function(v) {
                        var isZero = Numerical.isZero;
                        return isZero(v[0] - v[2]) && isZero(v[1] - v[3]) && isZero(v[4] - v[6]) && isZero(v[5] - v[7]);
                    },
                    isFlatEnough: function(v, tolerance) {
                        var p1x = v[0], p1y = v[1], c1x = v[2], c1y = v[3], c2x = v[4], c2y = v[5], p2x = v[6], p2y = v[7], ux = 3 * c1x - 2 * p1x - p2x, uy = 3 * c1y - 2 * p1y - p2y, vx = 3 * c2x - 2 * p2x - p1x, vy = 3 * c2y - 2 * p2y - p1y;
                        return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) < 10 * tolerance * tolerance;
                    },
                    getArea: function(v) {
                        var p1x = v[0], p1y = v[1], c1x = v[2], c1y = v[3], c2x = v[4], c2y = v[5], p2x = v[6], p2y = v[7];
                        return (3 * c1y * p1x - 1.5 * c1y * c2x - 1.5 * c1y * p2x - 3 * p1y * c1x - 1.5 * p1y * c2x - .5 * p1y * p2x + 1.5 * c2y * p1x + 1.5 * c2y * c1x - 3 * c2y * p2x + .5 * p2y * p1x + 1.5 * p2y * c1x + 3 * p2y * c2x) / 10;
                    },
                    getEdgeSum: function(v) {
                        return (v[0] - v[2]) * (v[3] + v[1]) + (v[2] - v[4]) * (v[5] + v[3]) + (v[4] - v[6]) * (v[7] + v[5]);
                    },
                    getBounds: function(v) {
                        var min = v.slice(0, 2), max = min.slice(), roots = [ 0, 0 ];
                        for (var i = 0; i < 2; i++) Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);
                        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
                    },
                    _addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
                        function add(value, padding) {
                            var left = value - padding, right = value + padding;
                            if (left < min[coord]) min[coord] = left;
                            if (right > max[coord]) max[coord] = right;
                        }
                        var a = 3 * (v1 - v2) - v0 + v3, b = 2 * (v0 + v2) - 4 * v1, c = v1 - v0, count = Numerical.solveQuadratic(a, b, c, roots), tMin = 1e-6, tMax = 1 - tMin;
                        add(v3, 0);
                        for (var i = 0; i < count; i++) {
                            var t = roots[i], u = 1 - t;
                            if (tMin < t && t < tMax) add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding);
                        }
                    }
                }
            }, Base.each([ "getBounds", "getStrokeBounds", "getHandleBounds", "getRoughBounds" ], function(name) {
                this[name] = function() {
                    if (!this._bounds) this._bounds = {};
                    var bounds = this._bounds[name];
                    if (!bounds) {
                        bounds = this._bounds[name] = Path[name]([ this._segment1, this._segment2 ], false, this._path.getStyle());
                    }
                    return bounds.clone();
                };
            }, {}), Base.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(name, index) {
                this[name + "At"] = function(offset, isParameter) {
                    var values = this.getValues();
                    return Curve.evaluate(values, isParameter ? offset : Curve.getParameterAt(values, offset, 0), index);
                };
                this[name] = function(parameter) {
                    return Curve.evaluate(this.getValues(), parameter, index);
                };
            }, {
                beans: false,
                getParameterAt: function(offset, start) {
                    return Curve.getParameterAt(this.getValues(), offset, start);
                },
                getParameterOf: function() {
                    var point = Point.read(arguments);
                    return Curve.getParameterOf(this.getValues(), point.x, point.y);
                },
                getLocationAt: function(offset, isParameter) {
                    var t = isParameter ? offset : this.getParameterAt(offset);
                    return t != null && t >= 0 && t <= 1 ? new CurveLocation(this, t) : null;
                },
                getLocationOf: function() {
                    return this.getLocationAt(this.getParameterOf(Point.read(arguments)), true);
                },
                getOffsetOf: function() {
                    var loc = this.getLocationOf.apply(this, arguments);
                    return loc ? loc.getOffset() : null;
                },
                getNearestLocation: function() {
                    var point = Point.read(arguments), values = this.getValues(), count = 100, minDist = Infinity, minT = 0;
                    function refine(t) {
                        if (t >= 0 && t <= 1) {
                            var dist = point.getDistance(Curve.evaluate(values, t, 0), true);
                            if (dist < minDist) {
                                minDist = dist;
                                minT = t;
                                return true;
                            }
                        }
                    }
                    for (var i = 0; i <= count; i++) refine(i / count);
                    var step = 1 / (count * 2);
                    while (step > 1e-6) {
                        if (!refine(minT - step) && !refine(minT + step)) step /= 2;
                    }
                    var pt = Curve.evaluate(values, minT, 0);
                    return new CurveLocation(this, minT, pt, null, null, null, point.getDistance(pt));
                },
                getNearestPoint: function() {
                    return this.getNearestLocation.apply(this, arguments).getPoint();
                }
            }), new function() {
                function getLengthIntegrand(v) {
                    var p1x = v[0], p1y = v[1], c1x = v[2], c1y = v[3], c2x = v[4], c2y = v[5], p2x = v[6], p2y = v[7], ax = 9 * (c1x - c2x) + 3 * (p2x - p1x), bx = 6 * (p1x + c2x) - 12 * c1x, cx = 3 * (c1x - p1x), ay = 9 * (c1y - c2y) + 3 * (p2y - p1y), by = 6 * (p1y + c2y) - 12 * c1y, cy = 3 * (c1y - p1y);
                    return function(t) {
                        var dx = (ax * t + bx) * t + cx, dy = (ay * t + by) * t + cy;
                        return Math.sqrt(dx * dx + dy * dy);
                    };
                }
                function getIterations(a, b) {
                    return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
                }
                return {
                    statics: true,
                    getLength: function(v, a, b) {
                        if (a === undefined) a = 0;
                        if (b === undefined) b = 1;
                        var isZero = Numerical.isZero;
                        if (a === 0 && b === 1 && isZero(v[0] - v[2]) && isZero(v[1] - v[3]) && isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
                            var dx = v[6] - v[0], dy = v[7] - v[1];
                            return Math.sqrt(dx * dx + dy * dy);
                        }
                        var ds = getLengthIntegrand(v);
                        return Numerical.integrate(ds, a, b, getIterations(a, b));
                    },
                    getParameterAt: function(v, offset, start) {
                        if (start === undefined) start = offset < 0 ? 1 : 0;
                        if (offset === 0) return start;
                        var tolerance = 1e-6, abs = Math.abs, forward = offset > 0, a = forward ? start : 0, b = forward ? 1 : start, ds = getLengthIntegrand(v), rangeLength = Numerical.integrate(ds, a, b, getIterations(a, b));
                        if (abs(offset - rangeLength) < tolerance) {
                            return forward ? b : a;
                        } else if (abs(offset) > rangeLength) {
                            return null;
                        }
                        var guess = offset / rangeLength, length = 0;
                        function f(t) {
                            length += Numerical.integrate(ds, start, t, getIterations(start, t));
                            start = t;
                            return length - offset;
                        }
                        return Numerical.findRoot(f, ds, start + guess, a, b, 16, tolerance);
                    }
                };
            }(), new function() {
                function addLocation(locations, include, curve1, t1, point1, curve2, t2, point2) {
                    var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
                    if (!include || include(loc)) locations.push(loc);
                }
                function addCurveIntersections(v1, v2, curve1, curve2, locations, include, tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
                    if (recursion > 32) return;
                    var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7], tolerance = 1e-6, getSignedDistance = Line.getSignedDistance, d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0, d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0, factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9, dMin = factor * Math.min(0, d1, d2), dMax = factor * Math.max(0, d1, d2), dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]), dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]), dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]), dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]), tMinNew, tMaxNew, tDiff;
                    if (q0x === q3x && uMax - uMin < tolerance && recursion > 3) {
                        tMaxNew = tMinNew = (tMax + tMin) / 2;
                        tDiff = 0;
                    } else {
                        var hull = getConvexHull(dp0, dp1, dp2, dp3), top = hull[0], bottom = hull[1], tMinClip, tMaxClip;
                        tMinClip = clipConvexHull(top, bottom, dMin, dMax);
                        top.reverse();
                        bottom.reverse();
                        tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
                        if (tMinClip == null || tMaxClip == null) return;
                        v1 = Curve.getPart(v1, tMinClip, tMaxClip);
                        tDiff = tMaxClip - tMinClip;
                        tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
                        tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
                    }
                    if (oldTDiff > .5 && tDiff > .5) {
                        if (tMaxNew - tMinNew > uMax - uMin) {
                            var parts = Curve.subdivide(v1, .5), t = tMinNew + (tMaxNew - tMinNew) / 2;
                            addCurveIntersections(v2, parts[0], curve2, curve1, locations, include, uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
                            addCurveIntersections(v2, parts[1], curve2, curve1, locations, include, uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
                        } else {
                            var parts = Curve.subdivide(v2, .5), t = uMin + (uMax - uMin) / 2;
                            addCurveIntersections(parts[0], v1, curve2, curve1, locations, include, uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
                            addCurveIntersections(parts[1], v1, curve2, curve1, locations, include, t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
                        }
                    } else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
                        var t1 = tMinNew + (tMaxNew - tMinNew) / 2, t2 = uMin + (uMax - uMin) / 2;
                        if (reverse) {
                            addLocation(locations, include, curve2, t2, Curve.evaluate(v2, t2, 0), curve1, t1, Curve.evaluate(v1, t1, 0));
                        } else {
                            addLocation(locations, include, curve1, t1, Curve.evaluate(v1, t1, 0), curve2, t2, Curve.evaluate(v2, t2, 0));
                        }
                    } else if (tDiff > 0) {
                        addCurveIntersections(v2, v1, curve2, curve1, locations, include, uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
                    }
                }
                function getConvexHull(dq0, dq1, dq2, dq3) {
                    var p0 = [ 0, dq0 ], p1 = [ 1 / 3, dq1 ], p2 = [ 2 / 3, dq2 ], p3 = [ 1, dq3 ], getSignedDistance = Line.getSignedDistance, dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1), dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2), flip = false, hull;
                    if (dist1 * dist2 < 0) {
                        hull = [ [ p0, p1, p3 ], [ p0, p2, p3 ] ];
                        flip = dist1 < 0;
                    } else {
                        var pmax, cross = 0, distZero = dist1 === 0 || dist2 === 0;
                        if (Math.abs(dist1) > Math.abs(dist2)) {
                            pmax = p1;
                            cross = (dq3 - dq2 - (dq3 - dq0) / 3) * (2 * (dq3 - dq2) - dq3 + dq1) / 3;
                        } else {
                            pmax = p2;
                            cross = (dq1 - dq0 + (dq0 - dq3) / 3) * (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
                        }
                        hull = cross < 0 || distZero ? [ [ p0, pmax, p3 ], [ p0, p3 ] ] : [ [ p0, p1, p2, p3 ], [ p0, p3 ] ];
                        flip = dist1 ? dist1 < 0 : dist2 < 0;
                    }
                    return flip ? hull.reverse() : hull;
                }
                function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
                    if (hullTop[0][1] < dMin) {
                        return clipConvexHullPart(hullTop, true, dMin);
                    } else if (hullBottom[0][1] > dMax) {
                        return clipConvexHullPart(hullBottom, false, dMax);
                    } else {
                        return hullTop[0][0];
                    }
                }
                function clipConvexHullPart(part, top, threshold) {
                    var px = part[0][0], py = part[0][1];
                    for (var i = 1, l = part.length; i < l; i++) {
                        var qx = part[i][0], qy = part[i][1];
                        if (top ? qy >= threshold : qy <= threshold) return px + (threshold - py) * (qx - px) / (qy - py);
                        px = qx;
                        py = qy;
                    }
                    return null;
                }
                function addCurveLineIntersections(v1, v2, curve1, curve2, locations, include) {
                    var flip = Curve.isLinear(v1), vc = flip ? v2 : v1, vl = flip ? v1 : v2, lx1 = vl[0], ly1 = vl[1], lx2 = vl[6], ly2 = vl[7], ldx = lx2 - lx1, ldy = ly2 - ly1, angle = Math.atan2(-ldy, ldx), sin = Math.sin(angle), cos = Math.cos(angle), rlx2 = ldx * cos - ldy * sin, rvl = [ 0, 0, 0, 0, rlx2, 0, rlx2, 0 ], rvc = [];
                    for (var i = 0; i < 8; i += 2) {
                        var x = vc[i] - lx1, y = vc[i + 1] - ly1;
                        rvc.push(x * cos - y * sin, y * cos + x * sin);
                    }
                    var roots = [], count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
                    for (var i = 0; i < count; i++) {
                        var tc = roots[i], x = Curve.evaluate(rvc, tc, 0).x;
                        if (x >= 0 && x <= rlx2) {
                            var tl = Curve.getParameterOf(rvl, x, 0), t1 = flip ? tl : tc, t2 = flip ? tc : tl;
                            addLocation(locations, include, curve1, t1, Curve.evaluate(v1, t1, 0), curve2, t2, Curve.evaluate(v2, t2, 0));
                        }
                    }
                }
                function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
                    var point = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);
                    if (point) {
                        var x = point.x, y = point.y;
                        addLocation(locations, include, curve1, Curve.getParameterOf(v1, x, y), point, curve2, Curve.getParameterOf(v2, x, y), point);
                    }
                }
                return {
                    statics: {
                        getIntersections: function(v1, v2, c1, c2, locations, include) {
                            var linear1 = Curve.isLinear(v1), linear2 = Curve.isLinear(v2), c1p1 = c1.getPoint1(), c1p2 = c1.getPoint2(), c2p1 = c2.getPoint1(), c2p2 = c2.getPoint2(), tolerance = 1e-6;
                            if (c1p1.isClose(c2p1, tolerance)) addLocation(locations, include, c1, 0, c1p1, c2, 0, c1p1);
                            if (c1p1.isClose(c2p2, tolerance)) addLocation(locations, include, c1, 0, c1p1, c2, 1, c1p1);
                            (linear1 && linear2 ? addLineIntersection : linear1 || linear2 ? addCurveLineIntersections : addCurveIntersections)(v1, v2, c1, c2, locations, include, 0, 1, 0, 1, 0, false, 0);
                            if (c1p2.isClose(c2p1, tolerance)) addLocation(locations, include, c1, 1, c1p2, c2, 0, c1p2);
                            if (c1p2.isClose(c2p2, tolerance)) addLocation(locations, include, c1, 1, c1p2, c2, 1, c1p2);
                            return locations;
                        },
                        filterIntersections: function(locations, _expand) {
                            var last = locations.length - 1, tMax = 1 - 1e-6;
                            for (var i = last; i >= 0; i--) {
                                var loc = locations[i], next = loc._curve.getNext(), next2 = loc._curve2.getNext();
                                if (next && loc._parameter >= tMax) {
                                    loc._parameter = 0;
                                    loc._curve = next;
                                }
                                if (next2 && loc._parameter2 >= tMax) {
                                    loc._parameter2 = 0;
                                    loc._curve2 = next2;
                                }
                            }
                            function compare(loc1, loc2) {
                                var path1 = loc1.getPath(), path2 = loc2.getPath();
                                return path1 === path2 ? loc1.getIndex() + loc1.getParameter() - (loc2.getIndex() + loc2.getParameter()) : path1._id - path2._id;
                            }
                            if (last > 0) {
                                locations.sort(compare);
                                for (var i = last; i > 0; i--) {
                                    if (locations[i].equals(locations[i - 1])) {
                                        locations.splice(i, 1);
                                        last--;
                                    }
                                }
                            }
                            if (_expand) {
                                for (var i = last; i >= 0; i--) locations.push(locations[i].getIntersection());
                                locations.sort(compare);
                            }
                            return locations;
                        }
                    }
                };
            }());
            var CurveLocation = Base.extend({
                _class: "CurveLocation",
                beans: true,
                initialize: function CurveLocation(curve, parameter, point, _curve2, _parameter2, _point2, _distance) {
                    this._id = UID.get(CurveLocation);
                    var path = curve._path;
                    this._version = path ? path._version : 0;
                    this._curve = curve;
                    this._parameter = parameter;
                    this._point = point || curve.getPointAt(parameter, true);
                    this._curve2 = _curve2;
                    this._parameter2 = _parameter2;
                    this._point2 = _point2;
                    this._distance = _distance;
                    this._segment1 = curve._segment1;
                    this._segment2 = curve._segment2;
                },
                getSegment: function(_preferFirst) {
                    if (!this._segment) {
                        var curve = this.getCurve(), parameter = this.getParameter();
                        if (parameter === 1) {
                            this._segment = curve._segment2;
                        } else if (parameter === 0 || _preferFirst) {
                            this._segment = curve._segment1;
                        } else if (parameter == null) {
                            return null;
                        } else {
                            this._segment = curve.getPartLength(0, parameter) < curve.getPartLength(parameter, 1) ? curve._segment1 : curve._segment2;
                        }
                    }
                    return this._segment;
                },
                getCurve: function() {
                    var curve = this._curve, path = curve && curve._path;
                    if (path && path._version !== this._version) {
                        curve = null;
                        this._parameter = null;
                    }
                    if (!curve) {
                        curve = this._segment1.getCurve();
                        if (curve.getParameterOf(this._point) == null) curve = this._segment2.getPrevious().getCurve();
                        this._curve = curve;
                        path = curve._path;
                        this._version = path ? path._version : 0;
                    }
                    return curve;
                },
                getPath: function() {
                    var curve = this.getCurve();
                    return curve && curve._path;
                },
                getIndex: function() {
                    var curve = this.getCurve();
                    return curve && curve.getIndex();
                },
                getParameter: function() {
                    var curve = this.getCurve(), parameter = this._parameter;
                    return curve && parameter == null ? this._parameter = curve.getParameterOf(this._point) : parameter;
                },
                getPoint: function() {
                    return this._point;
                },
                getOffset: function() {
                    var path = this.getPath();
                    return path ? path._getOffset(this) : this.getCurveOffset();
                },
                getCurveOffset: function() {
                    var curve = this.getCurve(), parameter = this.getParameter();
                    return parameter != null && curve && curve.getPartLength(0, parameter);
                },
                getIntersection: function() {
                    var intersection = this._intersection;
                    if (!intersection && this._curve2) {
                        this._intersection = intersection = new CurveLocation(this._curve2, this._parameter2, this._point2 || this._point, this);
                        intersection._intersection = this;
                    }
                    return intersection;
                },
                getDistance: function() {
                    return this._distance;
                },
                divide: function() {
                    var curve = this.getCurve();
                    return curve && curve.divide(this.getParameter(), true);
                },
                split: function() {
                    var curve = this.getCurve();
                    return curve && curve.split(this.getParameter(), true);
                },
                equals: function(loc) {
                    var abs = Math.abs, tolerance = 1e-6;
                    return this === loc || loc instanceof CurveLocation && this.getCurve() === loc.getCurve() && abs(this.getParameter() - loc.getParameter()) < tolerance && this._curve2 === loc._curve2 && abs(this._parameter2 - loc._parameter2) < tolerance || false;
                },
                toString: function() {
                    var parts = [], point = this.getPoint(), f = Formatter.instance;
                    if (point) parts.push("point: " + point);
                    var index = this.getIndex();
                    if (index != null) parts.push("index: " + index);
                    var parameter = this.getParameter();
                    if (parameter != null) parts.push("parameter: " + f.number(parameter));
                    if (this._distance != null) parts.push("distance: " + f.number(this._distance));
                    return "{ " + parts.join(", ") + " }";
                }
            }, Base.each([ "getTangent", "getNormal", "getCurvature" ], function(name) {
                var get = name + "At";
                this[name] = function() {
                    var parameter = this.getParameter(), curve = this.getCurve();
                    return parameter != null && curve && curve[get](parameter, true);
                };
            }, {}));
            var PathItem = Item.extend({
                _class: "PathItem",
                initialize: function PathItem() {},
                getIntersections: function(path, _matrix, _expand) {
                    if (this === path) path = null;
                    var locations = [], curves1 = this.getCurves(), curves2 = path ? path.getCurves() : curves1, matrix1 = this._matrix.orNullIfIdentity(), matrix2 = path ? (_matrix || path._matrix).orNullIfIdentity() : matrix1, length1 = curves1.length, length2 = path ? curves2.length : length1, values2 = [], tMin = 1e-6, tMax = 1 - tMin;
                    if (path && !this.getBounds(matrix1).touches(path.getBounds(matrix2))) return [];
                    for (var i = 0; i < length2; i++) values2[i] = curves2[i].getValues(matrix2);
                    for (var i = 0; i < length1; i++) {
                        var curve1 = curves1[i], values1 = path ? curve1.getValues(matrix1) : values2[i];
                        if (!path) {
                            var seg1 = curve1.getSegment1(), seg2 = curve1.getSegment2(), h1 = seg1._handleOut, h2 = seg2._handleIn;
                            if (new Line(seg1._point.subtract(h1), h1.multiply(2), true).intersect(new Line(seg2._point.subtract(h2), h2.multiply(2), true), false)) {
                                var parts = Curve.subdivide(values1);
                                Curve.getIntersections(parts[0], parts[1], curve1, curve1, locations, function(loc) {
                                    if (loc._parameter <= tMax) {
                                        loc._parameter /= 2;
                                        loc._parameter2 = .5 + loc._parameter2 / 2;
                                        return true;
                                    }
                                });
                            }
                        }
                        for (var j = path ? 0 : i + 1; j < length2; j++) {
                            Curve.getIntersections(values1, values2[j], curve1, curves2[j], locations, !path && (j === i + 1 || j === length2 - 1 && i === 0) && function(loc) {
                                var t = loc._parameter;
                                return t >= tMin && t <= tMax;
                            });
                        }
                    }
                    return Curve.filterIntersections(locations, _expand);
                },
                _asPathItem: function() {
                    return this;
                },
                setPathData: function(data) {
                    var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/gi), coords, relative = false, previous, control, current = new Point(), start = new Point();
                    function getCoord(index, coord) {
                        var val = +coords[index];
                        if (relative) val += current[coord];
                        return val;
                    }
                    function getPoint(index) {
                        return new Point(getCoord(index, "x"), getCoord(index + 1, "y"));
                    }
                    this.clear();
                    for (var i = 0, l = parts && parts.length; i < l; i++) {
                        var part = parts[i], command = part[0], lower = command.toLowerCase();
                        coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
                        var length = coords && coords.length;
                        relative = command === lower;
                        if (previous === "z" && !/[mz]/.test(lower)) this.moveTo(current = start);
                        switch (lower) {
                          case "m":
                          case "l":
                            var move = lower === "m";
                            for (var j = 0; j < length; j += 2) this[j === 0 && move ? "moveTo" : "lineTo"](current = getPoint(j));
                            control = current;
                            if (move) start = current;
                            break;

                          case "h":
                          case "v":
                            var coord = lower === "h" ? "x" : "y";
                            for (var j = 0; j < length; j++) {
                                current[coord] = getCoord(j, coord);
                                this.lineTo(current);
                            }
                            control = current;
                            break;

                          case "c":
                            for (var j = 0; j < length; j += 6) {
                                this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));
                            }
                            break;

                          case "s":
                            for (var j = 0; j < length; j += 4) {
                                this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2));
                                previous = lower;
                            }
                            break;

                          case "q":
                            for (var j = 0; j < length; j += 4) {
                                this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));
                            }
                            break;

                          case "t":
                            for (var j = 0; j < length; j += 2) {
                                this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j));
                                previous = lower;
                            }
                            break;

                          case "a":
                            for (var j = 0; j < length; j += 7) {
                                this.arcTo(current = getPoint(j + 5), new Size(+coords[j], +coords[j + 1]), +coords[j + 2], +coords[j + 4], +coords[j + 3]);
                            }
                            break;

                          case "z":
                            this.closePath(true);
                            break;
                        }
                        previous = lower;
                    }
                },
                _canComposite: function() {
                    return !(this.hasFill() && this.hasStroke());
                },
                _contains: function(point) {
                    var winding = this._getWinding(point, false, true);
                    return !!(this.getWindingRule() === "evenodd" ? winding & 1 : winding);
                }
            });
            var Path = PathItem.extend({
                _class: "Path",
                _serializeFields: {
                    segments: [],
                    closed: false
                },
                initialize: function Path(arg) {
                    this._closed = false;
                    this._segments = [];
                    this._version = 0;
                    var segments = Array.isArray(arg) ? typeof arg[0] === "object" ? arg : arguments : arg && (arg.size === undefined && (arg.x !== undefined || arg.point !== undefined)) ? arguments : null;
                    if (segments && segments.length > 0) {
                        this.setSegments(segments);
                    } else {
                        this._curves = undefined;
                        this._selectedSegmentState = 0;
                        if (!segments && typeof arg === "string") {
                            this.setPathData(arg);
                            arg = null;
                        }
                    }
                    this._initialize(!segments && arg);
                },
                _equals: function(item) {
                    return this._closed === item._closed && Base.equals(this._segments, item._segments);
                },
                clone: function(insert) {
                    var copy = new Path(Item.NO_INSERT);
                    copy.setSegments(this._segments);
                    copy._closed = this._closed;
                    if (this._clockwise !== undefined) copy._clockwise = this._clockwise;
                    return this._clone(copy, insert);
                },
                _changed: function _changed(flags) {
                    _changed.base.call(this, flags);
                    if (flags & 8) {
                        var parent = this._parent;
                        if (parent) parent._currentPath = undefined;
                        this._length = this._clockwise = undefined;
                        if (flags & 16) {
                            this._version++;
                        } else if (this._curves) {
                            for (var i = 0, l = this._curves.length; i < l; i++) this._curves[i]._changed();
                        }
                        this._monoCurves = undefined;
                    } else if (flags & 32) {
                        this._bounds = undefined;
                    }
                },
                getStyle: function() {
                    var parent = this._parent;
                    return (parent instanceof CompoundPath ? parent : this)._style;
                },
                getSegments: function() {
                    return this._segments;
                },
                setSegments: function(segments) {
                    var fullySelected = this.isFullySelected();
                    this._segments.length = 0;
                    this._selectedSegmentState = 0;
                    this._curves = undefined;
                    if (segments && segments.length > 0) this._add(Segment.readAll(segments));
                    if (fullySelected) this.setFullySelected(true);
                },
                getFirstSegment: function() {
                    return this._segments[0];
                },
                getLastSegment: function() {
                    return this._segments[this._segments.length - 1];
                },
                getCurves: function() {
                    var curves = this._curves, segments = this._segments;
                    if (!curves) {
                        var length = this._countCurves();
                        curves = this._curves = new Array(length);
                        for (var i = 0; i < length; i++) curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0]);
                    }
                    return curves;
                },
                getFirstCurve: function() {
                    return this.getCurves()[0];
                },
                getLastCurve: function() {
                    var curves = this.getCurves();
                    return curves[curves.length - 1];
                },
                isClosed: function() {
                    return this._closed;
                },
                setClosed: function(closed) {
                    if (this._closed != (closed = !!closed)) {
                        this._closed = closed;
                        if (this._curves) {
                            var length = this._curves.length = this._countCurves();
                            if (closed) this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);
                        }
                        this._changed(25);
                    }
                }
            }, {
                beans: true,
                getPathData: function(_matrix, _precision) {
                    var segments = this._segments, length = segments.length, f = new Formatter(_precision), coords = new Array(6), first = true, curX, curY, prevX, prevY, inX, inY, outX, outY, parts = [];
                    function addSegment(segment, skipLine) {
                        segment._transformCoordinates(_matrix, coords, false);
                        curX = coords[0];
                        curY = coords[1];
                        if (first) {
                            parts.push("M" + f.pair(curX, curY));
                            first = false;
                        } else {
                            inX = coords[2];
                            inY = coords[3];
                            if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
                                if (!skipLine) parts.push("l" + f.pair(curX - prevX, curY - prevY));
                            } else {
                                parts.push("c" + f.pair(outX - prevX, outY - prevY) + " " + f.pair(inX - prevX, inY - prevY) + " " + f.pair(curX - prevX, curY - prevY));
                            }
                        }
                        prevX = curX;
                        prevY = curY;
                        outX = coords[4];
                        outY = coords[5];
                    }
                    if (length === 0) return "";
                    for (var i = 0; i < length; i++) addSegment(segments[i]);
                    if (this._closed && length > 0) {
                        addSegment(segments[0], true);
                        parts.push("z");
                    }
                    return parts.join("");
                }
            }, {
                isEmpty: function() {
                    return this._segments.length === 0;
                },
                isPolygon: function() {
                    for (var i = 0, l = this._segments.length; i < l; i++) {
                        if (!this._segments[i].isLinear()) return false;
                    }
                    return true;
                },
                _transformContent: function(matrix) {
                    var coords = new Array(6);
                    for (var i = 0, l = this._segments.length; i < l; i++) this._segments[i]._transformCoordinates(matrix, coords, true);
                    return true;
                },
                _add: function(segs, index) {
                    var segments = this._segments, curves = this._curves, amount = segs.length, append = index == null, index = append ? segments.length : index;
                    for (var i = 0; i < amount; i++) {
                        var segment = segs[i];
                        if (segment._path) segment = segs[i] = segment.clone();
                        segment._path = this;
                        segment._index = index + i;
                        if (segment._selectionState) this._updateSelection(segment, 0, segment._selectionState);
                    }
                    if (append) {
                        segments.push.apply(segments, segs);
                    } else {
                        segments.splice.apply(segments, [ index, 0 ].concat(segs));
                        for (var i = index + amount, l = segments.length; i < l; i++) segments[i]._index = i;
                    }
                    if (curves || segs._curves) {
                        if (!curves) curves = this._curves = [];
                        var from = index > 0 ? index - 1 : index, start = from, to = Math.min(from + amount, this._countCurves());
                        if (segs._curves) {
                            curves.splice.apply(curves, [ from, 0 ].concat(segs._curves));
                            start += segs._curves.length;
                        }
                        for (var i = start; i < to; i++) curves.splice(i, 0, new Curve(this, null, null));
                        this._adjustCurves(from, to);
                    }
                    this._changed(25);
                    return segs;
                },
                _adjustCurves: function(from, to) {
                    var segments = this._segments, curves = this._curves, curve;
                    for (var i = from; i < to; i++) {
                        curve = curves[i];
                        curve._path = this;
                        curve._segment1 = segments[i];
                        curve._segment2 = segments[i + 1] || segments[0];
                        curve._changed();
                    }
                    if (curve = curves[this._closed && from === 0 ? segments.length - 1 : from - 1]) {
                        curve._segment2 = segments[from] || segments[0];
                        curve._changed();
                    }
                    if (curve = curves[to]) {
                        curve._segment1 = segments[to];
                        curve._changed();
                    }
                },
                _countCurves: function() {
                    var length = this._segments.length;
                    return !this._closed && length > 0 ? length - 1 : length;
                },
                add: function(segment1) {
                    return arguments.length > 1 && typeof segment1 !== "number" ? this._add(Segment.readAll(arguments)) : this._add([ Segment.read(arguments) ])[0];
                },
                insert: function(index, segment1) {
                    return arguments.length > 2 && typeof segment1 !== "number" ? this._add(Segment.readAll(arguments, 1), index) : this._add([ Segment.read(arguments, 1) ], index)[0];
                },
                addSegment: function() {
                    return this._add([ Segment.read(arguments) ])[0];
                },
                insertSegment: function(index) {
                    return this._add([ Segment.read(arguments, 1) ], index)[0];
                },
                addSegments: function(segments) {
                    return this._add(Segment.readAll(segments));
                },
                insertSegments: function(index, segments) {
                    return this._add(Segment.readAll(segments), index);
                },
                removeSegment: function(index) {
                    return this.removeSegments(index, index + 1)[0] || null;
                },
                removeSegments: function(from, to, _includeCurves) {
                    from = from || 0;
                    to = Base.pick(to, this._segments.length);
                    var segments = this._segments, curves = this._curves, count = segments.length, removed = segments.splice(from, to - from), amount = removed.length;
                    if (!amount) return removed;
                    for (var i = 0; i < amount; i++) {
                        var segment = removed[i];
                        if (segment._selectionState) this._updateSelection(segment, segment._selectionState, 0);
                        segment._index = segment._path = null;
                    }
                    for (var i = from, l = segments.length; i < l; i++) segments[i]._index = i;
                    if (curves) {
                        var index = from > 0 && to === count + (this._closed ? 1 : 0) ? from - 1 : from, curves = curves.splice(index, amount);
                        if (_includeCurves) removed._curves = curves.slice(1);
                        this._adjustCurves(index, index);
                    }
                    this._changed(25);
                    return removed;
                },
                clear: "#removeSegments",
                getLength: function() {
                    if (this._length == null) {
                        var curves = this.getCurves();
                        this._length = 0;
                        for (var i = 0, l = curves.length; i < l; i++) this._length += curves[i].getLength();
                    }
                    return this._length;
                },
                getArea: function() {
                    var curves = this.getCurves();
                    var area = 0;
                    for (var i = 0, l = curves.length; i < l; i++) area += curves[i].getArea();
                    return area;
                },
                isFullySelected: function() {
                    var length = this._segments.length;
                    return this._selected && length > 0 && this._selectedSegmentState === length * 7;
                },
                setFullySelected: function(selected) {
                    if (selected) this._selectSegments(true);
                    this.setSelected(selected);
                },
                setSelected: function setSelected(selected) {
                    if (!selected) this._selectSegments(false);
                    setSelected.base.call(this, selected);
                },
                _selectSegments: function(selected) {
                    var length = this._segments.length;
                    this._selectedSegmentState = selected ? length * 7 : 0;
                    for (var i = 0; i < length; i++) this._segments[i]._selectionState = selected ? 7 : 0;
                },
                _updateSelection: function(segment, oldState, newState) {
                    segment._selectionState = newState;
                    var total = this._selectedSegmentState += newState - oldState;
                    if (total > 0) this.setSelected(true);
                },
                flatten: function(maxDistance) {
                    var iterator = new PathIterator(this, 64, .1), pos = 0, step = iterator.length / Math.ceil(iterator.length / maxDistance), end = iterator.length + (this._closed ? -step : step) / 2;
                    var segments = [];
                    while (pos <= end) {
                        segments.push(new Segment(iterator.evaluate(pos, 0)));
                        pos += step;
                    }
                    this.setSegments(segments);
                },
                reduce: function() {
                    var curves = this.getCurves();
                    for (var i = curves.length - 1; i >= 0; i--) {
                        var curve = curves[i];
                        if (curve.isLinear() && curve.getLength() === 0) curve.remove();
                    }
                    return this;
                },
                simplify: function(tolerance) {
                    if (this._segments.length > 2) {
                        var fitter = new PathFitter(this, tolerance || 2.5);
                        this.setSegments(fitter.fit());
                    }
                },
                split: function(index, parameter) {
                    if (parameter === null) return null;
                    if (arguments.length === 1) {
                        var arg = index;
                        if (typeof arg === "number") arg = this.getLocationAt(arg);
                        if (!arg) return null;
                        index = arg.index;
                        parameter = arg.parameter;
                    }
                    var tolerance = 1e-6;
                    if (parameter >= 1 - tolerance) {
                        index++;
                        parameter--;
                    }
                    var curves = this.getCurves();
                    if (index >= 0 && index < curves.length) {
                        if (parameter > tolerance) {
                            curves[index++].divide(parameter, true);
                        }
                        var segs = this.removeSegments(index, this._segments.length, true), path;
                        if (this._closed) {
                            this.setClosed(false);
                            path = this;
                        } else {
                            path = this._clone(new Path().insertAbove(this, true));
                        }
                        path._add(segs, 0);
                        this.addSegment(segs[0]);
                        return path;
                    }
                    return null;
                },
                isClockwise: function() {
                    if (this._clockwise !== undefined) return this._clockwise;
                    return Path.isClockwise(this._segments);
                },
                setClockwise: function(clockwise) {
                    if (this.isClockwise() != (clockwise = !!clockwise)) this.reverse();
                    this._clockwise = clockwise;
                },
                reverse: function() {
                    this._segments.reverse();
                    for (var i = 0, l = this._segments.length; i < l; i++) {
                        var segment = this._segments[i];
                        var handleIn = segment._handleIn;
                        segment._handleIn = segment._handleOut;
                        segment._handleOut = handleIn;
                        segment._index = i;
                    }
                    this._curves = null;
                    if (this._clockwise !== undefined) this._clockwise = !this._clockwise;
                    this._changed(9);
                },
                join: function(path) {
                    if (path) {
                        var segments = path._segments, last1 = this.getLastSegment(), last2 = path.getLastSegment();
                        if (!last2) return this;
                        if (last1 && last1._point.equals(last2._point)) path.reverse();
                        var first2 = path.getFirstSegment();
                        if (last1 && last1._point.equals(first2._point)) {
                            last1.setHandleOut(first2._handleOut);
                            this._add(segments.slice(1));
                        } else {
                            var first1 = this.getFirstSegment();
                            if (first1 && first1._point.equals(first2._point)) path.reverse();
                            last2 = path.getLastSegment();
                            if (first1 && first1._point.equals(last2._point)) {
                                first1.setHandleIn(last2._handleIn);
                                this._add(segments.slice(0, segments.length - 1), 0);
                            } else {
                                this._add(segments.slice());
                            }
                        }
                        if (path.closed) this._add([ segments[0] ]);
                        path.remove();
                    }
                    var first = this.getFirstSegment(), last = this.getLastSegment();
                    if (first !== last && first._point.equals(last._point)) {
                        first.setHandleIn(last._handleIn);
                        last.remove();
                        this.setClosed(true);
                    }
                    return this;
                },
                toShape: function(insert) {
                    if (!this._closed) return null;
                    var segments = this._segments, type, size, radius, topCenter;
                    function isCollinear(i, j) {
                        return segments[i].isCollinear(segments[j]);
                    }
                    function isOrthogonal(i) {
                        return segments[i].isOrthogonal();
                    }
                    function isArc(i) {
                        return segments[i].isArc();
                    }
                    function getDistance(i, j) {
                        return segments[i]._point.getDistance(segments[j]._point);
                    }
                    if (this.isPolygon() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
                        type = Shape.Rectangle;
                        size = new Size(getDistance(0, 3), getDistance(0, 1));
                        topCenter = segments[1]._point.add(segments[2]._point).divide(2);
                    } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
                        type = Shape.Rectangle;
                        size = new Size(getDistance(1, 6), getDistance(0, 3));
                        radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);
                        topCenter = segments[3]._point.add(segments[4]._point).divide(2);
                    } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
                        if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
                            type = Shape.Circle;
                            radius = getDistance(0, 2) / 2;
                        } else {
                            type = Shape.Ellipse;
                            radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
                        }
                        topCenter = segments[1]._point;
                    }
                    if (type) {
                        var center = this.getPosition(true), shape = this._clone(new type({
                            center: center,
                            size: size,
                            radius: radius,
                            insert: false
                        }), insert, false);
                        shape.rotate(topCenter.subtract(center).getAngle() + 90);
                        return shape;
                    }
                    return null;
                },
                _hitTestSelf: function(point, options) {
                    var that = this, style = this.getStyle(), segments = this._segments, numSegments = segments.length, closed = this._closed, tolerancePadding = options._tolerancePadding, strokePadding = tolerancePadding, join, cap, miterLimit, area, loc, res, hitStroke = options.stroke && style.hasStroke(), hitFill = options.fill && style.hasFill(), hitCurves = options.curves, radius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;
                    if (radius !== null) {
                        if (radius > 0) {
                            join = style.getStrokeJoin();
                            cap = style.getStrokeCap();
                            miterLimit = radius * style.getMiterLimit();
                            strokePadding = tolerancePadding.add(new Point(radius, radius));
                        } else {
                            join = cap = "round";
                        }
                    }
                    function isCloseEnough(pt, padding) {
                        return point.subtract(pt).divide(padding).length <= 1;
                    }
                    function checkSegmentPoint(seg, pt, name) {
                        if (!options.selected || pt.isSelected()) {
                            var anchor = seg._point;
                            if (pt !== anchor) pt = pt.add(anchor);
                            if (isCloseEnough(pt, strokePadding)) {
                                return new HitResult(name, that, {
                                    segment: seg,
                                    point: pt
                                });
                            }
                        }
                    }
                    function checkSegmentPoints(seg, ends) {
                        return (ends || options.segments) && checkSegmentPoint(seg, seg._point, "segment") || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, "handle-in") || checkSegmentPoint(seg, seg._handleOut, "handle-out"));
                    }
                    function addToArea(point) {
                        area.add(point);
                    }
                    function checkSegmentStroke(segment) {
                        if (join !== "round" || cap !== "round") {
                            area = new Path({
                                internal: true,
                                closed: true
                            });
                            if (closed || segment._index > 0 && segment._index < numSegments - 1) {
                                if (join !== "round" && (segment._handleIn.isZero() || segment._handleOut.isZero())) Path._addBevelJoin(segment, join, radius, miterLimit, addToArea, true);
                            } else if (cap !== "round") {
                                Path._addSquareCap(segment, cap, radius, addToArea, true);
                            }
                            if (!area.isEmpty()) {
                                var loc;
                                return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding);
                            }
                        }
                        return isCloseEnough(segment._point, strokePadding);
                    }
                    if (options.ends && !options.segments && !closed) {
                        if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true)) return res;
                    } else if (options.segments || options.handles) {
                        for (var i = 0; i < numSegments; i++) if (res = checkSegmentPoints(segments[i])) return res;
                    }
                    if (radius !== null) {
                        loc = this.getNearestLocation(point);
                        if (loc) {
                            var parameter = loc.getParameter();
                            if (parameter === 0 || parameter === 1 && numSegments > 1) {
                                if (!checkSegmentStroke(loc.getSegment())) loc = null;
                            } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
                                loc = null;
                            }
                        }
                        if (!loc && join === "miter" && numSegments > 1) {
                            for (var i = 0; i < numSegments; i++) {
                                var segment = segments[i];
                                if (point.getDistance(segment._point) <= miterLimit && checkSegmentStroke(segment)) {
                                    loc = segment.getLocation();
                                    break;
                                }
                            }
                        }
                    }
                    return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult("fill", this) : loc ? new HitResult(hitStroke ? "stroke" : "curve", this, {
                        location: loc,
                        point: loc.getPoint()
                    }) : null;
                }
            }, Base.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(name) {
                this[name + "At"] = function(offset, isParameter) {
                    var loc = this.getLocationAt(offset, isParameter);
                    return loc && loc[name]();
                };
            }, {
                beans: false,
                _getOffset: function(location) {
                    var index = location && location.getIndex();
                    if (index != null) {
                        var curves = this.getCurves(), offset = 0;
                        for (var i = 0; i < index; i++) offset += curves[i].getLength();
                        var curve = curves[index], parameter = location.getParameter();
                        if (parameter > 0) offset += curve.getPartLength(0, parameter);
                        return offset;
                    }
                    return null;
                },
                getLocationOf: function() {
                    var point = Point.read(arguments), curves = this.getCurves();
                    for (var i = 0, l = curves.length; i < l; i++) {
                        var loc = curves[i].getLocationOf(point);
                        if (loc) return loc;
                    }
                    return null;
                },
                getOffsetOf: function() {
                    var loc = this.getLocationOf.apply(this, arguments);
                    return loc ? loc.getOffset() : null;
                },
                getLocationAt: function(offset, isParameter) {
                    var curves = this.getCurves(), length = 0;
                    if (isParameter) {
                        var index = ~~offset;
                        return curves[index].getLocationAt(offset - index, true);
                    }
                    for (var i = 0, l = curves.length; i < l; i++) {
                        var start = length, curve = curves[i];
                        length += curve.getLength();
                        if (length > offset) {
                            return curve.getLocationAt(offset - start);
                        }
                    }
                    if (offset <= this.getLength()) return new CurveLocation(curves[curves.length - 1], 1);
                    return null;
                },
                getNearestLocation: function() {
                    var point = Point.read(arguments), curves = this.getCurves(), minDist = Infinity, minLoc = null;
                    for (var i = 0, l = curves.length; i < l; i++) {
                        var loc = curves[i].getNearestLocation(point);
                        if (loc._distance < minDist) {
                            minDist = loc._distance;
                            minLoc = loc;
                        }
                    }
                    return minLoc;
                },
                getNearestPoint: function() {
                    return this.getNearestLocation.apply(this, arguments).getPoint();
                }
            }), new function() {
                function drawHandles(ctx, segments, matrix, size) {
                    var half = size / 2;
                    function drawHandle(index) {
                        var hX = coords[index], hY = coords[index + 1];
                        if (pX != hX || pY != hY) {
                            ctx.beginPath();
                            ctx.moveTo(pX, pY);
                            ctx.lineTo(hX, hY);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
                            ctx.fill();
                        }
                    }
                    var coords = new Array(6);
                    for (var i = 0, l = segments.length; i < l; i++) {
                        var segment = segments[i];
                        segment._transformCoordinates(matrix, coords, false);
                        var state = segment._selectionState, pX = coords[0], pY = coords[1];
                        if (state & 1) drawHandle(2);
                        if (state & 2) drawHandle(4);
                        ctx.fillRect(pX - half, pY - half, size, size);
                        if (!(state & 4)) {
                            var fillStyle = ctx.fillStyle;
                            ctx.fillStyle = "#ffffff";
                            ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
                            ctx.fillStyle = fillStyle;
                        }
                    }
                }
                function drawSegments(ctx, path, matrix) {
                    var segments = path._segments, length = segments.length, coords = new Array(6), first = true, curX, curY, prevX, prevY, inX, inY, outX, outY;
                    function drawSegment(segment) {
                        if (matrix) {
                            segment._transformCoordinates(matrix, coords, false);
                            curX = coords[0];
                            curY = coords[1];
                        } else {
                            var point = segment._point;
                            curX = point._x;
                            curY = point._y;
                        }
                        if (first) {
                            ctx.moveTo(curX, curY);
                            first = false;
                        } else {
                            if (matrix) {
                                inX = coords[2];
                                inY = coords[3];
                            } else {
                                var handle = segment._handleIn;
                                inX = curX + handle._x;
                                inY = curY + handle._y;
                            }
                            if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
                                ctx.lineTo(curX, curY);
                            } else {
                                ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
                            }
                        }
                        prevX = curX;
                        prevY = curY;
                        if (matrix) {
                            outX = coords[4];
                            outY = coords[5];
                        } else {
                            var handle = segment._handleOut;
                            outX = prevX + handle._x;
                            outY = prevY + handle._y;
                        }
                    }
                    for (var i = 0; i < length; i++) drawSegment(segments[i]);
                    if (path._closed && length > 0) drawSegment(segments[0]);
                }
                return {
                    _draw: function(ctx, param, strokeMatrix) {
                        var dontStart = param.dontStart, dontPaint = param.dontFinish || param.clip, style = this.getStyle(), hasFill = style.hasFill(), hasStroke = style.hasStroke(), dashArray = style.getDashArray(), dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;
                        if (!dontStart) ctx.beginPath();
                        if (!dontStart && this._currentPath) {
                            ctx.currentPath = this._currentPath;
                        } else if (hasFill || hasStroke && !dashLength || dontPaint) {
                            drawSegments(ctx, this, strokeMatrix);
                            if (this._closed) ctx.closePath();
                            if (!dontStart) this._currentPath = ctx.currentPath;
                        }
                        function getOffset(i) {
                            return dashArray[(i % dashLength + dashLength) % dashLength];
                        }
                        if (!dontPaint && (hasFill || hasStroke)) {
                            this._setStyles(ctx);
                            if (hasFill) {
                                ctx.fill(style.getWindingRule());
                                ctx.shadowColor = "rgba(0,0,0,0)";
                            }
                            if (hasStroke) {
                                if (dashLength) {
                                    if (!dontStart) ctx.beginPath();
                                    var iterator = new PathIterator(this, 32, .25, strokeMatrix), length = iterator.length, from = -style.getDashOffset(), to, i = 0;
                                    from = from % length;
                                    while (from > 0) {
                                        from -= getOffset(i--) + getOffset(i--);
                                    }
                                    while (from < length) {
                                        to = from + getOffset(i++);
                                        if (from > 0 || to > 0) iterator.drawPart(ctx, Math.max(from, 0), Math.max(to, 0));
                                        from = to + getOffset(i++);
                                    }
                                }
                                ctx.stroke();
                            }
                        }
                    },
                    _drawSelected: function(ctx, matrix) {
                        ctx.beginPath();
                        drawSegments(ctx, this, matrix);
                        ctx.stroke();
                        drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
                    }
                };
            }(), new function() {
                function getFirstControlPoints(rhs) {
                    var n = rhs.length, x = [], tmp = [], b = 2;
                    x[0] = rhs[0] / b;
                    for (var i = 1; i < n; i++) {
                        tmp[i] = 1 / b;
                        b = (i < n - 1 ? 4 : 2) - tmp[i];
                        x[i] = (rhs[i] - x[i - 1]) / b;
                    }
                    for (var i = 1; i < n; i++) {
                        x[n - i - 1] -= tmp[n - i] * x[n - i];
                    }
                    return x;
                }
                return {
                    smooth: function() {
                        var segments = this._segments, size = segments.length, closed = this._closed, n = size, overlap = 0;
                        if (size <= 2) return;
                        if (closed) {
                            overlap = Math.min(size, 4);
                            n += Math.min(size, overlap) * 2;
                        }
                        var knots = [];
                        for (var i = 0; i < size; i++) knots[i + overlap] = segments[i]._point;
                        if (closed) {
                            for (var i = 0; i < overlap; i++) {
                                knots[i] = segments[i + size - overlap]._point;
                                knots[i + size + overlap] = segments[i]._point;
                            }
                        } else {
                            n--;
                        }
                        var rhs = [];
                        for (var i = 1; i < n - 1; i++) rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
                        rhs[0] = knots[0]._x + 2 * knots[1]._x;
                        rhs[n - 1] = 3 * knots[n - 1]._x;
                        var x = getFirstControlPoints(rhs);
                        for (var i = 1; i < n - 1; i++) rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
                        rhs[0] = knots[0]._y + 2 * knots[1]._y;
                        rhs[n - 1] = 3 * knots[n - 1]._y;
                        var y = getFirstControlPoints(rhs);
                        if (closed) {
                            for (var i = 0, j = size; i < overlap; i++, j++) {
                                var f1 = i / overlap, f2 = 1 - f1, ie = i + overlap, je = j + overlap;
                                x[j] = x[i] * f1 + x[j] * f2;
                                y[j] = y[i] * f1 + y[j] * f2;
                                x[je] = x[ie] * f2 + x[je] * f1;
                                y[je] = y[ie] * f2 + y[je] * f1;
                            }
                            n--;
                        }
                        var handleIn = null;
                        for (var i = overlap; i <= n - overlap; i++) {
                            var segment = segments[i - overlap];
                            if (handleIn) segment.setHandleIn(handleIn.subtract(segment._point));
                            if (i < n) {
                                segment.setHandleOut(new Point(x[i], y[i]).subtract(segment._point));
                                handleIn = i < n - 1 ? new Point(2 * knots[i + 1]._x - x[i + 1], 2 * knots[i + 1]._y - y[i + 1]) : new Point((knots[n]._x + x[n - 1]) / 2, (knots[n]._y + y[n - 1]) / 2);
                            }
                        }
                        if (closed && handleIn) {
                            var segment = this._segments[0];
                            segment.setHandleIn(handleIn.subtract(segment._point));
                        }
                    }
                };
            }(), new function() {
                function getCurrentSegment(that) {
                    var segments = that._segments;
                    if (segments.length === 0) throw new Error("Use a moveTo() command first");
                    return segments[segments.length - 1];
                }
                return {
                    moveTo: function() {
                        var segments = this._segments;
                        if (segments.length === 1) this.removeSegment(0);
                        if (!segments.length) this._add([ new Segment(Point.read(arguments)) ]);
                    },
                    moveBy: function() {
                        throw new Error("moveBy() is unsupported on Path items.");
                    },
                    lineTo: function() {
                        this._add([ new Segment(Point.read(arguments)) ]);
                    },
                    cubicCurveTo: function() {
                        var handle1 = Point.read(arguments), handle2 = Point.read(arguments), to = Point.read(arguments), current = getCurrentSegment(this);
                        current.setHandleOut(handle1.subtract(current._point));
                        this._add([ new Segment(to, handle2.subtract(to)) ]);
                    },
                    quadraticCurveTo: function() {
                        var handle = Point.read(arguments), to = Point.read(arguments), current = getCurrentSegment(this)._point;
                        this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to);
                    },
                    curveTo: function() {
                        var through = Point.read(arguments), to = Point.read(arguments), t = Base.pick(Base.read(arguments), .5), t1 = 1 - t, current = getCurrentSegment(this)._point, handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);
                        if (handle.isNaN()) throw new Error("Cannot put a curve through points with parameter = " + t);
                        this.quadraticCurveTo(handle, to);
                    },
                    arcTo: function() {
                        var current = getCurrentSegment(this), from = current._point, to = Point.read(arguments), through, peek = Base.peek(arguments), clockwise = Base.pick(peek, true), center, extent, vector, matrix;
                        if (typeof clockwise === "boolean") {
                            var middle = from.add(to).divide(2), through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
                        } else if (Base.remain(arguments) <= 2) {
                            through = to;
                            to = Point.read(arguments);
                        } else {
                            var radius = Size.read(arguments);
                            if (radius.isZero()) return this.lineTo(to);
                            var rotation = Base.read(arguments), clockwise = !!Base.read(arguments), large = !!Base.read(arguments), middle = from.add(to).divide(2), pt = from.subtract(middle).rotate(-rotation), x = pt.x, y = pt.y, abs = Math.abs, epsilon = 1e-12, rx = abs(radius.width), ry = abs(radius.height), rxSq = rx * rx, rySq = ry * ry, xSq = x * x, ySq = y * y;
                            var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
                            if (factor > 1) {
                                rx *= factor;
                                ry *= factor;
                                rxSq = rx * rx;
                                rySq = ry * ry;
                            }
                            factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);
                            if (abs(factor) < epsilon) factor = 0;
                            if (factor < 0) throw new Error("Cannot create an arc with the given arguments");
                            center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * Math.sqrt(factor)).rotate(rotation).add(middle);
                            matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);
                            vector = matrix._inverseTransform(from);
                            extent = vector.getDirectedAngle(matrix._inverseTransform(to));
                            if (!clockwise && extent > 0) extent -= 360; else if (clockwise && extent < 0) extent += 360;
                        }
                        if (through) {
                            var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true), l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), true), line = new Line(from, to), throughSide = line.getSide(through);
                            center = l1.intersect(l2, true);
                            if (!center) {
                                if (!throughSide) return this.lineTo(to);
                                throw new Error("Cannot create an arc with the given arguments");
                            }
                            vector = from.subtract(center);
                            extent = vector.getDirectedAngle(to.subtract(center));
                            var centerSide = line.getSide(center);
                            if (centerSide === 0) {
                                extent = throughSide * Math.abs(extent);
                            } else if (throughSide === centerSide) {
                                extent += extent < 0 ? 360 : -360;
                            }
                        }
                        var ext = Math.abs(extent), count = ext >= 360 ? 4 : Math.ceil(ext / 90), inc = extent / count, half = inc * Math.PI / 360, z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)), segments = [];
                        for (var i = 0; i <= count; i++) {
                            var pt = to, out = null;
                            if (i < count) {
                                out = vector.rotate(90).multiply(z);
                                if (matrix) {
                                    pt = matrix._transformPoint(vector);
                                    out = matrix._transformPoint(vector.add(out)).subtract(pt);
                                } else {
                                    pt = center.add(vector);
                                }
                            }
                            if (i === 0) {
                                current.setHandleOut(out);
                            } else {
                                var _in = vector.rotate(-90).multiply(z);
                                if (matrix) {
                                    _in = matrix._transformPoint(vector.add(_in)).subtract(pt);
                                }
                                segments.push(new Segment(pt, _in, out));
                            }
                            vector = vector.rotate(inc);
                        }
                        this._add(segments);
                    },
                    lineBy: function() {
                        var to = Point.read(arguments), current = getCurrentSegment(this)._point;
                        this.lineTo(current.add(to));
                    },
                    curveBy: function() {
                        var through = Point.read(arguments), to = Point.read(arguments), parameter = Base.read(arguments), current = getCurrentSegment(this)._point;
                        this.curveTo(current.add(through), current.add(to), parameter);
                    },
                    cubicCurveBy: function() {
                        var handle1 = Point.read(arguments), handle2 = Point.read(arguments), to = Point.read(arguments), current = getCurrentSegment(this)._point;
                        this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to));
                    },
                    quadraticCurveBy: function() {
                        var handle = Point.read(arguments), to = Point.read(arguments), current = getCurrentSegment(this)._point;
                        this.quadraticCurveTo(current.add(handle), current.add(to));
                    },
                    arcBy: function() {
                        var current = getCurrentSegment(this)._point, point = current.add(Point.read(arguments)), clockwise = Base.pick(Base.peek(arguments), true);
                        if (typeof clockwise === "boolean") {
                            this.arcTo(point, clockwise);
                        } else {
                            this.arcTo(point, current.add(Point.read(arguments)));
                        }
                    },
                    closePath: function(join) {
                        this.setClosed(true);
                        if (join) this.join();
                    }
                };
            }(), {
                _getBounds: function(getter, matrix) {
                    return Path[getter](this._segments, this._closed, this.getStyle(), matrix);
                },
                statics: {
                    isClockwise: function(segments) {
                        var sum = 0;
                        for (var i = 0, l = segments.length; i < l; i++) sum += Curve.getEdgeSum(Curve.getValues(segments[i], segments[i + 1 < l ? i + 1 : 0]));
                        return sum > 0;
                    },
                    getBounds: function(segments, closed, style, matrix, strokePadding) {
                        var first = segments[0];
                        if (!first) return new Rectangle();
                        var coords = new Array(6), prevCoords = first._transformCoordinates(matrix, new Array(6), false), min = prevCoords.slice(0, 2), max = min.slice(), roots = new Array(2);
                        function processSegment(segment) {
                            segment._transformCoordinates(matrix, coords, false);
                            for (var i = 0; i < 2; i++) {
                                Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);
                            }
                            var tmp = prevCoords;
                            prevCoords = coords;
                            coords = tmp;
                        }
                        for (var i = 1, l = segments.length; i < l; i++) processSegment(segments[i]);
                        if (closed) processSegment(first);
                        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
                    },
                    getStrokeBounds: function(segments, closed, style, matrix) {
                        if (!style.hasStroke()) return Path.getBounds(segments, closed, style, matrix);
                        var length = segments.length - (closed ? 0 : 1), radius = style.getStrokeWidth() / 2, padding = Path._getPenPadding(radius, matrix), bounds = Path.getBounds(segments, closed, style, matrix, padding), join = style.getStrokeJoin(), cap = style.getStrokeCap(), miterLimit = radius * style.getMiterLimit();
                        var joinBounds = new Rectangle(new Size(padding).multiply(2));
                        function add(point) {
                            bounds = bounds.include(matrix ? matrix._transformPoint(point, point) : point);
                        }
                        function addRound(segment) {
                            bounds = bounds.unite(joinBounds.setCenter(matrix ? matrix._transformPoint(segment._point) : segment._point));
                        }
                        function addJoin(segment, join) {
                            var handleIn = segment._handleIn, handleOut = segment._handleOut;
                            if (join === "round" || !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut)) {
                                addRound(segment);
                            } else {
                                Path._addBevelJoin(segment, join, radius, miterLimit, add);
                            }
                        }
                        function addCap(segment, cap) {
                            if (cap === "round") {
                                addRound(segment);
                            } else {
                                Path._addSquareCap(segment, cap, radius, add);
                            }
                        }
                        for (var i = 1; i < length; i++) addJoin(segments[i], join);
                        if (closed) {
                            addJoin(segments[0], join);
                        } else if (length > 0) {
                            addCap(segments[0], cap);
                            addCap(segments[segments.length - 1], cap);
                        }
                        return bounds;
                    },
                    _getPenPadding: function(radius, matrix) {
                        if (!matrix) return [ radius, radius ];
                        var mx = matrix.shiftless(), hor = mx.transform(new Point(radius, 0)), ver = mx.transform(new Point(0, radius)), phi = hor.getAngleInRadians(), a = hor.getLength(), b = ver.getLength();
                        var sin = Math.sin(phi), cos = Math.cos(phi), tan = Math.tan(phi), tx = -Math.atan(b * tan / a), ty = Math.atan(b / (tan * a));
                        return [ Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin), Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin) ];
                    },
                    _addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
                        var curve2 = segment.getCurve(), curve1 = curve2.getPrevious(), point = curve2.getPointAt(0, true), normal1 = curve1.getNormalAt(1, true), normal2 = curve2.getNormalAt(0, true), step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
                        normal1.setLength(step);
                        normal2.setLength(step);
                        if (area) {
                            addPoint(point);
                            addPoint(point.add(normal1));
                        }
                        if (join === "miter") {
                            var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);
                            if (corner && point.getDistance(corner) <= miterLimit) {
                                addPoint(corner);
                                if (!area) return;
                            }
                        }
                        if (!area) addPoint(point.add(normal1));
                        addPoint(point.add(normal2));
                    },
                    _addSquareCap: function(segment, cap, radius, addPoint, area) {
                        var point = segment._point, loc = segment.getLocation(), normal = loc.getNormal().normalize(radius);
                        if (area) {
                            addPoint(point.subtract(normal));
                            addPoint(point.add(normal));
                        }
                        if (cap === "square") point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
                        addPoint(point.add(normal));
                        addPoint(point.subtract(normal));
                    },
                    getHandleBounds: function(segments, closed, style, matrix, strokePadding, joinPadding) {
                        var coords = new Array(6), x1 = Infinity, x2 = -x1, y1 = x1, y2 = x2;
                        for (var i = 0, l = segments.length; i < l; i++) {
                            var segment = segments[i];
                            segment._transformCoordinates(matrix, coords, false);
                            for (var j = 0; j < 6; j += 2) {
                                var padding = j === 0 ? joinPadding : strokePadding, paddingX = padding ? padding[0] : 0, paddingY = padding ? padding[1] : 0, x = coords[j], y = coords[j + 1], xn = x - paddingX, xx = x + paddingX, yn = y - paddingY, yx = y + paddingY;
                                if (xn < x1) x1 = xn;
                                if (xx > x2) x2 = xx;
                                if (yn < y1) y1 = yn;
                                if (yx > y2) y2 = yx;
                            }
                        }
                        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
                    },
                    getRoughBounds: function(segments, closed, style, matrix) {
                        var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0, joinRadius = strokeRadius;
                        if (strokeRadius > 0) {
                            if (style.getStrokeJoin() === "miter") joinRadius = strokeRadius * style.getMiterLimit();
                            if (style.getStrokeCap() === "square") joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
                        }
                        return Path.getHandleBounds(segments, closed, style, matrix, Path._getPenPadding(strokeRadius, matrix), Path._getPenPadding(joinRadius, matrix));
                    }
                }
            });
            Path.inject({
                statics: new function() {
                    var kappa = .5522847498307936, ellipseSegments = [ new Segment([ -1, 0 ], [ 0, kappa ], [ 0, -kappa ]), new Segment([ 0, -1 ], [ -kappa, 0 ], [ kappa, 0 ]), new Segment([ 1, 0 ], [ 0, -kappa ], [ 0, kappa ]), new Segment([ 0, 1 ], [ kappa, 0 ], [ -kappa, 0 ]) ];
                    function createPath(segments, closed, args) {
                        var props = Base.getNamed(args), path = new Path(props && props.insert === false && Item.NO_INSERT);
                        path._add(segments);
                        path._closed = closed;
                        return path.set(props);
                    }
                    function createEllipse(center, radius, args) {
                        var segments = new Array(4);
                        for (var i = 0; i < 4; i++) {
                            var segment = ellipseSegments[i];
                            segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));
                        }
                        return createPath(segments, true, args);
                    }
                    return {
                        Line: function() {
                            return createPath([ new Segment(Point.readNamed(arguments, "from")), new Segment(Point.readNamed(arguments, "to")) ], false, arguments);
                        },
                        Circle: function() {
                            var center = Point.readNamed(arguments, "center"), radius = Base.readNamed(arguments, "radius");
                            return createEllipse(center, new Size(radius), arguments);
                        },
                        Rectangle: function() {
                            var rect = Rectangle.readNamed(arguments, "rectangle"), radius = Size.readNamed(arguments, "radius", 0, {
                                readNull: true
                            }), bl = rect.getBottomLeft(true), tl = rect.getTopLeft(true), tr = rect.getTopRight(true), br = rect.getBottomRight(true), segments;
                            if (!radius || radius.isZero()) {
                                segments = [ new Segment(bl), new Segment(tl), new Segment(tr), new Segment(br) ];
                            } else {
                                radius = Size.min(radius, rect.getSize(true).divide(2));
                                var rx = radius.width, ry = radius.height, hx = rx * kappa, hy = ry * kappa;
                                segments = [ new Segment(bl.add(rx, 0), null, [ -hx, 0 ]), new Segment(bl.subtract(0, ry), [ 0, hy ]), new Segment(tl.add(0, ry), null, [ 0, -hy ]), new Segment(tl.add(rx, 0), [ -hx, 0 ], null), new Segment(tr.subtract(rx, 0), null, [ hx, 0 ]), new Segment(tr.add(0, ry), [ 0, -hy ], null), new Segment(br.subtract(0, ry), null, [ 0, hy ]), new Segment(br.subtract(rx, 0), [ hx, 0 ]) ];
                            }
                            return createPath(segments, true, arguments);
                        },
                        RoundRectangle: "#Rectangle",
                        Ellipse: function() {
                            var ellipse = Shape._readEllipse(arguments);
                            return createEllipse(ellipse.center, ellipse.radius, arguments);
                        },
                        Oval: "#Ellipse",
                        Arc: function() {
                            var from = Point.readNamed(arguments, "from"), through = Point.readNamed(arguments, "through"), to = Point.readNamed(arguments, "to"), props = Base.getNamed(arguments), path = new Path(props && props.insert === false && Item.NO_INSERT);
                            path.moveTo(from);
                            path.arcTo(through, to);
                            return path.set(props);
                        },
                        RegularPolygon: function() {
                            var center = Point.readNamed(arguments, "center"), sides = Base.readNamed(arguments, "sides"), radius = Base.readNamed(arguments, "radius"), step = 360 / sides, three = !(sides % 3), vector = new Point(0, three ? -radius : radius), offset = three ? -1 : .5, segments = new Array(sides);
                            for (var i = 0; i < sides; i++) segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));
                            return createPath(segments, true, arguments);
                        },
                        Star: function() {
                            var center = Point.readNamed(arguments, "center"), points = Base.readNamed(arguments, "points") * 2, radius1 = Base.readNamed(arguments, "radius1"), radius2 = Base.readNamed(arguments, "radius2"), step = 360 / points, vector = new Point(0, -1), segments = new Array(points);
                            for (var i = 0; i < points; i++) segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));
                            return createPath(segments, true, arguments);
                        }
                    };
                }()
            });
            var CompoundPath = PathItem.extend({
                _class: "CompoundPath",
                _serializeFields: {
                    children: []
                },
                initialize: function CompoundPath(arg) {
                    this._children = [];
                    this._namedChildren = {};
                    if (!this._initialize(arg)) {
                        if (typeof arg === "string") {
                            this.setPathData(arg);
                        } else {
                            this.addChildren(Array.isArray(arg) ? arg : arguments);
                        }
                    }
                },
                insertChildren: function insertChildren(index, items, _preserve) {
                    items = insertChildren.base.call(this, index, items, _preserve, Path);
                    for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
                        var item = items[i];
                        if (item._clockwise === undefined) item.setClockwise(item._index === 0);
                    }
                    return items;
                },
                reverse: function() {
                    var children = this._children;
                    for (var i = 0, l = children.length; i < l; i++) children[i].reverse();
                },
                smooth: function() {
                    for (var i = 0, l = this._children.length; i < l; i++) this._children[i].smooth();
                },
                reduce: function reduce() {
                    if (this._children.length === 0) {
                        var path = new Path(Item.NO_INSERT);
                        path.insertAbove(this);
                        path.setStyle(this._style);
                        this.remove();
                        return path;
                    } else {
                        return reduce.base.call(this);
                    }
                },
                isClockwise: function() {
                    var child = this.getFirstChild();
                    return child && child.isClockwise();
                },
                setClockwise: function(clockwise) {
                    if (this.isClockwise() !== !!clockwise) this.reverse();
                },
                getFirstSegment: function() {
                    var first = this.getFirstChild();
                    return first && first.getFirstSegment();
                },
                getLastSegment: function() {
                    var last = this.getLastChild();
                    return last && last.getLastSegment();
                },
                getCurves: function() {
                    var children = this._children, curves = [];
                    for (var i = 0, l = children.length; i < l; i++) curves.push.apply(curves, children[i].getCurves());
                    return curves;
                },
                getFirstCurve: function() {
                    var first = this.getFirstChild();
                    return first && first.getFirstCurve();
                },
                getLastCurve: function() {
                    var last = this.getLastChild();
                    return last && last.getFirstCurve();
                },
                getArea: function() {
                    var children = this._children, area = 0;
                    for (var i = 0, l = children.length; i < l; i++) area += children[i].getArea();
                    return area;
                }
            }, {
                beans: true,
                getPathData: function(_matrix, _precision) {
                    var children = this._children, paths = [];
                    for (var i = 0, l = children.length; i < l; i++) {
                        var child = children[i], mx = child._matrix;
                        paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.chain(mx) : mx, _precision));
                    }
                    return paths.join(" ");
                }
            }, {
                _getChildHitTestOptions: function(options) {
                    return options.class === Path || options.type === "path" ? options : new Base(options, {
                        fill: false
                    });
                },
                _draw: function(ctx, param, strokeMatrix) {
                    var children = this._children;
                    if (children.length === 0) return;
                    if (this._currentPath) {
                        ctx.currentPath = this._currentPath;
                    } else {
                        param = param.extend({
                            dontStart: true,
                            dontFinish: true
                        });
                        ctx.beginPath();
                        for (var i = 0, l = children.length; i < l; i++) children[i].draw(ctx, param, strokeMatrix);
                        this._currentPath = ctx.currentPath;
                    }
                    if (!param.clip) {
                        this._setStyles(ctx);
                        var style = this._style;
                        if (style.hasFill()) {
                            ctx.fill(style.getWindingRule());
                            ctx.shadowColor = "rgba(0,0,0,0)";
                        }
                        if (style.hasStroke()) ctx.stroke();
                    }
                },
                _drawSelected: function(ctx, matrix, selectedItems) {
                    var children = this._children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        var child = children[i], mx = child._matrix;
                        if (!selectedItems[child._id]) child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.chain(mx));
                    }
                }
            }, new function() {
                function getCurrentPath(that, check) {
                    var children = that._children;
                    if (check && children.length === 0) throw new Error("Use a moveTo() command first");
                    return children[children.length - 1];
                }
                var fields = {
                    moveTo: function() {
                        var current = getCurrentPath(this), path = current && current.isEmpty() ? current : new Path();
                        if (path !== current) this.addChild(path);
                        path.moveTo.apply(path, arguments);
                    },
                    moveBy: function() {
                        var current = getCurrentPath(this, true), last = current && current.getLastSegment(), point = Point.read(arguments);
                        this.moveTo(last ? point.add(last._point) : point);
                    },
                    closePath: function(join) {
                        getCurrentPath(this, true).closePath(join);
                    }
                };
                Base.each([ "lineTo", "cubicCurveTo", "quadraticCurveTo", "curveTo", "arcTo", "lineBy", "cubicCurveBy", "quadraticCurveBy", "curveBy", "arcBy" ], function(key) {
                    fields[key] = function() {
                        var path = getCurrentPath(this, true);
                        path[key].apply(path, arguments);
                    };
                });
                return fields;
            }());
            PathItem.inject(new function() {
                var operators = {
                    unite: function(w) {
                        return w === 1 || w === 0;
                    },
                    intersect: function(w) {
                        return w === 2;
                    },
                    subtract: function(w) {
                        return w === 1;
                    },
                    exclude: function(w) {
                        return w === 1;
                    }
                };
                function computeBoolean(path1, path2, operation) {
                    var operator = operators[operation];
                    function preparePath(path) {
                        return path.clone(false).reduce().reorient().transform(null, true, true);
                    }
                    var _path1 = preparePath(path1), _path2 = path2 && path1 !== path2 && preparePath(path2);
                    if (_path2 && /^(subtract|exclude)$/.test(operation) ^ _path2.isClockwise() !== _path1.isClockwise()) _path2.reverse();
                    splitPath(_path1.getIntersections(_path2, null, true));
                    var chain = [], segments = [], monoCurves = [], tolerance = 1e-6;
                    function collect(paths) {
                        for (var i = 0, l = paths.length; i < l; i++) {
                            var path = paths[i];
                            segments.push.apply(segments, path._segments);
                            monoCurves.push.apply(monoCurves, path._getMonoCurves());
                        }
                    }
                    collect(_path1._children || [ _path1 ]);
                    if (_path2) collect(_path2._children || [ _path2 ]);
                    segments.sort(function(a, b) {
                        var _a = a._intersection, _b = b._intersection;
                        return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
                    });
                    for (var i = 0, l = segments.length; i < l; i++) {
                        var segment = segments[i];
                        if (segment._winding != null) continue;
                        chain.length = 0;
                        var startSeg = segment, totalLength = 0, windingSum = 0;
                        do {
                            var length = segment.getCurve().getLength();
                            chain.push({
                                segment: segment,
                                length: length
                            });
                            totalLength += length;
                            segment = segment.getNext();
                        } while (segment && !segment._intersection && segment !== startSeg);
                        for (var j = 0; j < 3; j++) {
                            var length = totalLength * (j + 1) / 4;
                            for (k = 0, m = chain.length; k < m; k++) {
                                var node = chain[k], curveLength = node.length;
                                if (length <= curveLength) {
                                    if (length < tolerance || curveLength - length < tolerance) length = curveLength / 2;
                                    var curve = node.segment.getCurve(), pt = curve.getPointAt(length), hor = curve.isLinear() && Math.abs(curve.getTangentAt(.5, true).y) < tolerance, path = curve._path;
                                    if (path._parent instanceof CompoundPath) path = path._parent;
                                    windingSum += operation === "subtract" && _path2 && (path === _path1 && _path2._getWinding(pt, hor) || path === _path2 && !_path1._getWinding(pt, hor)) ? 0 : getWinding(pt, monoCurves, hor);
                                    break;
                                }
                                length -= curveLength;
                            }
                        }
                        var winding = Math.round(windingSum / 3);
                        for (var j = chain.length - 1; j >= 0; j--) chain[j].segment._winding = winding;
                    }
                    var result = new CompoundPath(Item.NO_INSERT);
                    result.insertAbove(path1);
                    result.addChildren(tracePaths(segments, operator), true);
                    result = result.reduce();
                    result.setStyle(path1._style);
                    return result;
                }
                function splitPath(intersections) {
                    var tMin = 1e-6, tMax = 1 - tMin, linearHandles;
                    function resetLinear() {
                        for (var i = 0, l = linearHandles.length; i < l; i++) linearHandles[i].set(0, 0);
                    }
                    for (var i = intersections.length - 1, curve, prev; i >= 0; i--) {
                        var loc = intersections[i], t = loc._parameter;
                        if (prev && prev._curve === loc._curve && prev._parameter > 0) {
                            t /= prev._parameter;
                        } else {
                            curve = loc._curve;
                            if (linearHandles) resetLinear();
                            linearHandles = curve.isLinear() ? [ curve._segment1._handleOut, curve._segment2._handleIn ] : null;
                        }
                        var newCurve, segment;
                        if (newCurve = curve.divide(t, true, true)) {
                            segment = newCurve._segment1;
                            curve = newCurve.getPrevious();
                            if (linearHandles) linearHandles.push(segment._handleOut, segment._handleIn);
                        } else {
                            segment = t < tMin ? curve._segment1 : t > tMax ? curve._segment2 : curve.getPartLength(0, t) < curve.getPartLength(t, 1) ? curve._segment1 : curve._segment2;
                        }
                        segment._intersection = loc.getIntersection();
                        loc._segment = segment;
                        prev = loc;
                    }
                    if (linearHandles) resetLinear();
                }
                function getWinding(point, curves, horizontal, testContains) {
                    var tolerance = 1e-6, tMin = tolerance, tMax = 1 - tMin, px = point.x, py = point.y, windLeft = 0, windRight = 0, roots = [], abs = Math.abs;
                    if (horizontal) {
                        var yTop = -Infinity, yBottom = Infinity, yBefore = py - tolerance, yAfter = py + tolerance;
                        for (var i = 0, l = curves.length; i < l; i++) {
                            var values = curves[i].values;
                            if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
                                for (var j = roots.length - 1; j >= 0; j--) {
                                    var y = Curve.evaluate(values, roots[j], 0).y;
                                    if (y < yBefore && y > yTop) {
                                        yTop = y;
                                    } else if (y > yAfter && y < yBottom) {
                                        yBottom = y;
                                    }
                                }
                            }
                        }
                        yTop = (yTop + py) / 2;
                        yBottom = (yBottom + py) / 2;
                        if (yTop > -Infinity) windLeft = getWinding(new Point(px, yTop), curves);
                        if (yBottom < Infinity) windRight = getWinding(new Point(px, yBottom), curves);
                    } else {
                        var xBefore = px - tolerance, xAfter = px + tolerance;
                        for (var i = 0, l = curves.length; i < l; i++) {
                            var curve = curves[i], values = curve.values, winding = curve.winding, prevT, prevX;
                            if (winding && (winding === 1 && py >= values[1] && py <= values[7] || py >= values[7] && py <= values[1]) && Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
                                var t = roots[0], x = Curve.evaluate(values, t, 0).x, slope = Curve.evaluate(values, t, 1).y;
                                if (!(t > tMax && (i === l - 1 || curve.next !== curves[i + 1]) && abs(Curve.evaluate(curve.next.values, 0, 0).x - x) < tolerance || i > 0 && curve.previous === curves[i - 1] && abs(prevX - x) < tolerance && prevT > tMax && t < tMin)) {
                                    if (Numerical.isZero(slope) && !Curve.isLinear(values) || t < tMin && slope * Curve.evaluate(curve.previous.values, 1, 1).y < 0 || t > tMax && slope * Curve.evaluate(curve.next.values, 0, 1).y < 0) {
                                        if (testContains && x >= xBefore && x <= xAfter) {
                                            ++windLeft;
                                            ++windRight;
                                        }
                                    } else if (x <= xBefore) {
                                        windLeft += winding;
                                    } else if (x >= xAfter) {
                                        windRight += winding;
                                    }
                                }
                                prevT = t;
                                prevX = x;
                            }
                        }
                    }
                    return Math.max(abs(windLeft), abs(windRight));
                }
                function tracePaths(segments, operator, selfOp) {
                    var paths = [], tMin = 1e-6, tMax = 1 - tMin;
                    for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
                        seg = startSeg = segments[i];
                        if (seg._visited || !operator(seg._winding)) continue;
                        var path = new Path(Item.NO_INSERT), inter = seg._intersection, startInterSeg = inter && inter._segment, added = false, dir = 1;
                        do {
                            var handleIn = dir > 0 ? seg._handleIn : seg._handleOut, handleOut = dir > 0 ? seg._handleOut : seg._handleIn, interSeg;
                            if (added && (!operator(seg._winding) || selfOp) && (inter = seg._intersection) && (interSeg = inter._segment) && interSeg !== startSeg) {
                                if (selfOp) {
                                    seg._visited = interSeg._visited;
                                    seg = interSeg;
                                    dir = 1;
                                } else {
                                    var c1 = seg.getCurve();
                                    if (dir > 0) c1 = c1.getPrevious();
                                    var t1 = c1.getTangentAt(dir < 1 ? tMin : tMax, true), c4 = interSeg.getCurve(), c3 = c4.getPrevious(), t3 = c3.getTangentAt(tMax, true), t4 = c4.getTangentAt(tMin, true), w3 = t1.cross(t3), w4 = t1.cross(t4);
                                    if (w3 * w4 !== 0) {
                                        var curve = w3 < w4 ? c3 : c4, nextCurve = operator(curve._segment1._winding) ? curve : w3 < w4 ? c4 : c3, nextSeg = nextCurve._segment1;
                                        dir = nextCurve === c3 ? -1 : 1;
                                        if (nextSeg._visited && seg._path !== nextSeg._path || !operator(nextSeg._winding)) {
                                            dir = 1;
                                        } else {
                                            seg._visited = interSeg._visited;
                                            seg = interSeg;
                                            if (nextSeg._visited) dir = 1;
                                        }
                                    } else {
                                        dir = 1;
                                    }
                                }
                                handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
                            }
                            path.add(new Segment(seg._point, added && handleIn, handleOut));
                            added = true;
                            seg._visited = true;
                            seg = dir > 0 ? seg.getNext() : seg.getPrevious();
                        } while (seg && !seg._visited && seg !== startSeg && seg !== startInterSeg && (seg._intersection || operator(seg._winding)));
                        if (seg && (seg === startSeg || seg === startInterSeg)) {
                            path.firstSegment.setHandleIn((seg === startInterSeg ? startInterSeg : seg)._handleIn);
                            path.setClosed(true);
                        } else {
                            path.lastSegment._handleOut.set(0, 0);
                        }
                        if (path._segments.length > (path._closed ? path.isPolygon() ? 2 : 0 : 1)) paths.push(path);
                    }
                    return paths;
                }
                return {
                    _getWinding: function(point, horizontal, testContains) {
                        return getWinding(point, this._getMonoCurves(), horizontal, testContains);
                    },
                    unite: function(path) {
                        return computeBoolean(this, path, "unite");
                    },
                    intersect: function(path) {
                        return computeBoolean(this, path, "intersect");
                    },
                    subtract: function(path) {
                        return computeBoolean(this, path, "subtract");
                    },
                    exclude: function(path) {
                        return computeBoolean(this, path, "exclude");
                    },
                    divide: function(path) {
                        return new Group([ this.subtract(path), this.intersect(path) ]);
                    }
                };
            }());
            Path.inject({
                _getMonoCurves: function() {
                    var monoCurves = this._monoCurves, prevCurve;
                    function insertCurve(v) {
                        var y0 = v[1], y1 = v[7], curve = {
                            values: v,
                            winding: y0 === y1 ? 0 : y0 > y1 ? -1 : 1,
                            previous: prevCurve,
                            next: null
                        };
                        if (prevCurve) prevCurve.next = curve;
                        monoCurves.push(curve);
                        prevCurve = curve;
                    }
                    function handleCurve(v) {
                        if (Curve.getLength(v) === 0) return;
                        var y0 = v[1], y1 = v[3], y2 = v[5], y3 = v[7];
                        if (Curve.isLinear(v)) {
                            insertCurve(v);
                        } else {
                            var a = 3 * (y1 - y2) - y0 + y3, b = 2 * (y0 + y2) - 4 * y1, c = y1 - y0, tolerance = 1e-6, roots = [];
                            var count = Numerical.solveQuadratic(a, b, c, roots, tolerance, 1 - tolerance);
                            if (count === 0) {
                                insertCurve(v);
                            } else {
                                roots.sort();
                                var t = roots[0], parts = Curve.subdivide(v, t);
                                insertCurve(parts[0]);
                                if (count > 1) {
                                    t = (roots[1] - t) / (1 - t);
                                    parts = Curve.subdivide(parts[1], t);
                                    insertCurve(parts[0]);
                                }
                                insertCurve(parts[1]);
                            }
                        }
                    }
                    if (!monoCurves) {
                        monoCurves = this._monoCurves = [];
                        var curves = this.getCurves(), segments = this._segments;
                        for (var i = 0, l = curves.length; i < l; i++) handleCurve(curves[i].getValues());
                        if (!this._closed && segments.length > 1) {
                            var p1 = segments[segments.length - 1]._point, p2 = segments[0]._point, p1x = p1._x, p1y = p1._y, p2x = p2._x, p2y = p2._y;
                            handleCurve([ p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y ]);
                        }
                        if (monoCurves.length > 0) {
                            var first = monoCurves[0], last = monoCurves[monoCurves.length - 1];
                            first.previous = last;
                            last.next = first;
                        }
                    }
                    return monoCurves;
                },
                getInteriorPoint: function() {
                    var bounds = this.getBounds(), point = bounds.getCenter(true);
                    if (!this.contains(point)) {
                        var curves = this._getMonoCurves(), roots = [], y = point.y, xIntercepts = [];
                        for (var i = 0, l = curves.length; i < l; i++) {
                            var values = curves[i].values;
                            if ((curves[i].winding === 1 && y >= values[1] && y <= values[7] || y >= values[7] && y <= values[1]) && Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
                                for (var j = roots.length - 1; j >= 0; j--) xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
                            }
                            if (xIntercepts.length > 1) break;
                        }
                        point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
                    }
                    return point;
                },
                reorient: function() {
                    this.setClockwise(true);
                    return this;
                }
            });
            CompoundPath.inject({
                _getMonoCurves: function() {
                    var children = this._children, monoCurves = [];
                    for (var i = 0, l = children.length; i < l; i++) monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
                    return monoCurves;
                },
                reorient: function() {
                    var children = this.removeChildren().sort(function(a, b) {
                        return b.getBounds().getArea() - a.getBounds().getArea();
                    });
                    if (children.length > 0) {
                        this.addChildren(children);
                        var clockwise = children[0].isClockwise();
                        for (var i = 1, l = children.length; i < l; i++) {
                            var point = children[i].getInteriorPoint(), counters = 0;
                            for (var j = i - 1; j >= 0; j--) {
                                if (children[j].contains(point)) counters++;
                            }
                            children[i].setClockwise(counters % 2 === 0 && clockwise);
                        }
                    }
                    return this;
                }
            });
            var PathIterator = Base.extend({
                _class: "PathIterator",
                initialize: function(path, maxRecursion, tolerance, matrix) {
                    var curves = [], parts = [], length = 0, minDifference = 1 / (maxRecursion || 32), segments = path._segments, segment1 = segments[0], segment2;
                    function addCurve(segment1, segment2) {
                        var curve = Curve.getValues(segment1, segment2, matrix);
                        curves.push(curve);
                        computeParts(curve, segment1._index, 0, 1);
                    }
                    function computeParts(curve, index, minT, maxT) {
                        if (maxT - minT > minDifference && !Curve.isFlatEnough(curve, tolerance || .25)) {
                            var split = Curve.subdivide(curve), halfT = (minT + maxT) / 2;
                            computeParts(split[0], index, minT, halfT);
                            computeParts(split[1], index, halfT, maxT);
                        } else {
                            var x = curve[6] - curve[0], y = curve[7] - curve[1], dist = Math.sqrt(x * x + y * y);
                            if (dist > 1e-6) {
                                length += dist;
                                parts.push({
                                    offset: length,
                                    value: maxT,
                                    index: index
                                });
                            }
                        }
                    }
                    for (var i = 1, l = segments.length; i < l; i++) {
                        segment2 = segments[i];
                        addCurve(segment1, segment2);
                        segment1 = segment2;
                    }
                    if (path._closed) addCurve(segment2, segments[0]);
                    this.curves = curves;
                    this.parts = parts;
                    this.length = length;
                    this.index = 0;
                },
                getParameterAt: function(offset) {
                    var i, j = this.index;
                    for (;;) {
                        i = j;
                        if (j == 0 || this.parts[--j].offset < offset) break;
                    }
                    for (var l = this.parts.length; i < l; i++) {
                        var part = this.parts[i];
                        if (part.offset >= offset) {
                            this.index = i;
                            var prev = this.parts[i - 1];
                            var prevVal = prev && prev.index == part.index ? prev.value : 0, prevLen = prev ? prev.offset : 0;
                            return {
                                value: prevVal + (part.value - prevVal) * (offset - prevLen) / (part.offset - prevLen),
                                index: part.index
                            };
                        }
                    }
                    var part = this.parts[this.parts.length - 1];
                    return {
                        value: 1,
                        index: part.index
                    };
                },
                evaluate: function(offset, type) {
                    var param = this.getParameterAt(offset);
                    return Curve.evaluate(this.curves[param.index], param.value, type);
                },
                drawPart: function(ctx, from, to) {
                    from = this.getParameterAt(from);
                    to = this.getParameterAt(to);
                    for (var i = from.index; i <= to.index; i++) {
                        var curve = Curve.getPart(this.curves[i], i == from.index ? from.value : 0, i == to.index ? to.value : 1);
                        if (i == from.index) ctx.moveTo(curve[0], curve[1]);
                        ctx.bezierCurveTo.apply(ctx, curve.slice(2));
                    }
                }
            }, Base.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(name, index) {
                this[name + "At"] = function(offset) {
                    return this.evaluate(offset, index);
                };
            }, {}));
            var PathFitter = Base.extend({
                initialize: function(path, error) {
                    var points = this.points = [], segments = path._segments, prev;
                    for (var i = 0, l = segments.length; i < l; i++) {
                        var point = segments[i].point.clone();
                        if (!prev || !prev.equals(point)) {
                            points.push(point);
                            prev = point;
                        }
                    }
                    if (path._closed) {
                        this.closed = true;
                        points.unshift(points[points.length - 1]);
                        points.push(points[1]);
                    }
                    this.error = error;
                },
                fit: function() {
                    var points = this.points, length = points.length, segments = this.segments = length > 0 ? [ new Segment(points[0]) ] : [];
                    if (length > 1) this.fitCubic(0, length - 1, points[1].subtract(points[0]).normalize(), points[length - 2].subtract(points[length - 1]).normalize());
                    if (this.closed) {
                        segments.shift();
                        segments.pop();
                    }
                    return segments;
                },
                fitCubic: function(first, last, tan1, tan2) {
                    if (last - first == 1) {
                        var pt1 = this.points[first], pt2 = this.points[last], dist = pt1.getDistance(pt2) / 3;
                        this.addCurve([ pt1, pt1.add(tan1.normalize(dist)), pt2.add(tan2.normalize(dist)), pt2 ]);
                        return;
                    }
                    var uPrime = this.chordLengthParameterize(first, last), maxError = Math.max(this.error, this.error * this.error), split, parametersInOrder = true;
                    for (var i = 0; i <= 4; i++) {
                        var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
                        var max = this.findMaxError(first, last, curve, uPrime);
                        if (max.error < this.error && parametersInOrder) {
                            this.addCurve(curve);
                            return;
                        }
                        split = max.index;
                        if (max.error >= maxError) break;
                        parametersInOrder = this.reparameterize(first, last, uPrime, curve);
                        maxError = max.error;
                    }
                    var V1 = this.points[split - 1].subtract(this.points[split]), V2 = this.points[split].subtract(this.points[split + 1]), tanCenter = V1.add(V2).divide(2).normalize();
                    this.fitCubic(first, split, tan1, tanCenter);
                    this.fitCubic(split, last, tanCenter.negate(), tan2);
                },
                addCurve: function(curve) {
                    var prev = this.segments[this.segments.length - 1];
                    prev.setHandleOut(curve[1].subtract(curve[0]));
                    this.segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
                },
                generateBezier: function(first, last, uPrime, tan1, tan2) {
                    var epsilon = 1e-12, pt1 = this.points[first], pt2 = this.points[last], C = [ [ 0, 0 ], [ 0, 0 ] ], X = [ 0, 0 ];
                    for (var i = 0, l = last - first + 1; i < l; i++) {
                        var u = uPrime[i], t = 1 - u, b = 3 * u * t, b0 = t * t * t, b1 = b * t, b2 = b * u, b3 = u * u * u, a1 = tan1.normalize(b1), a2 = tan2.normalize(b2), tmp = this.points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));
                        C[0][0] += a1.dot(a1);
                        C[0][1] += a1.dot(a2);
                        C[1][0] = C[0][1];
                        C[1][1] += a2.dot(a2);
                        X[0] += a1.dot(tmp);
                        X[1] += a2.dot(tmp);
                    }
                    var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1], alpha1, alpha2;
                    if (Math.abs(detC0C1) > epsilon) {
                        var detC0X = C[0][0] * X[1] - C[1][0] * X[0], detXC1 = X[0] * C[1][1] - X[1] * C[0][1];
                        alpha1 = detXC1 / detC0C1;
                        alpha2 = detC0X / detC0C1;
                    } else {
                        var c0 = C[0][0] + C[0][1], c1 = C[1][0] + C[1][1];
                        if (Math.abs(c0) > epsilon) {
                            alpha1 = alpha2 = X[0] / c0;
                        } else if (Math.abs(c1) > epsilon) {
                            alpha1 = alpha2 = X[1] / c1;
                        } else {
                            alpha1 = alpha2 = 0;
                        }
                    }
                    var segLength = pt2.getDistance(pt1), eps = epsilon * segLength, handle1, handle2;
                    if (alpha1 < eps || alpha2 < eps) {
                        alpha1 = alpha2 = segLength / 3;
                    } else {
                        var line = pt2.subtract(pt1);
                        handle1 = tan1.normalize(alpha1);
                        handle2 = tan2.normalize(alpha2);
                        if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
                            alpha1 = alpha2 = segLength / 3;
                            handle1 = handle2 = null;
                        }
                    }
                    return [ pt1, pt1.add(handle1 || tan1.normalize(alpha1)), pt2.add(handle2 || tan2.normalize(alpha2)), pt2 ];
                },
                reparameterize: function(first, last, u, curve) {
                    for (var i = first; i <= last; i++) {
                        u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
                    }
                    for (var i = 1, l = u.length; i < l; i++) {
                        if (u[i] <= u[i - 1]) return false;
                    }
                    return true;
                },
                findRoot: function(curve, point, u) {
                    var curve1 = [], curve2 = [];
                    for (var i = 0; i <= 2; i++) {
                        curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
                    }
                    for (var i = 0; i <= 1; i++) {
                        curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
                    }
                    var pt = this.evaluate(3, curve, u), pt1 = this.evaluate(2, curve1, u), pt2 = this.evaluate(1, curve2, u), diff = pt.subtract(point), df = pt1.dot(pt1) + diff.dot(pt2);
                    if (Math.abs(df) < 1e-6) return u;
                    return u - diff.dot(pt1) / df;
                },
                evaluate: function(degree, curve, t) {
                    var tmp = curve.slice();
                    for (var i = 1; i <= degree; i++) {
                        for (var j = 0; j <= degree - i; j++) {
                            tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
                        }
                    }
                    return tmp[0];
                },
                chordLengthParameterize: function(first, last) {
                    var u = [ 0 ];
                    for (var i = first + 1; i <= last; i++) {
                        u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);
                    }
                    for (var i = 1, m = last - first; i <= m; i++) {
                        u[i] /= u[m];
                    }
                    return u;
                },
                findMaxError: function(first, last, curve, u) {
                    var index = Math.floor((last - first + 1) / 2), maxDist = 0;
                    for (var i = first + 1; i < last; i++) {
                        var P = this.evaluate(3, curve, u[i - first]);
                        var v = P.subtract(this.points[i]);
                        var dist = v.x * v.x + v.y * v.y;
                        if (dist >= maxDist) {
                            maxDist = dist;
                            index = i;
                        }
                    }
                    return {
                        error: maxDist,
                        index: index
                    };
                }
            });
            var TextItem = Item.extend({
                _class: "TextItem",
                _boundsSelected: true,
                _applyMatrix: false,
                _canApplyMatrix: false,
                _serializeFields: {
                    content: null
                },
                _boundsGetter: "getBounds",
                initialize: function TextItem(arg) {
                    this._content = "";
                    this._lines = [];
                    var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;
                    this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
                },
                _equals: function(item) {
                    return this._content === item._content;
                },
                _clone: function _clone(copy, insert, includeMatrix) {
                    copy.setContent(this._content);
                    return _clone.base.call(this, copy, insert, includeMatrix);
                },
                getContent: function() {
                    return this._content;
                },
                setContent: function(content) {
                    this._content = "" + content;
                    this._lines = this._content.split(/\r\n|\n|\r/gm);
                    this._changed(265);
                },
                isEmpty: function() {
                    return !this._content;
                },
                getCharacterStyle: "#getStyle",
                setCharacterStyle: "#setStyle",
                getParagraphStyle: "#getStyle",
                setParagraphStyle: "#setStyle"
            });
            var PointText = TextItem.extend({
                _class: "PointText",
                initialize: function PointText() {
                    TextItem.apply(this, arguments);
                },
                clone: function(insert) {
                    return this._clone(new PointText(Item.NO_INSERT), insert);
                },
                getPoint: function() {
                    var point = this._matrix.getTranslation();
                    return new LinkedPoint(point.x, point.y, this, "setPoint");
                },
                setPoint: function() {
                    var point = Point.read(arguments);
                    this.translate(point.subtract(this._matrix.getTranslation()));
                },
                _draw: function(ctx) {
                    if (!this._content) return;
                    this._setStyles(ctx);
                    var style = this._style, lines = this._lines, leading = style.getLeading(), shadowColor = ctx.shadowColor;
                    ctx.font = style.getFontStyle();
                    ctx.textAlign = style.getJustification();
                    for (var i = 0, l = lines.length; i < l; i++) {
                        ctx.shadowColor = shadowColor;
                        var line = lines[i];
                        if (style.hasFill()) {
                            ctx.fillText(line, 0, 0);
                            ctx.shadowColor = "rgba(0,0,0,0)";
                        }
                        if (style.hasStroke()) ctx.strokeText(line, 0, 0);
                        ctx.translate(0, leading);
                    }
                },
                _getBounds: function(getter, matrix) {
                    var style = this._style, lines = this._lines, numLines = lines.length, justification = style.getJustification(), leading = style.getLeading(), width = this.getView().getTextWidth(style.getFontStyle(), lines), x = 0;
                    if (justification !== "left") x -= width / (justification === "center" ? 2 : 1);
                    var bounds = new Rectangle(x, numLines ? -.75 * leading : 0, width, numLines * leading);
                    return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
                }
            });
            var Color = Base.extend(new function() {
                var types = {
                    gray: [ "gray" ],
                    rgb: [ "red", "green", "blue" ],
                    hsb: [ "hue", "saturation", "brightness" ],
                    hsl: [ "hue", "saturation", "lightness" ],
                    gradient: [ "gradient", "origin", "destination", "highlight" ]
                };
                var componentParsers = {}, colorCache = {}, colorCtx;
                function fromCSS(string) {
                    var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/), components;
                    if (match) {
                        components = [ 0, 0, 0 ];
                        for (var i = 0; i < 3; i++) {
                            var value = match[i + 1];
                            components[i] = parseInt(value.length == 1 ? value + value : value, 16) / 255;
                        }
                    } else if (match = string.match(/^rgba?\((.*)\)$/)) {
                        components = match[1].split(",");
                        for (var i = 0, l = components.length; i < l; i++) {
                            var value = +components[i];
                            components[i] = i < 3 ? value / 255 : value;
                        }
                    } else {
                        var cached = colorCache[string];
                        if (!cached) {
                            if (!colorCtx) {
                                colorCtx = CanvasProvider.getContext(1, 1);
                                colorCtx.globalCompositeOperation = "copy";
                            }
                            colorCtx.fillStyle = "rgba(0,0,0,0)";
                            colorCtx.fillStyle = string;
                            colorCtx.fillRect(0, 0, 1, 1);
                            var data = colorCtx.getImageData(0, 0, 1, 1).data;
                            cached = colorCache[string] = [ data[0] / 255, data[1] / 255, data[2] / 255 ];
                        }
                        components = cached.slice();
                    }
                    return components;
                }
                var hsbIndices = [ [ 0, 3, 1 ], [ 2, 0, 1 ], [ 1, 0, 3 ], [ 1, 2, 0 ], [ 3, 1, 0 ], [ 0, 1, 2 ] ];
                var converters = {
                    "rgb-hsb": function(r, g, b) {
                        var max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, h = delta === 0 ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
                        return [ h, max === 0 ? 0 : delta / max, max ];
                    },
                    "hsb-rgb": function(h, s, b) {
                        h = (h / 60 % 6 + 6) % 6;
                        var i = Math.floor(h), f = h - i, i = hsbIndices[i], v = [ b, b * (1 - s), b * (1 - s * f), b * (1 - s * (1 - f)) ];
                        return [ v[i[0]], v[i[1]], v[i[2]] ];
                    },
                    "rgb-hsl": function(r, g, b) {
                        var max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, achromatic = delta === 0, h = achromatic ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60, l = (max + min) / 2, s = achromatic ? 0 : l < .5 ? delta / (max + min) : delta / (2 - max - min);
                        return [ h, s, l ];
                    },
                    "hsl-rgb": function(h, s, l) {
                        h = (h / 360 % 1 + 1) % 1;
                        if (s === 0) return [ l, l, l ];
                        var t3s = [ h + 1 / 3, h, h - 1 / 3 ], t2 = l < .5 ? l * (1 + s) : l + s - l * s, t1 = 2 * l - t2, c = [];
                        for (var i = 0; i < 3; i++) {
                            var t3 = t3s[i];
                            if (t3 < 0) t3 += 1;
                            if (t3 > 1) t3 -= 1;
                            c[i] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
                        }
                        return c;
                    },
                    "rgb-gray": function(r, g, b) {
                        return [ r * .2989 + g * .587 + b * .114 ];
                    },
                    "gray-rgb": function(g) {
                        return [ g, g, g ];
                    },
                    "gray-hsb": function(g) {
                        return [ 0, 0, g ];
                    },
                    "gray-hsl": function(g) {
                        return [ 0, 0, g ];
                    },
                    "gradient-rgb": function() {
                        return [];
                    },
                    "rgb-gradient": function() {
                        return [];
                    }
                };
                return Base.each(types, function(properties, type) {
                    componentParsers[type] = [];
                    Base.each(properties, function(name, index) {
                        var part = Base.capitalize(name), hasOverlap = /^(hue|saturation)$/.test(name), parser = componentParsers[type][index] = name === "gradient" ? function(value) {
                            var current = this._components[0];
                            value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {
                                readNull: true
                            });
                            if (current !== value) {
                                if (current) current._removeOwner(this);
                                if (value) value._addOwner(this);
                            }
                            return value;
                        } : type === "gradient" ? function() {
                            return Point.read(arguments, 0, {
                                readNull: name === "highlight",
                                clone: true
                            });
                        } : function(value) {
                            return value == null || isNaN(value) ? 0 : value;
                        };
                        this["get" + part] = function() {
                            return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];
                        };
                        this["set" + part] = function(value) {
                            if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
                                this._components = this._convert(type);
                                this._properties = types[type];
                                this._type = type;
                            }
                            this._components[index] = parser.call(this, value);
                            this._changed();
                        };
                    }, this);
                }, {
                    _class: "Color",
                    _readIndex: true,
                    initialize: function Color(arg) {
                        var slice = Array.prototype.slice, args = arguments, read = 0, type, components, alpha, values;
                        if (Array.isArray(arg)) {
                            args = arg;
                            arg = args[0];
                        }
                        var argType = arg != null && typeof arg;
                        if (argType === "string" && arg in types) {
                            type = arg;
                            arg = args[1];
                            if (Array.isArray(arg)) {
                                components = arg;
                                alpha = args[2];
                            } else {
                                if (this.__read) read = 1;
                                args = slice.call(args, 1);
                                argType = typeof arg;
                            }
                        }
                        if (!components) {
                            values = argType === "number" ? args : argType === "object" && arg.length != null ? arg : null;
                            if (values) {
                                if (!type) type = values.length >= 3 ? "rgb" : "gray";
                                var length = types[type].length;
                                alpha = values[length];
                                if (this.__read) read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;
                                if (values.length > length) values = slice.call(values, 0, length);
                            } else if (argType === "string") {
                                type = "rgb";
                                components = fromCSS(arg);
                                if (components.length === 4) {
                                    alpha = components[3];
                                    components.length--;
                                }
                            } else if (argType === "object") {
                                if (arg.constructor === Color) {
                                    type = arg._type;
                                    components = arg._components.slice();
                                    alpha = arg._alpha;
                                    if (type === "gradient") {
                                        for (var i = 1, l = components.length; i < l; i++) {
                                            var point = components[i];
                                            if (point) components[i] = point.clone();
                                        }
                                    }
                                } else if (arg.constructor === Gradient) {
                                    type = "gradient";
                                    values = args;
                                } else {
                                    type = "hue" in arg ? "lightness" in arg ? "hsl" : "hsb" : "gradient" in arg || "stops" in arg || "radial" in arg ? "gradient" : "gray" in arg ? "gray" : "rgb";
                                    var properties = types[type];
                                    parsers = componentParsers[type];
                                    this._components = components = [];
                                    for (var i = 0, l = properties.length; i < l; i++) {
                                        var value = arg[properties[i]];
                                        if (value == null && i === 0 && type === "gradient" && "stops" in arg) {
                                            value = {
                                                stops: arg.stops,
                                                radial: arg.radial
                                            };
                                        }
                                        value = parsers[i].call(this, value);
                                        if (value != null) components[i] = value;
                                    }
                                    alpha = arg.alpha;
                                }
                            }
                            if (this.__read && type) read = 1;
                        }
                        this._type = type || "rgb";
                        this._id = UID.get(Color);
                        if (!components) {
                            this._components = components = [];
                            var parsers = componentParsers[this._type];
                            for (var i = 0, l = parsers.length; i < l; i++) {
                                var value = parsers[i].call(this, values && values[i]);
                                if (value != null) components[i] = value;
                            }
                        }
                        this._components = components;
                        this._properties = types[this._type];
                        this._alpha = alpha;
                        if (this.__read) this.__read = read;
                    },
                    _serialize: function(options, dictionary) {
                        var components = this.getComponents();
                        return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [ this._type ].concat(components), options, true, dictionary);
                    },
                    _changed: function() {
                        this._canvasStyle = null;
                        if (this._owner) this._owner._changed(65);
                    },
                    _convert: function(type) {
                        var converter;
                        return this._type === type ? this._components.slice() : (converter = converters[this._type + "-" + type]) ? converter.apply(this, this._components) : converters["rgb-" + type].apply(this, converters[this._type + "-rgb"].apply(this, this._components));
                    },
                    convert: function(type) {
                        return new Color(type, this._convert(type), this._alpha);
                    },
                    getType: function() {
                        return this._type;
                    },
                    setType: function(type) {
                        this._components = this._convert(type);
                        this._properties = types[type];
                        this._type = type;
                    },
                    getComponents: function() {
                        var components = this._components.slice();
                        if (this._alpha != null) components.push(this._alpha);
                        return components;
                    },
                    getAlpha: function() {
                        return this._alpha != null ? this._alpha : 1;
                    },
                    setAlpha: function(alpha) {
                        this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
                        this._changed();
                    },
                    hasAlpha: function() {
                        return this._alpha != null;
                    },
                    equals: function(color) {
                        var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;
                        return col === this || col && this._class === col._class && this._type === col._type && this._alpha === col._alpha && Base.equals(this._components, col._components) || false;
                    },
                    toString: function() {
                        var properties = this._properties, parts = [], isGradient = this._type === "gradient", f = Formatter.instance;
                        for (var i = 0, l = properties.length; i < l; i++) {
                            var value = this._components[i];
                            if (value != null) parts.push(properties[i] + ": " + (isGradient ? value : f.number(value)));
                        }
                        if (this._alpha != null) parts.push("alpha: " + f.number(this._alpha));
                        return "{ " + parts.join(", ") + " }";
                    },
                    toCSS: function(hex) {
                        var components = this._convert("rgb"), alpha = hex || this._alpha == null ? 1 : this._alpha;
                        function convert(val) {
                            return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
                        }
                        components = [ convert(components[0]), convert(components[1]), convert(components[2]) ];
                        if (alpha < 1) components.push(alpha < 0 ? 0 : alpha);
                        return hex ? "#" + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? "rgba(" : "rgb(") + components.join(",") + ")";
                    },
                    toCanvasStyle: function(ctx) {
                        if (this._canvasStyle) return this._canvasStyle;
                        if (this._type !== "gradient") return this._canvasStyle = this.toCSS();
                        var components = this._components, gradient = components[0], stops = gradient._stops, origin = components[1], destination = components[2], canvasGradient;
                        if (gradient._radial) {
                            var radius = destination.getDistance(origin), highlight = components[3];
                            if (highlight) {
                                var vector = highlight.subtract(origin);
                                if (vector.getLength() > radius) highlight = origin.add(vector.normalize(radius - .1));
                            }
                            var start = highlight || origin;
                            canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
                        } else {
                            canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
                        }
                        for (var i = 0, l = stops.length; i < l; i++) {
                            var stop = stops[i];
                            canvasGradient.addColorStop(stop._rampPoint, stop._color.toCanvasStyle());
                        }
                        return this._canvasStyle = canvasGradient;
                    },
                    transform: function(matrix) {
                        if (this._type === "gradient") {
                            var components = this._components;
                            for (var i = 1, l = components.length; i < l; i++) {
                                var point = components[i];
                                matrix._transformPoint(point, point, true);
                            }
                            this._changed();
                        }
                    },
                    statics: {
                        _types: types,
                        random: function() {
                            var random = Math.random;
                            return new Color(random(), random(), random());
                        }
                    }
                });
            }(), new function() {
                var operators = {
                    add: function(a, b) {
                        return a + b;
                    },
                    subtract: function(a, b) {
                        return a - b;
                    },
                    multiply: function(a, b) {
                        return a * b;
                    },
                    divide: function(a, b) {
                        return a / b;
                    }
                };
                return Base.each(operators, function(operator, name) {
                    this[name] = function(color) {
                        color = Color.read(arguments);
                        var type = this._type, components1 = this._components, components2 = color._convert(type);
                        for (var i = 0, l = components1.length; i < l; i++) components2[i] = operator(components1[i], components2[i]);
                        return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);
                    };
                }, {});
            }());
            Base.each(Color._types, function(properties, type) {
                var ctor = this[Base.capitalize(type) + "Color"] = function(arg) {
                    var argType = arg != null && typeof arg, components = argType === "object" && arg.length != null ? arg : argType === "string" ? null : arguments;
                    return components ? new Color(type, components) : new Color(arg);
                };
                if (type.length == 3) {
                    var acronym = type.toUpperCase();
                    Color[acronym] = this[acronym + "Color"] = ctor;
                }
            }, Base.exports);
            var Gradient = Base.extend({
                _class: "Gradient",
                initialize: function Gradient(stops, radial) {
                    this._id = UID.get();
                    if (stops && this._set(stops)) stops = radial = null;
                    if (!this._stops) this.setStops(stops || [ "white", "black" ]);
                    if (this._radial == null) this.setRadial(typeof radial === "string" && radial === "radial" || radial || false);
                },
                _serialize: function(options, dictionary) {
                    return dictionary.add(this, function() {
                        return Base.serialize([ this._stops, this._radial ], options, true, dictionary);
                    });
                },
                _changed: function() {
                    for (var i = 0, l = this._owners && this._owners.length; i < l; i++) this._owners[i]._changed();
                },
                _addOwner: function(color) {
                    if (!this._owners) this._owners = [];
                    this._owners.push(color);
                },
                _removeOwner: function(color) {
                    var index = this._owners ? this._owners.indexOf(color) : -1;
                    if (index != -1) {
                        this._owners.splice(index, 1);
                        if (this._owners.length === 0) this._owners = undefined;
                    }
                },
                clone: function() {
                    var stops = [];
                    for (var i = 0, l = this._stops.length; i < l; i++) stops[i] = this._stops[i].clone();
                    return new Gradient(stops, this._radial);
                },
                getStops: function() {
                    return this._stops;
                },
                setStops: function(stops) {
                    if (this.stops) {
                        for (var i = 0, l = this._stops.length; i < l; i++) this._stops[i]._owner = undefined;
                    }
                    if (stops.length < 2) throw new Error("Gradient stop list needs to contain at least two stops.");
                    this._stops = GradientStop.readAll(stops, 0, {
                        clone: true
                    });
                    for (var i = 0, l = this._stops.length; i < l; i++) {
                        var stop = this._stops[i];
                        stop._owner = this;
                        if (stop._defaultRamp) stop.setRampPoint(i / (l - 1));
                    }
                    this._changed();
                },
                getRadial: function() {
                    return this._radial;
                },
                setRadial: function(radial) {
                    this._radial = radial;
                    this._changed();
                },
                equals: function(gradient) {
                    if (gradient === this) return true;
                    if (gradient && this._class === gradient._class && this._stops.length === gradient._stops.length) {
                        for (var i = 0, l = this._stops.length; i < l; i++) {
                            if (!this._stops[i].equals(gradient._stops[i])) return false;
                        }
                        return true;
                    }
                    return false;
                }
            });
            var GradientStop = Base.extend({
                _class: "GradientStop",
                initialize: function GradientStop(arg0, arg1) {
                    if (arg0) {
                        var color, rampPoint;
                        if (arg1 === undefined && Array.isArray(arg0)) {
                            color = arg0[0];
                            rampPoint = arg0[1];
                        } else if (arg0.color) {
                            color = arg0.color;
                            rampPoint = arg0.rampPoint;
                        } else {
                            color = arg0;
                            rampPoint = arg1;
                        }
                        this.setColor(color);
                        this.setRampPoint(rampPoint);
                    }
                },
                clone: function() {
                    return new GradientStop(this._color.clone(), this._rampPoint);
                },
                _serialize: function(options, dictionary) {
                    return Base.serialize([ this._color, this._rampPoint ], options, true, dictionary);
                },
                _changed: function() {
                    if (this._owner) this._owner._changed(65);
                },
                getRampPoint: function() {
                    return this._rampPoint;
                },
                setRampPoint: function(rampPoint) {
                    this._defaultRamp = rampPoint == null;
                    this._rampPoint = rampPoint || 0;
                    this._changed();
                },
                getColor: function() {
                    return this._color;
                },
                setColor: function(color) {
                    this._color = Color.read(arguments);
                    if (this._color === color) this._color = color.clone();
                    this._color._owner = this;
                    this._changed();
                },
                equals: function(stop) {
                    return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._rampPoint == stop._rampPoint || false;
                }
            });
            var Style = Base.extend(new function() {
                var defaults = {
                    fillColor: undefined,
                    strokeColor: undefined,
                    strokeWidth: 1,
                    strokeCap: "butt",
                    strokeJoin: "miter",
                    strokeScaling: true,
                    miterLimit: 10,
                    dashOffset: 0,
                    dashArray: [],
                    windingRule: "nonzero",
                    shadowColor: undefined,
                    shadowBlur: 0,
                    shadowOffset: new Point(),
                    selectedColor: undefined,
                    fontFamily: "sans-serif",
                    fontWeight: "normal",
                    fontSize: 12,
                    font: "sans-serif",
                    leading: null,
                    justification: "left"
                };
                var flags = {
                    strokeWidth: 97,
                    strokeCap: 97,
                    strokeJoin: 97,
                    strokeScaling: 105,
                    miterLimit: 97,
                    fontFamily: 9,
                    fontWeight: 9,
                    fontSize: 9,
                    font: 9,
                    leading: 9,
                    justification: 9
                };
                var item = {
                    beans: true
                }, fields = {
                    _defaults: defaults,
                    _textDefaults: new Base(defaults, {
                        fillColor: new Color()
                    }),
                    beans: true
                };
                Base.each(defaults, function(value, key) {
                    var isColor = /Color$/.test(key), isPoint = key === "shadowOffset", part = Base.capitalize(key), flag = flags[key], set = "set" + part, get = "get" + part;
                    fields[set] = function(value) {
                        var owner = this._owner, children = owner && owner._children;
                        if (children && children.length > 0 && !(owner instanceof CompoundPath)) {
                            for (var i = 0, l = children.length; i < l; i++) children[i]._style[set](value);
                        } else {
                            var old = this._values[key];
                            if (old !== value) {
                                if (isColor) {
                                    if (old) old._owner = undefined;
                                    if (value && value.constructor === Color) {
                                        if (value._owner) value = value.clone();
                                        value._owner = owner;
                                    }
                                }
                                this._values[key] = value;
                                if (owner) owner._changed(flag || 65);
                            }
                        }
                    };
                    fields[get] = function(_dontMerge) {
                        var owner = this._owner, children = owner && owner._children, value;
                        if (!children || children.length === 0 || _dontMerge || owner instanceof CompoundPath) {
                            var value = this._values[key];
                            if (value === undefined) {
                                value = this._defaults[key];
                                if (value && value.clone) value = value.clone();
                            } else {
                                var ctor = isColor ? Color : isPoint ? Point : null;
                                if (ctor && !(value && value.constructor === ctor)) {
                                    this._values[key] = value = ctor.read([ value ], 0, {
                                        readNull: true,
                                        clone: true
                                    });
                                    if (value && isColor) value._owner = owner;
                                }
                            }
                            return value;
                        }
                        for (var i = 0, l = children.length; i < l; i++) {
                            var childValue = children[i]._style[get]();
                            if (i === 0) {
                                value = childValue;
                            } else if (!Base.equals(value, childValue)) {
                                return undefined;
                            }
                        }
                        return value;
                    };
                    item[get] = function(_dontMerge) {
                        return this._style[get](_dontMerge);
                    };
                    item[set] = function(value) {
                        this._style[set](value);
                    };
                });
                Item.inject(item);
                return fields;
            }(), {
                _class: "Style",
                initialize: function Style(style, _owner, _project) {
                    this._values = {};
                    this._owner = _owner;
                    this._project = _owner && _owner._project || _project || paper.project;
                    if (_owner instanceof TextItem) this._defaults = this._textDefaults;
                    if (style) this.set(style);
                },
                set: function(style) {
                    var isStyle = style instanceof Style, values = isStyle ? style._values : style;
                    if (values) {
                        for (var key in values) {
                            if (key in this._defaults) {
                                var value = values[key];
                                this[key] = value && isStyle && value.clone ? value.clone() : value;
                            }
                        }
                    }
                },
                equals: function(style) {
                    return style === this || style && this._class === style._class && Base.equals(this._values, style._values) || false;
                },
                hasFill: function() {
                    return !!this.getFillColor();
                },
                hasStroke: function() {
                    return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
                },
                hasShadow: function() {
                    return !!this.getShadowColor() && this.getShadowBlur() > 0;
                },
                getView: function() {
                    return this._project.getView();
                },
                getFontStyle: function() {
                    var fontSize = this.getFontSize();
                    return this.getFontWeight() + " " + fontSize + (/[a-z]/i.test(fontSize + "") ? " " : "px ") + this.getFontFamily();
                },
                getFont: "#getFontFamily",
                setFont: "#setFontFamily",
                getLeading: function getLeading() {
                    var leading = getLeading.base.call(this), fontSize = this.getFontSize();
                    if (/pt|em|%|px/.test(fontSize)) fontSize = this.getView().getPixelSize(fontSize);
                    return leading != null ? leading : fontSize * 1.2;
                }
            });
            var DomElement = new function() {
                function handlePrefix(el, name, set, value) {
                    var prefixes = [ "", "webkit", "moz", "Moz", "ms", "o" ], suffix = name[0].toUpperCase() + name.substring(1);
                    for (var i = 0; i < 6; i++) {
                        var prefix = prefixes[i], key = prefix ? prefix + suffix : name;
                        if (key in el) {
                            if (set) {
                                el[key] = value;
                            } else {
                                return el[key];
                            }
                            break;
                        }
                    }
                }
                return {
                    getStyles: function(el) {
                        var doc = el && el.nodeType !== 9 ? el.ownerDocument : el, view = doc && doc.defaultView;
                        return view && view.getComputedStyle(el, "");
                    },
                    getBounds: function(el, viewport) {
                        var doc = el.ownerDocument, body = doc.body, html = doc.documentElement, rect;
                        try {
                            rect = el.getBoundingClientRect();
                        } catch (e) {
                            rect = {
                                left: 0,
                                top: 0,
                                width: 0,
                                height: 0
                            };
                        }
                        var x = rect.left - (html.clientLeft || body.clientLeft || 0), y = rect.top - (html.clientTop || body.clientTop || 0);
                        if (!viewport) {
                            var view = doc.defaultView;
                            x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
                            y += view.pageYOffset || html.scrollTop || body.scrollTop;
                        }
                        return new Rectangle(x, y, rect.width, rect.height);
                    },
                    getViewportBounds: function(el) {
                        var doc = el.ownerDocument, view = doc.defaultView, html = doc.documentElement;
                        return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);
                    },
                    getOffset: function(el, viewport) {
                        return DomElement.getBounds(el, viewport).getPoint();
                    },
                    getSize: function(el) {
                        return DomElement.getBounds(el, true).getSize();
                    },
                    isInvisible: function(el) {
                        return DomElement.getSize(el).equals(new Size(0, 0));
                    },
                    isInView: function(el) {
                        return !DomElement.isInvisible(el) && DomElement.getViewportBounds(el).intersects(DomElement.getBounds(el, true));
                    },
                    getPrefixed: function(el, name) {
                        return handlePrefix(el, name);
                    },
                    setPrefixed: function(el, name, value) {
                        if (typeof name === "object") {
                            for (var key in name) handlePrefix(el, key, true, name[key]);
                        } else {
                            handlePrefix(el, name, true, value);
                        }
                    }
                };
            }();
            var DomEvent = {
                add: function(el, events) {
                    for (var type in events) {
                        var func = events[type], parts = type.split(/[\s,]+/g);
                        for (var i = 0, l = parts.length; i < l; i++) el.addEventListener(parts[i], func, false);
                    }
                },
                remove: function(el, events) {
                    for (var type in events) {
                        var func = events[type], parts = type.split(/[\s,]+/g);
                        for (var i = 0, l = parts.length; i < l; i++) el.removeEventListener(parts[i], func, false);
                    }
                },
                getPoint: function(event) {
                    var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
                    return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop);
                },
                getTarget: function(event) {
                    return event.target || event.srcElement;
                },
                getRelatedTarget: function(event) {
                    return event.relatedTarget || event.toElement;
                },
                getOffset: function(event, target) {
                    return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));
                },
                stop: function(event) {
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
            DomEvent.requestAnimationFrame = new function() {
                var nativeRequest = DomElement.getPrefixed(window, "requestAnimationFrame"), requested = false, callbacks = [], focused = true, timer;
                DomEvent.add(window, {
                    focus: function() {
                        focused = true;
                    },
                    blur: function() {
                        focused = false;
                    }
                });
                function handleCallbacks() {
                    for (var i = callbacks.length - 1; i >= 0; i--) {
                        var entry = callbacks[i], func = entry[0], el = entry[1];
                        if (!el || (PaperScope.getAttribute(el, "keepalive") == "true" || focused) && DomElement.isInView(el)) {
                            callbacks.splice(i, 1);
                            func();
                        }
                    }
                    if (nativeRequest) {
                        if (callbacks.length) {
                            nativeRequest(handleCallbacks);
                        } else {
                            requested = false;
                        }
                    }
                }
                return function(callback, element) {
                    callbacks.push([ callback, element ]);
                    if (nativeRequest) {
                        if (!requested) {
                            nativeRequest(handleCallbacks);
                            requested = true;
                        }
                    } else if (!timer) {
                        timer = setInterval(handleCallbacks, 1e3 / 60);
                    }
                };
            }();
            var View = Base.extend(Emitter, {
                _class: "View",
                initialize: function View(project, element) {
                    this._project = project;
                    this._scope = project._scope;
                    this._element = element;
                    var size;
                    if (!this._pixelRatio) this._pixelRatio = window.devicePixelRatio || 1;
                    this._id = element.getAttribute("id");
                    if (this._id == null) element.setAttribute("id", this._id = "view-" + View._id++);
                    DomEvent.add(element, this._viewEvents);
                    var none = "none";
                    DomElement.setPrefixed(element.style, {
                        userSelect: none,
                        touchAction: none,
                        touchCallout: none,
                        contentZooming: none,
                        userDrag: none,
                        tapHighlightColor: "rgba(0,0,0,0)"
                    });
                    function getSize(name) {
                        return element[name] || parseInt(element.getAttribute(name), 10);
                    }
                    function getCanvasSize() {
                        var size = DomElement.getSize(element);
                        return size.isNaN() || size.isZero() ? new Size(getSize("width"), getSize("height")) : size;
                    }
                    if (PaperScope.hasAttribute(element, "resize")) {
                        var that = this;
                        DomEvent.add(window, this._windowEvents = {
                            resize: function() {
                                that.setViewSize(getCanvasSize());
                            }
                        });
                    }
                    this._setViewSize(size = getCanvasSize());
                    if (PaperScope.hasAttribute(element, "stats") && typeof Stats !== "undefined") {
                        this._stats = new Stats();
                        var stats = this._stats.domElement, style = stats.style, offset = DomElement.getOffset(element);
                        style.position = "absolute";
                        style.left = offset.x + "px";
                        style.top = offset.y + "px";
                        document.body.appendChild(stats);
                    }
                    View._views.push(this);
                    View._viewsById[this._id] = this;
                    this._viewSize = size;
                    (this._matrix = new Matrix())._owner = this;
                    this._zoom = 1;
                    if (!View._focused) View._focused = this;
                    this._frameItems = {};
                    this._frameItemCount = 0;
                },
                remove: function() {
                    if (!this._project) return false;
                    if (View._focused === this) View._focused = null;
                    View._views.splice(View._views.indexOf(this), 1);
                    delete View._viewsById[this._id];
                    if (this._project._view === this) this._project._view = null;
                    DomEvent.remove(this._element, this._viewEvents);
                    DomEvent.remove(window, this._windowEvents);
                    this._element = this._project = null;
                    this.off("frame");
                    this._animate = false;
                    this._frameItems = {};
                    return true;
                },
                _events: {
                    onFrame: {
                        install: function() {
                            this.play();
                        },
                        uninstall: function() {
                            this.pause();
                        }
                    },
                    onResize: {}
                },
                _animate: false,
                _time: 0,
                _count: 0,
                _requestFrame: function() {
                    var that = this;
                    DomEvent.requestAnimationFrame(function() {
                        that._requested = false;
                        if (!that._animate) return;
                        that._requestFrame();
                        that._handleFrame();
                    }, this._element);
                    this._requested = true;
                },
                _handleFrame: function() {
                    paper = this._scope;
                    var now = Date.now() / 1e3, delta = this._before ? now - this._before : 0;
                    this._before = now;
                    this._handlingFrame = true;
                    this.emit("frame", new Base({
                        delta: delta,
                        time: this._time += delta,
                        count: this._count++
                    }));
                    if (this._stats) this._stats.update();
                    this._handlingFrame = false;
                    this.update();
                },
                _animateItem: function(item, animate) {
                    var items = this._frameItems;
                    if (animate) {
                        items[item._id] = {
                            item: item,
                            time: 0,
                            count: 0
                        };
                        if (++this._frameItemCount === 1) this.on("frame", this._handleFrameItems);
                    } else {
                        delete items[item._id];
                        if (--this._frameItemCount === 0) {
                            this.off("frame", this._handleFrameItems);
                        }
                    }
                },
                _handleFrameItems: function(event) {
                    for (var i in this._frameItems) {
                        var entry = this._frameItems[i];
                        entry.item.emit("frame", new Base(event, {
                            time: entry.time += event.delta,
                            count: entry.count++
                        }));
                    }
                },
                _update: function() {
                    this._project._needsUpdate = true;
                    if (this._handlingFrame) return;
                    if (this._animate) {
                        this._handleFrame();
                    } else {
                        this.update();
                    }
                },
                _changed: function(flags) {
                    if (flags & 1) this._project._needsUpdate = true;
                },
                _transform: function(matrix) {
                    this._matrix.concatenate(matrix);
                    this._bounds = null;
                    this._update();
                },
                getElement: function() {
                    return this._element;
                },
                getPixelRatio: function() {
                    return this._pixelRatio;
                },
                getResolution: function() {
                    return this._pixelRatio * 72;
                },
                getViewSize: function() {
                    var size = this._viewSize;
                    return new LinkedSize(size.width, size.height, this, "setViewSize");
                },
                setViewSize: function() {
                    var size = Size.read(arguments), delta = size.subtract(this._viewSize);
                    if (delta.isZero()) return;
                    this._viewSize.set(size.width, size.height);
                    this._setViewSize(size);
                    this._bounds = null;
                    this.emit("resize", {
                        size: size,
                        delta: delta
                    });
                    this._update();
                },
                _setViewSize: function(size) {
                    var element = this._element;
                    element.width = size.width;
                    element.height = size.height;
                },
                getBounds: function() {
                    if (!this._bounds) this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point(), this._viewSize));
                    return this._bounds;
                },
                getSize: function() {
                    return this.getBounds().getSize();
                },
                getCenter: function() {
                    return this.getBounds().getCenter();
                },
                setCenter: function() {
                    var center = Point.read(arguments);
                    this.scrollBy(center.subtract(this.getCenter()));
                },
                getZoom: function() {
                    return this._zoom;
                },
                setZoom: function(zoom) {
                    this._transform(new Matrix().scale(zoom / this._zoom, this.getCenter()));
                    this._zoom = zoom;
                },
                isVisible: function() {
                    return DomElement.isInView(this._element);
                },
                scrollBy: function() {
                    this._transform(new Matrix().translate(Point.read(arguments).negate()));
                },
                play: function() {
                    this._animate = true;
                    if (!this._requested) this._requestFrame();
                },
                pause: function() {
                    this._animate = false;
                },
                draw: function() {
                    this.update();
                },
                projectToView: function() {
                    return this._matrix._transformPoint(Point.read(arguments));
                },
                viewToProject: function() {
                    return this._matrix._inverseTransform(Point.read(arguments));
                }
            }, {
                statics: {
                    _views: [],
                    _viewsById: {},
                    _id: 0,
                    create: function(project, element) {
                        if (typeof element === "string") element = document.getElementById(element);
                        return new CanvasView(project, element);
                    }
                }
            }, new function() {
                var tool, prevFocus, tempFocus, dragging = false;
                function getView(event) {
                    var target = DomEvent.getTarget(event);
                    return target.getAttribute && View._viewsById[target.getAttribute("id")];
                }
                function viewToProject(view, event) {
                    return view.viewToProject(DomEvent.getOffset(event, view._element));
                }
                function updateFocus() {
                    if (!View._focused || !View._focused.isVisible()) {
                        for (var i = 0, l = View._views.length; i < l; i++) {
                            var view = View._views[i];
                            if (view && view.isVisible()) {
                                View._focused = tempFocus = view;
                                break;
                            }
                        }
                    }
                }
                function handleMouseMove(view, point, event) {
                    view._handleEvent("mousemove", point, event);
                    var tool = view._scope.tool;
                    if (tool) {
                        tool._handleEvent(dragging && tool.responds("mousedrag") ? "mousedrag" : "mousemove", point, event);
                    }
                    view.update();
                    return tool;
                }
                var navigator = window.navigator, mousedown, mousemove, mouseup;
                if (navigator.pointerEnabled || navigator.msPointerEnabled) {
                    mousedown = "pointerdown MSPointerDown";
                    mousemove = "pointermove MSPointerMove";
                    mouseup = "pointerup pointercancel MSPointerUp MSPointerCancel";
                } else {
                    mousedown = "touchstart";
                    mousemove = "touchmove";
                    mouseup = "touchend touchcancel";
                    if (!("ontouchstart" in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
                        mousedown += " mousedown";
                        mousemove += " mousemove";
                        mouseup += " mouseup";
                    }
                }
                var viewEvents = {
                    "selectstart dragstart": function(event) {
                        if (dragging) event.preventDefault();
                    }
                };
                var docEvents = {
                    mouseout: function(event) {
                        var view = View._focused, target = DomEvent.getRelatedTarget(event);
                        if (view && (!target || target.nodeName === "HTML")) handleMouseMove(view, viewToProject(view, event), event);
                    },
                    scroll: updateFocus
                };
                viewEvents[mousedown] = function(event) {
                    var view = View._focused = getView(event), point = viewToProject(view, event);
                    dragging = true;
                    view._handleEvent("mousedown", point, event);
                    if (tool = view._scope.tool) tool._handleEvent("mousedown", point, event);
                    view.update();
                };
                docEvents[mousemove] = function(event) {
                    var view = View._focused;
                    if (!dragging) {
                        var target = getView(event);
                        if (target) {
                            if (view !== target) handleMouseMove(view, viewToProject(view, event), event);
                            prevFocus = view;
                            view = View._focused = tempFocus = target;
                        } else if (tempFocus && tempFocus === view) {
                            view = View._focused = prevFocus;
                            updateFocus();
                        }
                    }
                    if (view) {
                        var point = viewToProject(view, event);
                        if (dragging || view.getBounds().contains(point)) tool = handleMouseMove(view, point, event);
                    }
                };
                docEvents[mouseup] = function(event) {
                    var view = View._focused;
                    if (!view || !dragging) return;
                    var point = viewToProject(view, event);
                    dragging = false;
                    view._handleEvent("mouseup", point, event);
                    if (tool) tool._handleEvent("mouseup", point, event);
                    view.update();
                };
                DomEvent.add(document, docEvents);
                DomEvent.add(window, {
                    load: updateFocus
                });
                return {
                    _viewEvents: viewEvents,
                    _handleEvent: function() {},
                    statics: {
                        updateFocus: updateFocus
                    }
                };
            }());
            var CanvasView = View.extend({
                _class: "CanvasView",
                initialize: function CanvasView(project, canvas) {
                    if (!(canvas instanceof HTMLCanvasElement)) {
                        var size = Size.read(arguments, 1);
                        if (size.isZero()) throw new Error("Cannot create CanvasView with the provided argument: " + [].slice.call(arguments, 1));
                        canvas = CanvasProvider.getCanvas(size);
                    }
                    this._context = canvas.getContext("2d");
                    this._eventCounters = {};
                    this._pixelRatio = 1;
                    if (!/^off|false$/.test(PaperScope.getAttribute(canvas, "hidpi"))) {
                        var deviceRatio = window.devicePixelRatio || 1, backingStoreRatio = DomElement.getPrefixed(this._context, "backingStorePixelRatio") || 1;
                        this._pixelRatio = deviceRatio / backingStoreRatio;
                    }
                    View.call(this, project, canvas);
                },
                _setViewSize: function(size) {
                    var element = this._element, pixelRatio = this._pixelRatio, width = size.width, height = size.height;
                    element.width = width * pixelRatio;
                    element.height = height * pixelRatio;
                    if (pixelRatio !== 1) {
                        if (!PaperScope.hasAttribute(element, "resize")) {
                            var style = element.style;
                            style.width = width + "px";
                            style.height = height + "px";
                        }
                        this._context.scale(pixelRatio, pixelRatio);
                    }
                },
                getPixelSize: function(size) {
                    var ctx = this._context, prevFont = ctx.font;
                    ctx.font = size + " serif";
                    size = parseFloat(ctx.font);
                    ctx.font = prevFont;
                    return size;
                },
                getTextWidth: function(font, lines) {
                    var ctx = this._context, prevFont = ctx.font, width = 0;
                    ctx.font = font;
                    for (var i = 0, l = lines.length; i < l; i++) width = Math.max(width, ctx.measureText(lines[i]).width);
                    ctx.font = prevFont;
                    return width;
                },
                update: function(force) {
                    var project = this._project;
                    if (!project || !force && !project._needsUpdate) return false;
                    var ctx = this._context, size = this._viewSize;
                    ctx.clearRect(0, 0, size.width + 1, size.height + 1);
                    project.draw(ctx, this._matrix, this._pixelRatio);
                    project._needsUpdate = false;
                    return true;
                }
            }, new function() {
                var downPoint, lastPoint, overPoint, downItem, lastItem, overItem, dragItem, dblClick, clickTime;
                function callEvent(view, type, event, point, target, lastPoint) {
                    var item = target, mouseEvent;
                    function call(obj) {
                        if (obj.responds(type)) {
                            if (!mouseEvent) {
                                mouseEvent = new MouseEvent(type, event, point, target, lastPoint ? point.subtract(lastPoint) : null);
                            }
                            if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
                                event.preventDefault();
                                return true;
                            }
                        }
                    }
                    while (item) {
                        if (call(item)) return true;
                        item = item.getParent();
                    }
                    if (call(view)) return true;
                    return false;
                }
                return {
                    _handleEvent: function(type, point, event) {
                        if (!this._eventCounters[type]) return;
                        var project = this._project, hit = project.hitTest(point, {
                            tolerance: 0,
                            fill: true,
                            stroke: true
                        }), item = hit && hit.item, stopped = false;
                        switch (type) {
                          case "mousedown":
                            stopped = callEvent(this, type, event, point, item);
                            dblClick = lastItem == item && Date.now() - clickTime < 300;
                            downItem = lastItem = item;
                            downPoint = lastPoint = overPoint = point;
                            dragItem = !stopped && item;
                            while (dragItem && !dragItem.responds("mousedrag")) dragItem = dragItem._parent;
                            break;

                          case "mouseup":
                            stopped = callEvent(this, type, event, point, item, downPoint);
                            if (dragItem) {
                                if (lastPoint && !lastPoint.equals(point)) callEvent(this, "mousedrag", event, point, dragItem, lastPoint);
                                if (item !== dragItem) {
                                    overPoint = point;
                                    callEvent(this, "mousemove", event, point, item, overPoint);
                                }
                            }
                            if (!stopped && item && item === downItem) {
                                clickTime = Date.now();
                                callEvent(this, dblClick && downItem.responds("doubleclick") ? "doubleclick" : "click", event, downPoint, item);
                                dblClick = false;
                            }
                            downItem = dragItem = null;
                            break;

                          case "mousemove":
                            if (dragItem) stopped = callEvent(this, "mousedrag", event, point, dragItem, lastPoint);
                            if (!stopped) {
                                if (item !== overItem) overPoint = point;
                                stopped = callEvent(this, type, event, point, item, overPoint);
                            }
                            lastPoint = overPoint = point;
                            if (item !== overItem) {
                                callEvent(this, "mouseleave", event, point, overItem);
                                overItem = item;
                                callEvent(this, "mouseenter", event, point, item);
                            }
                            break;
                        }
                        return stopped;
                    }
                };
            }());
            var Event = Base.extend({
                _class: "Event",
                initialize: function Event(event) {
                    this.event = event;
                },
                isPrevented: false,
                isStopped: false,
                preventDefault: function() {
                    this.isPrevented = true;
                    this.event.preventDefault();
                },
                stopPropagation: function() {
                    this.isStopped = true;
                    this.event.stopPropagation();
                },
                stop: function() {
                    this.stopPropagation();
                    this.preventDefault();
                },
                getModifiers: function() {
                    return Key.modifiers;
                }
            });
            var KeyEvent = Event.extend({
                _class: "KeyEvent",
                initialize: function KeyEvent(down, key, character, event) {
                    Event.call(this, event);
                    this.type = down ? "keydown" : "keyup";
                    this.key = key;
                    this.character = character;
                },
                toString: function() {
                    return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
                }
            });
            var Key = new function() {
                var specialKeys = {
                    8: "backspace",
                    9: "tab",
                    13: "enter",
                    16: "shift",
                    17: "control",
                    18: "option",
                    19: "pause",
                    20: "caps-lock",
                    27: "escape",
                    32: "space",
                    35: "end",
                    36: "home",
                    37: "left",
                    38: "up",
                    39: "right",
                    40: "down",
                    46: "delete",
                    91: "command",
                    93: "command",
                    224: "command"
                }, specialChars = {
                    9: true,
                    13: true,
                    32: true
                }, modifiers = new Base({
                    shift: false,
                    control: false,
                    option: false,
                    command: false,
                    capsLock: false,
                    space: false
                }), charCodeMap = {}, keyMap = {}, downCode;
                function handleKey(down, keyCode, charCode, event) {
                    var character = charCode ? String.fromCharCode(charCode) : "", specialKey = specialKeys[keyCode], key = specialKey || character.toLowerCase(), type = down ? "keydown" : "keyup", view = View._focused, scope = view && view.isVisible() && view._scope, tool = scope && scope.tool, name;
                    keyMap[key] = down;
                    if (specialKey && (name = Base.camelize(specialKey)) in modifiers) modifiers[name] = down;
                    if (down) {
                        charCodeMap[keyCode] = charCode;
                    } else {
                        delete charCodeMap[keyCode];
                    }
                    if (tool && tool.responds(type)) {
                        paper = scope;
                        tool.emit(type, new KeyEvent(down, key, character, event));
                        if (view) view.update();
                    }
                }
                DomEvent.add(document, {
                    keydown: function(event) {
                        var code = event.which || event.keyCode;
                        if (code in specialKeys || modifiers.command) {
                            handleKey(true, code, code in specialChars || modifiers.command ? code : 0, event);
                        } else {
                            downCode = code;
                        }
                    },
                    keypress: function(event) {
                        if (downCode != null) {
                            handleKey(true, downCode, event.which || event.keyCode, event);
                            downCode = null;
                        }
                    },
                    keyup: function(event) {
                        var code = event.which || event.keyCode;
                        if (code in charCodeMap) handleKey(false, code, charCodeMap[code], event);
                    }
                });
                DomEvent.add(window, {
                    blur: function(event) {
                        for (var code in charCodeMap) handleKey(false, code, charCodeMap[code], event);
                    }
                });
                return {
                    modifiers: modifiers,
                    isDown: function(key) {
                        return !!keyMap[key];
                    }
                };
            }();
            var MouseEvent = Event.extend({
                _class: "MouseEvent",
                initialize: function MouseEvent(type, event, point, target, delta) {
                    Event.call(this, event);
                    this.type = type;
                    this.point = point;
                    this.target = target;
                    this.delta = delta;
                },
                toString: function() {
                    return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }";
                }
            });
            var ToolEvent = Event.extend({
                _class: "ToolEvent",
                _item: null,
                initialize: function ToolEvent(tool, type, event) {
                    this.tool = tool;
                    this.type = type;
                    this.event = event;
                },
                _choosePoint: function(point, toolPoint) {
                    return point ? point : toolPoint ? toolPoint.clone() : null;
                },
                getPoint: function() {
                    return this._choosePoint(this._point, this.tool._point);
                },
                setPoint: function(point) {
                    this._point = point;
                },
                getLastPoint: function() {
                    return this._choosePoint(this._lastPoint, this.tool._lastPoint);
                },
                setLastPoint: function(lastPoint) {
                    this._lastPoint = lastPoint;
                },
                getDownPoint: function() {
                    return this._choosePoint(this._downPoint, this.tool._downPoint);
                },
                setDownPoint: function(downPoint) {
                    this._downPoint = downPoint;
                },
                getMiddlePoint: function() {
                    if (!this._middlePoint && this.tool._lastPoint) {
                        return this.tool._point.add(this.tool._lastPoint).divide(2);
                    }
                    return this._middlePoint;
                },
                setMiddlePoint: function(middlePoint) {
                    this._middlePoint = middlePoint;
                },
                getDelta: function() {
                    return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
                },
                setDelta: function(delta) {
                    this._delta = delta;
                },
                getCount: function() {
                    return /^mouse(down|up)$/.test(this.type) ? this.tool._downCount : this.tool._count;
                },
                setCount: function(count) {
                    this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = count;
                },
                getItem: function() {
                    if (!this._item) {
                        var result = this.tool._scope.project.hitTest(this.getPoint());
                        if (result) {
                            var item = result.item, parent = item._parent;
                            while (/^(Group|CompoundPath)$/.test(parent._class)) {
                                item = parent;
                                parent = parent._parent;
                            }
                            this._item = item;
                        }
                    }
                    return this._item;
                },
                setItem: function(item) {
                    this._item = item;
                },
                toString: function() {
                    return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }";
                }
            });
            var Tool = PaperScopeItem.extend({
                _class: "Tool",
                _list: "tools",
                _reference: "tool",
                _events: [ "onActivate", "onDeactivate", "onEditOptions", "onMouseDown", "onMouseUp", "onMouseDrag", "onMouseMove", "onKeyDown", "onKeyUp" ],
                initialize: function Tool(props) {
                    PaperScopeItem.call(this);
                    this._firstMove = true;
                    this._count = 0;
                    this._downCount = 0;
                    this._set(props);
                },
                getMinDistance: function() {
                    return this._minDistance;
                },
                setMinDistance: function(minDistance) {
                    this._minDistance = minDistance;
                    if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) {
                        this._maxDistance = minDistance;
                    }
                },
                getMaxDistance: function() {
                    return this._maxDistance;
                },
                setMaxDistance: function(maxDistance) {
                    this._maxDistance = maxDistance;
                    if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) {
                        this._minDistance = maxDistance;
                    }
                },
                getFixedDistance: function() {
                    return this._minDistance == this._maxDistance ? this._minDistance : null;
                },
                setFixedDistance: function(distance) {
                    this._minDistance = distance;
                    this._maxDistance = distance;
                },
                _updateEvent: function(type, point, minDistance, maxDistance, start, needsChange, matchMaxDistance) {
                    if (!start) {
                        if (minDistance != null || maxDistance != null) {
                            var minDist = minDistance != null ? minDistance : 0, vector = point.subtract(this._point), distance = vector.getLength();
                            if (distance < minDist) return false;
                            if (maxDistance != null && maxDistance != 0) {
                                if (distance > maxDistance) {
                                    point = this._point.add(vector.normalize(maxDistance));
                                } else if (matchMaxDistance) {
                                    return false;
                                }
                            }
                        }
                        if (needsChange && point.equals(this._point)) return false;
                    }
                    this._lastPoint = start && type == "mousemove" ? point : this._point;
                    this._point = point;
                    switch (type) {
                      case "mousedown":
                        this._lastPoint = this._downPoint;
                        this._downPoint = this._point;
                        this._downCount++;
                        break;

                      case "mouseup":
                        this._lastPoint = this._downPoint;
                        break;
                    }
                    this._count = start ? 0 : this._count + 1;
                    return true;
                },
                _fireEvent: function(type, event) {
                    var sets = paper.project._removeSets;
                    if (sets) {
                        if (type === "mouseup") sets.mousedrag = null;
                        var set = sets[type];
                        if (set) {
                            for (var id in set) {
                                var item = set[id];
                                for (var key in sets) {
                                    var other = sets[key];
                                    if (other && other != set) delete other[item._id];
                                }
                                item.remove();
                            }
                            sets[type] = null;
                        }
                    }
                    return this.responds(type) && this.emit(type, new ToolEvent(this, type, event));
                },
                _handleEvent: function(type, point, event) {
                    paper = this._scope;
                    var called = false;
                    switch (type) {
                      case "mousedown":
                        this._updateEvent(type, point, null, null, true, false, false);
                        called = this._fireEvent(type, event);
                        break;

                      case "mousedrag":
                        var needsChange = false, matchMaxDistance = false;
                        while (this._updateEvent(type, point, this.minDistance, this.maxDistance, false, needsChange, matchMaxDistance)) {
                            called = this._fireEvent(type, event) || called;
                            needsChange = true;
                            matchMaxDistance = true;
                        }
                        break;

                      case "mouseup":
                        if (!point.equals(this._point) && this._updateEvent("mousedrag", point, this.minDistance, this.maxDistance, false, false, false)) {
                            called = this._fireEvent("mousedrag", event);
                        }
                        this._updateEvent(type, point, null, this.maxDistance, false, false, false);
                        called = this._fireEvent(type, event) || called;
                        this._updateEvent(type, point, null, null, true, false, false);
                        this._firstMove = true;
                        break;

                      case "mousemove":
                        while (this._updateEvent(type, point, this.minDistance, this.maxDistance, this._firstMove, true, false)) {
                            called = this._fireEvent(type, event) || called;
                            this._firstMove = false;
                        }
                        break;
                    }
                    if (called) event.preventDefault();
                    return called;
                }
            });
            var Http = {
                request: function(method, url, callback, async) {
                    async = async === undefined ? true : async;
                    var xhr = new (window.ActiveXObject || XMLHttpRequest)("Microsoft.XMLHTTP");
                    xhr.open(method.toUpperCase(), url, async);
                    if ("overrideMimeType" in xhr) xhr.overrideMimeType("text/plain");
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            var status = xhr.status;
                            if (status === 0 || status === 200) {
                                callback.call(xhr, xhr.responseText);
                            } else {
                                throw new Error("Could not load " + url + " (Error " + status + ")");
                            }
                        }
                    };
                    return xhr.send(null);
                }
            };
            var CanvasProvider = {
                canvases: [],
                getCanvas: function(width, height) {
                    var canvas, clear = true;
                    if (typeof width === "object") {
                        height = width.height;
                        width = width.width;
                    }
                    if (this.canvases.length) {
                        canvas = this.canvases.pop();
                    } else {
                        canvas = document.createElement("canvas");
                    }
                    var ctx = canvas.getContext("2d");
                    if (canvas.width === width && canvas.height === height) {
                        if (clear) ctx.clearRect(0, 0, width + 1, height + 1);
                    } else {
                        canvas.width = width;
                        canvas.height = height;
                    }
                    ctx.save();
                    return canvas;
                },
                getContext: function(width, height) {
                    return this.getCanvas(width, height).getContext("2d");
                },
                release: function(obj) {
                    var canvas = obj.canvas ? obj.canvas : obj;
                    canvas.getContext("2d").restore();
                    this.canvases.push(canvas);
                }
            };
            var BlendMode = new function() {
                var min = Math.min, max = Math.max, abs = Math.abs, sr, sg, sb, sa, br, bg, bb, ba, dr, dg, db;
                function getLum(r, g, b) {
                    return .2989 * r + .587 * g + .114 * b;
                }
                function setLum(r, g, b, l) {
                    var d = l - getLum(r, g, b);
                    dr = r + d;
                    dg = g + d;
                    db = b + d;
                    var l = getLum(dr, dg, db), mn = min(dr, dg, db), mx = max(dr, dg, db);
                    if (mn < 0) {
                        var lmn = l - mn;
                        dr = l + (dr - l) * l / lmn;
                        dg = l + (dg - l) * l / lmn;
                        db = l + (db - l) * l / lmn;
                    }
                    if (mx > 255) {
                        var ln = 255 - l, mxl = mx - l;
                        dr = l + (dr - l) * ln / mxl;
                        dg = l + (dg - l) * ln / mxl;
                        db = l + (db - l) * ln / mxl;
                    }
                }
                function getSat(r, g, b) {
                    return max(r, g, b) - min(r, g, b);
                }
                function setSat(r, g, b, s) {
                    var col = [ r, g, b ], mx = max(r, g, b), mn = min(r, g, b), md;
                    mn = mn === r ? 0 : mn === g ? 1 : 2;
                    mx = mx === r ? 0 : mx === g ? 1 : 2;
                    md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
                    if (col[mx] > col[mn]) {
                        col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
                        col[mx] = s;
                    } else {
                        col[md] = col[mx] = 0;
                    }
                    col[mn] = 0;
                    dr = col[0];
                    dg = col[1];
                    db = col[2];
                }
                var modes = {
                    multiply: function() {
                        dr = br * sr / 255;
                        dg = bg * sg / 255;
                        db = bb * sb / 255;
                    },
                    screen: function() {
                        dr = br + sr - br * sr / 255;
                        dg = bg + sg - bg * sg / 255;
                        db = bb + sb - bb * sb / 255;
                    },
                    overlay: function() {
                        dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
                        dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
                        db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
                    },
                    "soft-light": function() {
                        var t = sr * br / 255;
                        dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
                        t = sg * bg / 255;
                        dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
                        t = sb * bb / 255;
                        db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
                    },
                    "hard-light": function() {
                        dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
                        dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
                        db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
                    },
                    "color-dodge": function() {
                        dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
                        dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
                        db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
                    },
                    "color-burn": function() {
                        dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
                        dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
                        db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
                    },
                    darken: function() {
                        dr = br < sr ? br : sr;
                        dg = bg < sg ? bg : sg;
                        db = bb < sb ? bb : sb;
                    },
                    lighten: function() {
                        dr = br > sr ? br : sr;
                        dg = bg > sg ? bg : sg;
                        db = bb > sb ? bb : sb;
                    },
                    difference: function() {
                        dr = br - sr;
                        if (dr < 0) dr = -dr;
                        dg = bg - sg;
                        if (dg < 0) dg = -dg;
                        db = bb - sb;
                        if (db < 0) db = -db;
                    },
                    exclusion: function() {
                        dr = br + sr * (255 - br - br) / 255;
                        dg = bg + sg * (255 - bg - bg) / 255;
                        db = bb + sb * (255 - bb - bb) / 255;
                    },
                    hue: function() {
                        setSat(sr, sg, sb, getSat(br, bg, bb));
                        setLum(dr, dg, db, getLum(br, bg, bb));
                    },
                    saturation: function() {
                        setSat(br, bg, bb, getSat(sr, sg, sb));
                        setLum(dr, dg, db, getLum(br, bg, bb));
                    },
                    luminosity: function() {
                        setLum(br, bg, bb, getLum(sr, sg, sb));
                    },
                    color: function() {
                        setLum(sr, sg, sb, getLum(br, bg, bb));
                    },
                    add: function() {
                        dr = min(br + sr, 255);
                        dg = min(bg + sg, 255);
                        db = min(bb + sb, 255);
                    },
                    subtract: function() {
                        dr = max(br - sr, 0);
                        dg = max(bg - sg, 0);
                        db = max(bb - sb, 0);
                    },
                    average: function() {
                        dr = (br + sr) / 2;
                        dg = (bg + sg) / 2;
                        db = (bb + sb) / 2;
                    },
                    negation: function() {
                        dr = 255 - abs(255 - sr - br);
                        dg = 255 - abs(255 - sg - bg);
                        db = 255 - abs(255 - sb - bb);
                    }
                };
                var nativeModes = this.nativeModes = Base.each([ "source-over", "source-in", "source-out", "source-atop", "destination-over", "destination-in", "destination-out", "destination-atop", "lighter", "darker", "copy", "xor" ], function(mode) {
                    this[mode] = true;
                }, {});
                var ctx = CanvasProvider.getContext(1, 1);
                Base.each(modes, function(func, mode) {
                    var darken = mode === "darken", ok = false;
                    ctx.save();
                    try {
                        ctx.fillStyle = darken ? "#300" : "#a00";
                        ctx.fillRect(0, 0, 1, 1);
                        ctx.globalCompositeOperation = mode;
                        if (ctx.globalCompositeOperation === mode) {
                            ctx.fillStyle = darken ? "#a00" : "#300";
                            ctx.fillRect(0, 0, 1, 1);
                            ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
                        }
                    } catch (e) {}
                    ctx.restore();
                    nativeModes[mode] = ok;
                });
                CanvasProvider.release(ctx);
                this.process = function(mode, srcContext, dstContext, alpha, offset) {
                    var srcCanvas = srcContext.canvas, normal = mode === "normal";
                    if (normal || nativeModes[mode]) {
                        dstContext.save();
                        dstContext.setTransform(1, 0, 0, 1, 0, 0);
                        dstContext.globalAlpha = alpha;
                        if (!normal) dstContext.globalCompositeOperation = mode;
                        dstContext.drawImage(srcCanvas, offset.x, offset.y);
                        dstContext.restore();
                    } else {
                        var process = modes[mode];
                        if (!process) return;
                        var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height), dst = dstData.data, src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;
                        for (var i = 0, l = dst.length; i < l; i += 4) {
                            sr = src[i];
                            br = dst[i];
                            sg = src[i + 1];
                            bg = dst[i + 1];
                            sb = src[i + 2];
                            bb = dst[i + 2];
                            sa = src[i + 3];
                            ba = dst[i + 3];
                            process();
                            var a1 = sa * alpha / 255, a2 = 1 - a1;
                            dst[i] = a1 * dr + a2 * br;
                            dst[i + 1] = a1 * dg + a2 * bg;
                            dst[i + 2] = a1 * db + a2 * bb;
                            dst[i + 3] = sa * alpha + a2 * ba;
                        }
                        dstContext.putImageData(dstData, offset.x, offset.y);
                    }
                };
            }();
            var SVGStyles = Base.each({
                fillColor: [ "fill", "color" ],
                strokeColor: [ "stroke", "color" ],
                strokeWidth: [ "stroke-width", "number" ],
                strokeCap: [ "stroke-linecap", "string" ],
                strokeJoin: [ "stroke-linejoin", "string" ],
                strokeScaling: [ "vector-effect", "lookup", {
                    "true": "none",
                    "false": "non-scaling-stroke"
                }, function(item, value) {
                    return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);
                } ],
                miterLimit: [ "stroke-miterlimit", "number" ],
                dashArray: [ "stroke-dasharray", "array" ],
                dashOffset: [ "stroke-dashoffset", "number" ],
                fontFamily: [ "font-family", "string" ],
                fontWeight: [ "font-weight", "string" ],
                fontSize: [ "font-size", "number" ],
                justification: [ "text-anchor", "lookup", {
                    left: "start",
                    center: "middle",
                    right: "end"
                } ],
                opacity: [ "opacity", "number" ],
                blendMode: [ "mix-blend-mode", "string" ]
            }, function(entry, key) {
                var part = Base.capitalize(key), lookup = entry[2];
                this[key] = {
                    type: entry[1],
                    property: key,
                    attribute: entry[0],
                    toSVG: lookup,
                    fromSVG: lookup && Base.each(lookup, function(value, name) {
                        this[value] = name;
                    }, {}),
                    exportFilter: entry[3],
                    get: "get" + part,
                    set: "set" + part
                };
            }, {});
            var SVGNamespaces = {
                href: "http://www.w3.org/1999/xlink",
                xlink: "http://www.w3.org/2000/xmlns"
            };
            new function() {
                var formatter;
                function setAttributes(node, attrs) {
                    for (var key in attrs) {
                        var val = attrs[key], namespace = SVGNamespaces[key];
                        if (typeof val === "number") val = formatter.number(val);
                        if (namespace) {
                            node.setAttributeNS(namespace, key, val);
                        } else {
                            node.setAttribute(key, val);
                        }
                    }
                    return node;
                }
                function createElement(tag, attrs) {
                    return setAttributes(document.createElementNS("http://www.w3.org/2000/svg", tag), attrs);
                }
                function getTransform(matrix, coordinates, center) {
                    var attrs = new Base(), trans = matrix.getTranslation();
                    if (coordinates) {
                        matrix = matrix.shiftless();
                        var point = matrix._inverseTransform(trans);
                        attrs[center ? "cx" : "x"] = point.x;
                        attrs[center ? "cy" : "y"] = point.y;
                        trans = null;
                    }
                    if (!matrix.isIdentity()) {
                        var decomposed = matrix.decompose();
                        if (decomposed && !decomposed.shearing) {
                            var parts = [], angle = decomposed.rotation, scale = decomposed.scaling;
                            if (trans && !trans.isZero()) parts.push("translate(" + formatter.point(trans) + ")");
                            if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1)) parts.push("scale(" + formatter.point(scale) + ")");
                            if (angle) parts.push("rotate(" + formatter.number(angle) + ")");
                            attrs.transform = parts.join(" ");
                        } else {
                            attrs.transform = "matrix(" + matrix.getValues().join(",") + ")";
                        }
                    }
                    return attrs;
                }
                function exportGroup(item, options) {
                    var attrs = getTransform(item._matrix), children = item._children;
                    var node = createElement("g", attrs);
                    for (var i = 0, l = children.length; i < l; i++) {
                        var child = children[i];
                        var childNode = exportSVG(child, options);
                        if (childNode) {
                            if (child.isClipMask()) {
                                var clip = createElement("clipPath");
                                clip.appendChild(childNode);
                                setDefinition(child, clip, "clip");
                                setAttributes(node, {
                                    "clip-path": "url(#" + clip.id + ")"
                                });
                            } else {
                                node.appendChild(childNode);
                            }
                        }
                    }
                    return node;
                }
                function exportRaster(item) {
                    var attrs = getTransform(item._matrix, true), size = item.getSize();
                    attrs.x -= size.width / 2;
                    attrs.y -= size.height / 2;
                    attrs.width = size.width;
                    attrs.height = size.height;
                    attrs.href = item.toDataURL();
                    return createElement("image", attrs);
                }
                function exportPath(item, options) {
                    if (options.matchShapes) {
                        var shape = item.toShape(false);
                        if (shape) return exportShape(shape, options);
                    }
                    var segments = item._segments, type, attrs = getTransform(item._matrix);
                    if (segments.length === 0) return null;
                    if (item.isPolygon()) {
                        if (segments.length >= 3) {
                            type = item._closed ? "polygon" : "polyline";
                            var parts = [];
                            for (i = 0, l = segments.length; i < l; i++) parts.push(formatter.point(segments[i]._point));
                            attrs.points = parts.join(" ");
                        } else {
                            type = "line";
                            var first = segments[0]._point, last = segments[segments.length - 1]._point;
                            attrs.set({
                                x1: first.x,
                                y1: first.y,
                                x2: last.x,
                                y2: last.y
                            });
                        }
                    } else {
                        type = "path";
                        attrs.d = item.getPathData(null, options.precision);
                    }
                    return createElement(type, attrs);
                }
                function exportShape(item) {
                    var type = item._type, radius = item._radius, attrs = getTransform(item._matrix, true, type !== "rectangle");
                    if (type === "rectangle") {
                        type = "rect";
                        var size = item._size, width = size.width, height = size.height;
                        attrs.x -= width / 2;
                        attrs.y -= height / 2;
                        attrs.width = width;
                        attrs.height = height;
                        if (radius.isZero()) radius = null;
                    }
                    if (radius) {
                        if (type === "circle") {
                            attrs.r = radius;
                        } else {
                            attrs.rx = radius.width;
                            attrs.ry = radius.height;
                        }
                    }
                    return createElement(type, attrs);
                }
                function exportCompoundPath(item, options) {
                    var attrs = getTransform(item._matrix);
                    var data = item.getPathData(null, options.precision);
                    if (data) attrs.d = data;
                    return createElement("path", attrs);
                }
                function exportPlacedSymbol(item, options) {
                    var attrs = getTransform(item._matrix, true), symbol = item.getSymbol(), symbolNode = getDefinition(symbol, "symbol"), definition = symbol.getDefinition(), bounds = definition.getBounds();
                    if (!symbolNode) {
                        symbolNode = createElement("symbol", {
                            viewBox: formatter.rectangle(bounds)
                        });
                        symbolNode.appendChild(exportSVG(definition, options));
                        setDefinition(symbol, symbolNode, "symbol");
                    }
                    attrs.href = "#" + symbolNode.id;
                    attrs.x += bounds.x;
                    attrs.y += bounds.y;
                    attrs.width = formatter.number(bounds.width);
                    attrs.height = formatter.number(bounds.height);
                    attrs.overflow = "visible";
                    return createElement("use", attrs);
                }
                function exportGradient(color) {
                    var gradientNode = getDefinition(color, "color");
                    if (!gradientNode) {
                        var gradient = color.getGradient(), radial = gradient._radial, origin = color.getOrigin().transform(), destination = color.getDestination().transform(), attrs;
                        if (radial) {
                            attrs = {
                                cx: origin.x,
                                cy: origin.y,
                                r: origin.getDistance(destination)
                            };
                            var highlight = color.getHighlight();
                            if (highlight) {
                                highlight = highlight.transform();
                                attrs.fx = highlight.x;
                                attrs.fy = highlight.y;
                            }
                        } else {
                            attrs = {
                                x1: origin.x,
                                y1: origin.y,
                                x2: destination.x,
                                y2: destination.y
                            };
                        }
                        attrs.gradientUnits = "userSpaceOnUse";
                        gradientNode = createElement((radial ? "radial" : "linear") + "Gradient", attrs);
                        var stops = gradient._stops;
                        for (var i = 0, l = stops.length; i < l; i++) {
                            var stop = stops[i], stopColor = stop._color, alpha = stopColor.getAlpha();
                            attrs = {
                                offset: stop._rampPoint,
                                "stop-color": stopColor.toCSS(true)
                            };
                            if (alpha < 1) attrs["stop-opacity"] = alpha;
                            gradientNode.appendChild(createElement("stop", attrs));
                        }
                        setDefinition(color, gradientNode, "color");
                    }
                    return "url(#" + gradientNode.id + ")";
                }
                function exportText(item) {
                    var node = createElement("text", getTransform(item._matrix, true));
                    node.textContent = item._content;
                    return node;
                }
                var exporters = {
                    Group: exportGroup,
                    Layer: exportGroup,
                    Raster: exportRaster,
                    Path: exportPath,
                    Shape: exportShape,
                    CompoundPath: exportCompoundPath,
                    PlacedSymbol: exportPlacedSymbol,
                    PointText: exportText
                };
                function applyStyle(item, node, isRoot) {
                    var attrs = {}, parent = !isRoot && item.getParent();
                    if (item._name != null) attrs.id = item._name;
                    Base.each(SVGStyles, function(entry) {
                        var get = entry.get, type = entry.type, value = item[get]();
                        if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {
                            if (type === "color" && value != null) {
                                var alpha = value.getAlpha();
                                if (alpha < 1) attrs[entry.attribute + "-opacity"] = alpha;
                            }
                            attrs[entry.attribute] = value == null ? "none" : type === "number" ? formatter.number(value) : type === "color" ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === "array" ? value.join(",") : type === "lookup" ? entry.toSVG[value] : value;
                        }
                    });
                    if (attrs.opacity === 1) delete attrs.opacity;
                    if (!item._visible) attrs.visibility = "hidden";
                    return setAttributes(node, attrs);
                }
                var definitions;
                function getDefinition(item, type) {
                    if (!definitions) definitions = {
                        ids: {},
                        svgs: {}
                    };
                    return item && definitions.svgs[type + "-" + item._id];
                }
                function setDefinition(item, node, type) {
                    if (!definitions) getDefinition();
                    var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
                    node.id = type + "-" + id;
                    definitions.svgs[type + "-" + item._id] = node;
                }
                function exportDefinitions(node, options) {
                    var svg = node, defs = null;
                    if (definitions) {
                        svg = node.nodeName.toLowerCase() === "svg" && node;
                        for (var i in definitions.svgs) {
                            if (!defs) {
                                if (!svg) {
                                    svg = createElement("svg");
                                    svg.appendChild(node);
                                }
                                defs = svg.insertBefore(createElement("defs"), svg.firstChild);
                            }
                            defs.appendChild(definitions.svgs[i]);
                        }
                        definitions = null;
                    }
                    return options.asString ? new XMLSerializer().serializeToString(svg) : svg;
                }
                function exportSVG(item, options, isRoot) {
                    var exporter = exporters[item._class], node = exporter && exporter(item, options);
                    if (node) {
                        var onExport = options.onExport;
                        if (onExport) node = onExport(item, node, options) || node;
                        var data = JSON.stringify(item._data);
                        if (data && data !== "{}" && data !== "null") node.setAttribute("data-paper-data", data);
                    }
                    return node && applyStyle(item, node, isRoot);
                }
                function setOptions(options) {
                    if (!options) options = {};
                    formatter = new Formatter(options.precision);
                    return options;
                }
                Item.inject({
                    exportSVG: function(options) {
                        options = setOptions(options);
                        return exportDefinitions(exportSVG(this, options, true), options);
                    }
                });
                Project.inject({
                    exportSVG: function(options) {
                        options = setOptions(options);
                        var layers = this.layers, view = this.getView(), size = view.getViewSize(), node = createElement("svg", {
                            x: 0,
                            y: 0,
                            width: size.width,
                            height: size.height,
                            version: "1.1",
                            xmlns: "http://www.w3.org/2000/svg",
                            "xmlns:xlink": "http://www.w3.org/1999/xlink"
                        }), parent = node, matrix = view._matrix;
                        if (!matrix.isIdentity()) parent = node.appendChild(createElement("g", getTransform(matrix)));
                        for (var i = 0, l = layers.length; i < l; i++) parent.appendChild(exportSVG(layers[i], options, true));
                        return exportDefinitions(node, options);
                    }
                });
            }();
            new function() {
                function getValue(node, name, isString, allowNull) {
                    var namespace = SVGNamespaces[name], value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
                    if (value === "null") value = null;
                    return value == null ? allowNull ? null : isString ? "" : 0 : isString ? value : parseFloat(value);
                }
                function getPoint(node, x, y, allowNull) {
                    x = getValue(node, x, false, allowNull);
                    y = getValue(node, y, false, allowNull);
                    return allowNull && (x == null || y == null) ? null : new Point(x, y);
                }
                function getSize(node, w, h, allowNull) {
                    w = getValue(node, w, false, allowNull);
                    h = getValue(node, h, false, allowNull);
                    return allowNull && (w == null || h == null) ? null : new Size(w, h);
                }
                function convertValue(value, type, lookup) {
                    return value === "none" ? null : type === "number" ? parseFloat(value) : type === "array" ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : type === "color" ? getDefinition(value) || value : type === "lookup" ? lookup[value] : value;
                }
                function importGroup(node, type, options, isRoot) {
                    var nodes = node.childNodes, isClip = type === "clippath", item = new Group(), project = item._project, currentStyle = project._currentStyle, children = [];
                    if (!isClip) {
                        item = applyAttributes(item, node, isRoot);
                        project._currentStyle = item._style.clone();
                    }
                    if (isRoot) {
                        var defs = node.querySelectorAll("defs");
                        for (var i = 0, l = defs.length; i < l; i++) {
                            importSVG(defs[i], options, false);
                        }
                    }
                    for (var i = 0, l = nodes.length; i < l; i++) {
                        var childNode = nodes[i], child;
                        if (childNode.nodeType === 1 && childNode.nodeName.toLowerCase() !== "defs" && (child = importSVG(childNode, options, false)) && !(child instanceof Symbol)) children.push(child);
                    }
                    item.addChildren(children);
                    if (isClip) item = applyAttributes(item.reduce(), node, isRoot);
                    project._currentStyle = currentStyle;
                    if (isClip || type === "defs") {
                        item.remove();
                        item = null;
                    }
                    return item;
                }
                function importPoly(node, type) {
                    var coords = node.getAttribute("points").match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g), points = [];
                    for (var i = 0, l = coords.length; i < l; i += 2) points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));
                    var path = new Path(points);
                    if (type === "polygon") path.closePath();
                    return path;
                }
                function importPath(node) {
                    var data = node.getAttribute("d"), param = {
                        pathData: data
                    };
                    return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data) ? new CompoundPath(param) : new Path(param);
                }
                function importGradient(node, type) {
                    var id = (getValue(node, "href", true) || "").substring(1), isRadial = type === "radialgradient", gradient;
                    if (id) {
                        gradient = definitions[id].getGradient();
                    } else {
                        var nodes = node.childNodes, stops = [];
                        for (var i = 0, l = nodes.length; i < l; i++) {
                            var child = nodes[i];
                            if (child.nodeType === 1) stops.push(applyAttributes(new GradientStop(), child));
                        }
                        gradient = new Gradient(stops, isRadial);
                    }
                    var origin, destination, highlight;
                    if (isRadial) {
                        origin = getPoint(node, "cx", "cy");
                        destination = origin.add(getValue(node, "r"), 0);
                        highlight = getPoint(node, "fx", "fy", true);
                    } else {
                        origin = getPoint(node, "x1", "y1");
                        destination = getPoint(node, "x2", "y2");
                    }
                    applyAttributes(new Color(gradient, origin, destination, highlight), node);
                    return null;
                }
                var importers = {
                    "#document": function(node, type, options, isRoot) {
                        var nodes = node.childNodes;
                        for (var i = 0, l = nodes.length; i < l; i++) {
                            var child = nodes[i];
                            if (child.nodeType === 1) {
                                var next = child.nextSibling;
                                document.body.appendChild(child);
                                var item = importSVG(child, options, isRoot);
                                if (next) {
                                    node.insertBefore(child, next);
                                } else {
                                    node.appendChild(child);
                                }
                                return item;
                            }
                        }
                    },
                    g: importGroup,
                    svg: importGroup,
                    clippath: importGroup,
                    polygon: importPoly,
                    polyline: importPoly,
                    path: importPath,
                    lineargradient: importGradient,
                    radialgradient: importGradient,
                    image: function(node) {
                        var raster = new Raster(getValue(node, "href", true));
                        raster.on("load", function() {
                            var size = getSize(node, "width", "height");
                            this.setSize(size);
                            var center = this._matrix._transformPoint(getPoint(node, "x", "y").add(size.divide(2)));
                            this.translate(center);
                        });
                        return raster;
                    },
                    symbol: function(node, type, options, isRoot) {
                        return new Symbol(importGroup(node, type, options, isRoot), true);
                    },
                    defs: importGroup,
                    use: function(node) {
                        var id = (getValue(node, "href", true) || "").substring(1), definition = definitions[id], point = getPoint(node, "x", "y");
                        return definition ? definition instanceof Symbol ? definition.place(point) : definition.clone().translate(point) : null;
                    },
                    circle: function(node) {
                        return new Shape.Circle(getPoint(node, "cx", "cy"), getValue(node, "r"));
                    },
                    ellipse: function(node) {
                        return new Shape.Ellipse({
                            center: getPoint(node, "cx", "cy"),
                            radius: getSize(node, "rx", "ry")
                        });
                    },
                    rect: function(node) {
                        var point = getPoint(node, "x", "y"), size = getSize(node, "width", "height"), radius = getSize(node, "rx", "ry");
                        return new Shape.Rectangle(new Rectangle(point, size), radius);
                    },
                    line: function(node) {
                        return new Path.Line(getPoint(node, "x1", "y1"), getPoint(node, "x2", "y2"));
                    },
                    text: function(node) {
                        var text = new PointText(getPoint(node, "x", "y").add(getPoint(node, "dx", "dy")));
                        text.setContent(node.textContent.trim() || "");
                        return text;
                    }
                };
                function applyTransform(item, value, name, node) {
                    var transforms = (node.getAttribute(name) || "").split(/\)\s*/g), matrix = new Matrix();
                    for (var i = 0, l = transforms.length; i < l; i++) {
                        var transform = transforms[i];
                        if (!transform) break;
                        var parts = transform.split(/\(\s*/), command = parts[0], v = parts[1].split(/[\s,]+/g);
                        for (var j = 0, m = v.length; j < m; j++) v[j] = parseFloat(v[j]);
                        switch (command) {
                          case "matrix":
                            matrix.concatenate(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
                            break;

                          case "rotate":
                            matrix.rotate(v[0], v[1], v[2]);
                            break;

                          case "translate":
                            matrix.translate(v[0], v[1]);
                            break;

                          case "scale":
                            matrix.scale(v);
                            break;

                          case "skewX":
                            matrix.skew(v[0], 0);
                            break;

                          case "skewY":
                            matrix.skew(0, v[0]);
                            break;
                        }
                    }
                    item.transform(matrix);
                }
                function applyOpacity(item, value, name) {
                    var color = item[name === "fill-opacity" ? "getFillColor" : "getStrokeColor"]();
                    if (color) color.setAlpha(parseFloat(value));
                }
                var attributes = Base.set(Base.each(SVGStyles, function(entry) {
                    this[entry.attribute] = function(item, value) {
                        item[entry.set](convertValue(value, entry.type, entry.fromSVG));
                        if (entry.type === "color" && item instanceof Shape) {
                            var color = item[entry.get]();
                            if (color) color.transform(new Matrix().translate(item.getPosition(true).negate()));
                        }
                    };
                }, {}), {
                    id: function(item, value) {
                        definitions[value] = item;
                        if (item.setName) item.setName(value);
                    },
                    "clip-path": function(item, value) {
                        var clip = getDefinition(value);
                        if (clip) {
                            clip = clip.clone();
                            clip.setClipMask(true);
                            if (item instanceof Group) {
                                item.insertChild(0, clip);
                            } else {
                                return new Group(clip, item);
                            }
                        }
                    },
                    gradientTransform: applyTransform,
                    transform: applyTransform,
                    "fill-opacity": applyOpacity,
                    "stroke-opacity": applyOpacity,
                    visibility: function(item, value) {
                        item.setVisible(value === "visible");
                    },
                    display: function(item, value) {
                        item.setVisible(value !== null);
                    },
                    "stop-color": function(item, value) {
                        if (item.setColor) item.setColor(value);
                    },
                    "stop-opacity": function(item, value) {
                        if (item._color) item._color.setAlpha(parseFloat(value));
                    },
                    offset: function(item, value) {
                        var percentage = value.match(/(.*)%$/);
                        item.setRampPoint(percentage ? percentage[1] / 100 : parseFloat(value));
                    },
                    viewBox: function(item, value, name, node, styles) {
                        var rect = new Rectangle(convertValue(value, "array")), size = getSize(node, "width", "height", true);
                        if (item instanceof Group) {
                            var scale = size ? rect.getSize().divide(size) : 1, matrix = new Matrix().translate(rect.getPoint()).scale(scale);
                            item.transform(matrix.inverted());
                        } else if (item instanceof Symbol) {
                            if (size) rect.setSize(size);
                            var clip = getAttribute(node, "overflow", styles) != "visible", group = item._definition;
                            if (clip && !rect.contains(group.getBounds())) {
                                clip = new Shape.Rectangle(rect).transform(group._matrix);
                                clip.setClipMask(true);
                                group.addChild(clip);
                            }
                        }
                    }
                });
                function getAttribute(node, name, styles) {
                    var attr = node.attributes[name], value = attr && attr.value;
                    if (!value) {
                        var style = Base.camelize(name);
                        value = node.style[style];
                        if (!value && styles.node[style] !== styles.parent[style]) value = styles.node[style];
                    }
                    return !value ? undefined : value === "none" ? null : value;
                }
                function applyAttributes(item, node, isRoot) {
                    var styles = {
                        node: DomElement.getStyles(node) || {},
                        parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
                    };
                    Base.each(attributes, function(apply, name) {
                        var value = getAttribute(node, name, styles);
                        if (value !== undefined) item = Base.pick(apply(item, value, name, node, styles), item);
                    });
                    return item;
                }
                var definitions = {};
                function getDefinition(value) {
                    var match = value && value.match(/\((?:#|)([^)']+)/);
                    return match && definitions[match[1]];
                }
                function importSVG(source, options, isRoot) {
                    if (!source) return null;
                    if (!options) {
                        options = {};
                    } else if (typeof options === "function") {
                        options = {
                            onLoad: options
                        };
                    }
                    var node = source, scope = paper;
                    function onLoadCallback(svg) {
                        paper = scope;
                        var item = importSVG(svg, options, isRoot), onLoad = options.onLoad, view = scope.project && scope.getView();
                        if (onLoad) onLoad.call(this, item);
                        view.update();
                    }
                    if (isRoot) {
                        if (typeof source === "string" && !/^.*</.test(source)) {
                            node = document.getElementById(source);
                            if (node) {
                                source = null;
                            } else {
                                return Http.request("get", source, onLoadCallback);
                            }
                        } else if (typeof File !== "undefined" && source instanceof File) {
                            var reader = new FileReader();
                            reader.onload = function() {
                                onLoadCallback(reader.result);
                            };
                            return reader.readAsText(source);
                        }
                    }
                    if (typeof source === "string") node = new DOMParser().parseFromString(source, "image/svg+xml");
                    if (!node.nodeName) throw new Error("Unsupported SVG source: " + source);
                    var type = node.nodeName.toLowerCase(), importer = importers[type], item, data = node.getAttribute && node.getAttribute("data-paper-data"), settings = scope.settings, applyMatrix = settings.applyMatrix;
                    settings.applyMatrix = false;
                    item = importer && importer(node, type, options, isRoot) || null;
                    settings.applyMatrix = applyMatrix;
                    if (item) {
                        if (type !== "#document" && !(item instanceof Group)) item = applyAttributes(item, node, isRoot);
                        var onImport = options.onImport;
                        if (onImport) item = onImport(node, item, options) || item;
                        if (options.expandShapes && item instanceof Shape) {
                            item.remove();
                            item = item.toPath();
                        }
                        if (data) item._data = JSON.parse(data);
                    }
                    if (isRoot) {
                        definitions = {};
                        if (item && Base.pick(options.applyMatrix, applyMatrix)) item.matrix.apply(true, true);
                    }
                    return item;
                }
                Item.inject({
                    importSVG: function(node, options) {
                        return this.addChild(importSVG(node, options, true));
                    }
                });
                Project.inject({
                    importSVG: function(node, options) {
                        this.activate();
                        return importSVG(node, options, true);
                    }
                });
            }();
            Base.exports.PaperScript = function() {
                var exports, define, scope = this;
                !function(e, r) {
                    return "object" == typeof exports && "object" == typeof module ? r(exports) : "function" == typeof define && define.amd ? define([ "exports" ], r) : (r(e.acorn || (e.acorn = {})), 
                    void 0);
                }(this, function(e) {
                    "use strict";
                    function r(e) {
                        fr = e || {};
                        for (var r in mr) Object.prototype.hasOwnProperty.call(fr, r) || (fr[r] = mr[r]);
                        hr = fr.sourceFile || null;
                    }
                    function t(e, r) {
                        var t = vr(dr, e);
                        r += " (" + t.line + ":" + t.column + ")";
                        var n = new SyntaxError(r);
                        throw n.pos = e, n.loc = t, n.raisedAt = br, n;
                    }
                    function n(e) {
                        function r(e) {
                            if (1 == e.length) return t += "return str === " + JSON.stringify(e[0]) + ";";
                            t += "switch(str){";
                            for (var r = 0; r < e.length; ++r) t += "case " + JSON.stringify(e[r]) + ":";
                            t += "return true}return false;";
                        }
                        e = e.split(" ");
                        var t = "", n = [];
                        e: for (var a = 0; a < e.length; ++a) {
                            for (var o = 0; o < n.length; ++o) if (n[o][0].length == e[a].length) {
                                n[o].push(e[a]);
                                continue e;
                            }
                            n.push([ e[a] ]);
                        }
                        if (n.length > 3) {
                            n.sort(function(e, r) {
                                return r.length - e.length;
                            }), t += "switch(str.length){";
                            for (var a = 0; a < n.length; ++a) {
                                var i = n[a];
                                t += "case " + i[0].length + ":", r(i);
                            }
                            t += "}";
                        } else r(e);
                        return new Function("str", t);
                    }
                    function a() {
                        this.line = Ar, this.column = br - Sr;
                    }
                    function o() {
                        Ar = 1, br = Sr = 0, Er = !0, u();
                    }
                    function i(e, r) {
                        gr = br, fr.locations && (kr = new a()), wr = e, u(), Cr = r, Er = e.beforeExpr;
                    }
                    function s() {
                        var e = fr.onComment && fr.locations && new a(), r = br, n = dr.indexOf("*/", br += 2);
                        if (-1 === n && t(br - 2, "Unterminated comment"), br = n + 2, fr.locations) {
                            Kt.lastIndex = r;
                            for (var o; (o = Kt.exec(dr)) && o.index < br; ) ++Ar, Sr = o.index + o[0].length;
                        }
                        fr.onComment && fr.onComment(!0, dr.slice(r + 2, n), r, br, e, fr.locations && new a());
                    }
                    function c() {
                        for (var e = br, r = fr.onComment && fr.locations && new a(), t = dr.charCodeAt(br += 2); pr > br && 10 !== t && 13 !== t && 8232 !== t && 8233 !== t; ) ++br, 
                        t = dr.charCodeAt(br);
                        fr.onComment && fr.onComment(!1, dr.slice(e + 2, br), e, br, r, fr.locations && new a());
                    }
                    function u() {
                        for (;pr > br; ) {
                            var e = dr.charCodeAt(br);
                            if (32 === e) ++br; else if (13 === e) {
                                ++br;
                                var r = dr.charCodeAt(br);
                                10 === r && ++br, fr.locations && (++Ar, Sr = br);
                            } else if (10 === e || 8232 === e || 8233 === e) ++br, fr.locations && (++Ar, Sr = br); else if (e > 8 && 14 > e) ++br; else if (47 === e) {
                                var r = dr.charCodeAt(br + 1);
                                if (42 === r) s(); else {
                                    if (47 !== r) break;
                                    c();
                                }
                            } else if (160 === e) ++br; else {
                                if (!(e >= 5760 && Jt.test(String.fromCharCode(e)))) break;
                                ++br;
                            }
                        }
                    }
                    function l() {
                        var e = dr.charCodeAt(br + 1);
                        return e >= 48 && 57 >= e ? E(!0) : (++br, i(xt));
                    }
                    function f() {
                        var e = dr.charCodeAt(br + 1);
                        return Er ? (++br, k()) : 61 === e ? x(Et, 2) : x(wt, 1);
                    }
                    function d() {
                        var e = dr.charCodeAt(br + 1);
                        return 61 === e ? x(Et, 2) : x(Dt, 1);
                    }
                    function p(e) {
                        var r = dr.charCodeAt(br + 1);
                        return r === e ? x(124 === e ? Lt : Ut, 2) : 61 === r ? x(Et, 2) : x(124 === e ? Rt : Tt, 1);
                    }
                    function h() {
                        var e = dr.charCodeAt(br + 1);
                        return 61 === e ? x(Et, 2) : x(Vt, 1);
                    }
                    function m(e) {
                        var r = dr.charCodeAt(br + 1);
                        return r === e ? 45 == r && 62 == dr.charCodeAt(br + 2) && Gt.test(dr.slice(Lr, br)) ? (br += 3, 
                        c(), u(), g()) : x(St, 2) : 61 === r ? x(Et, 2) : x(At, 1);
                    }
                    function v(e) {
                        var r = dr.charCodeAt(br + 1), t = 1;
                        return r === e ? (t = 62 === e && 62 === dr.charCodeAt(br + 2) ? 3 : 2, 61 === dr.charCodeAt(br + t) ? x(Et, t + 1) : x(jt, t)) : 33 == r && 60 == e && 45 == dr.charCodeAt(br + 2) && 45 == dr.charCodeAt(br + 3) ? (br += 4, 
                        c(), u(), g()) : (61 === r && (t = 61 === dr.charCodeAt(br + 2) ? 3 : 2), x(Ot, t));
                    }
                    function b(e) {
                        var r = dr.charCodeAt(br + 1);
                        return 61 === r ? x(qt, 61 === dr.charCodeAt(br + 2) ? 3 : 2) : x(61 === e ? Ct : It, 1);
                    }
                    function y(e) {
                        switch (e) {
                          case 46:
                            return l();

                          case 40:
                            return ++br, i(mt);

                          case 41:
                            return ++br, i(vt);

                          case 59:
                            return ++br, i(yt);

                          case 44:
                            return ++br, i(bt);

                          case 91:
                            return ++br, i(ft);

                          case 93:
                            return ++br, i(dt);

                          case 123:
                            return ++br, i(pt);

                          case 125:
                            return ++br, i(ht);

                          case 58:
                            return ++br, i(gt);

                          case 63:
                            return ++br, i(kt);

                          case 48:
                            var r = dr.charCodeAt(br + 1);
                            if (120 === r || 88 === r) return C();

                          case 49:
                          case 50:
                          case 51:
                          case 52:
                          case 53:
                          case 54:
                          case 55:
                          case 56:
                          case 57:
                            return E(!1);

                          case 34:
                          case 39:
                            return A(e);

                          case 47:
                            return f(e);

                          case 37:
                          case 42:
                            return d();

                          case 124:
                          case 38:
                            return p(e);

                          case 94:
                            return h();

                          case 43:
                          case 45:
                            return m(e);

                          case 60:
                          case 62:
                            return v(e);

                          case 61:
                          case 33:
                            return b(e);

                          case 126:
                            return x(It, 1);
                        }
                        return !1;
                    }
                    function g(e) {
                        if (e ? br = yr + 1 : yr = br, fr.locations && (xr = new a()), e) return k();
                        if (br >= pr) return i(Br);
                        var r = dr.charCodeAt(br);
                        if (Qt(r) || 92 === r) return L();
                        var n = y(r);
                        if (n === !1) {
                            var o = String.fromCharCode(r);
                            if ("\\" === o || $t.test(o)) return L();
                            t(br, "Unexpected character '" + o + "'");
                        }
                        return n;
                    }
                    function x(e, r) {
                        var t = dr.slice(br, br + r);
                        br += r, i(e, t);
                    }
                    function k() {
                        for (var e, r, n = "", a = br; ;) {
                            br >= pr && t(a, "Unterminated regular expression");
                            var o = dr.charAt(br);
                            if (Gt.test(o) && t(a, "Unterminated regular expression"), e) e = !1; else {
                                if ("[" === o) r = !0; else if ("]" === o && r) r = !1; else if ("/" === o && !r) break;
                                e = "\\" === o;
                            }
                            ++br;
                        }
                        var n = dr.slice(a, br);
                        ++br;
                        var s = I();
                        return s && !/^[gmsiy]*$/.test(s) && t(a, "Invalid regexp flag"), i(jr, new RegExp(n, s));
                    }
                    function w(e, r) {
                        for (var t = br, n = 0, a = 0, o = null == r ? 1 / 0 : r; o > a; ++a) {
                            var i, s = dr.charCodeAt(br);
                            if (i = s >= 97 ? s - 97 + 10 : s >= 65 ? s - 65 + 10 : s >= 48 && 57 >= s ? s - 48 : 1 / 0, 
                            i >= e) break;
                            ++br, n = n * e + i;
                        }
                        return br === t || null != r && br - t !== r ? null : n;
                    }
                    function C() {
                        br += 2;
                        var e = w(16);
                        return null == e && t(yr + 2, "Expected hexadecimal number"), Qt(dr.charCodeAt(br)) && t(br, "Identifier directly after number"), 
                        i(Or, e);
                    }
                    function E(e) {
                        var r = br, n = !1, a = 48 === dr.charCodeAt(br);
                        e || null !== w(10) || t(r, "Invalid number"), 46 === dr.charCodeAt(br) && (++br, 
                        w(10), n = !0);
                        var o = dr.charCodeAt(br);
                        (69 === o || 101 === o) && (o = dr.charCodeAt(++br), (43 === o || 45 === o) && ++br, 
                        null === w(10) && t(r, "Invalid number"), n = !0), Qt(dr.charCodeAt(br)) && t(br, "Identifier directly after number");
                        var s, c = dr.slice(r, br);
                        return n ? s = parseFloat(c) : a && 1 !== c.length ? /[89]/.test(c) || Tr ? t(r, "Invalid number") : s = parseInt(c, 8) : s = parseInt(c, 10), 
                        i(Or, s);
                    }
                    function A(e) {
                        br++;
                        for (var r = ""; ;) {
                            br >= pr && t(yr, "Unterminated string constant");
                            var n = dr.charCodeAt(br);
                            if (n === e) return ++br, i(Dr, r);
                            if (92 === n) {
                                n = dr.charCodeAt(++br);
                                var a = /^[0-7]+/.exec(dr.slice(br, br + 3));
                                for (a && (a = a[0]); a && parseInt(a, 8) > 255; ) a = a.slice(0, a.length - 1);
                                if ("0" === a && (a = null), ++br, a) Tr && t(br - 2, "Octal literal in strict mode"), 
                                r += String.fromCharCode(parseInt(a, 8)), br += a.length - 1; else switch (n) {
                                  case 110:
                                    r += "\n";
                                    break;

                                  case 114:
                                    r += "\r";
                                    break;

                                  case 120:
                                    r += String.fromCharCode(S(2));
                                    break;

                                  case 117:
                                    r += String.fromCharCode(S(4));
                                    break;

                                  case 85:
                                    r += String.fromCharCode(S(8));
                                    break;

                                  case 116:
                                    r += "	";
                                    break;

                                  case 98:
                                    r += "\b";
                                    break;

                                  case 118:
                                    r += "";
                                    break;

                                  case 102:
                                    r += "\f";
                                    break;

                                  case 48:
                                    r += "\x00";
                                    break;

                                  case 13:
                                    10 === dr.charCodeAt(br) && ++br;

                                  case 10:
                                    fr.locations && (Sr = br, ++Ar);
                                    break;

                                  default:
                                    r += String.fromCharCode(n);
                                }
                            } else (13 === n || 10 === n || 8232 === n || 8233 === n) && t(yr, "Unterminated string constant"), 
                            r += String.fromCharCode(n), ++br;
                        }
                    }
                    function S(e) {
                        var r = w(16, e);
                        return null === r && t(yr, "Bad character escape sequence"), r;
                    }
                    function I() {
                        Bt = !1;
                        for (var e, r = !0, n = br; ;) {
                            var a = dr.charCodeAt(br);
                            if (Yt(a)) Bt && (e += dr.charAt(br)), ++br; else {
                                if (92 !== a) break;
                                Bt || (e = dr.slice(n, br)), Bt = !0, 117 != dr.charCodeAt(++br) && t(br, "Expecting Unicode escape sequence \\uXXXX"), 
                                ++br;
                                var o = S(4), i = String.fromCharCode(o);
                                i || t(br - 1, "Invalid Unicode escape"), (r ? Qt(o) : Yt(o)) || t(br - 4, "Invalid Unicode escape"), 
                                e += i;
                            }
                            r = !1;
                        }
                        return Bt ? e : dr.slice(n, br);
                    }
                    function L() {
                        var e = I(), r = Fr;
                        return Bt || (Wt(e) ? r = lt[e] : (fr.forbidReserved && (3 === fr.ecmaVersion ? Mt : zt)(e) || Tr && Xt(e)) && t(yr, "The keyword '" + e + "' is reserved")), 
                        i(r, e);
                    }
                    function U() {
                        Ir = yr, Lr = gr, Ur = kr, g();
                    }
                    function R(e) {
                        if (Tr = e, br = Lr, fr.locations) for (;Sr > br; ) Sr = dr.lastIndexOf("\n", Sr - 2) + 1, 
                        --Ar;
                        u(), g();
                    }
                    function V() {
                        this.type = null, this.start = yr, this.end = null;
                    }
                    function T() {
                        this.start = xr, this.end = null, null !== hr && (this.source = hr);
                    }
                    function q() {
                        var e = new V();
                        return fr.locations && (e.loc = new T()), fr.ranges && (e.range = [ yr, 0 ]), e;
                    }
                    function O(e) {
                        var r = new V();
                        return r.start = e.start, fr.locations && (r.loc = new T(), r.loc.start = e.loc.start), 
                        fr.ranges && (r.range = [ e.range[0], 0 ]), r;
                    }
                    function j(e, r) {
                        return e.type = r, e.end = Lr, fr.locations && (e.loc.end = Ur), fr.ranges && (e.range[1] = Lr), 
                        e;
                    }
                    function D(e) {
                        return fr.ecmaVersion >= 5 && "ExpressionStatement" === e.type && "Literal" === e.expression.type && "use strict" === e.expression.value;
                    }
                    function F(e) {
                        return wr === e ? (U(), !0) : void 0;
                    }
                    function B() {
                        return !fr.strictSemicolons && (wr === Br || wr === ht || Gt.test(dr.slice(Lr, yr)));
                    }
                    function M() {
                        F(yt) || B() || X();
                    }
                    function z(e) {
                        wr === e ? U() : X();
                    }
                    function X() {
                        t(yr, "Unexpected token");
                    }
                    function N(e) {
                        "Identifier" !== e.type && "MemberExpression" !== e.type && t(e.start, "Assigning to rvalue"), 
                        Tr && "Identifier" === e.type && Nt(e.name) && t(e.start, "Assigning to " + e.name + " in strict mode");
                    }
                    function W(e) {
                        Ir = Lr = br, fr.locations && (Ur = new a()), Rr = Tr = null, Vr = [], g();
                        var r = e || q(), t = !0;
                        for (e || (r.body = []); wr !== Br; ) {
                            var n = J();
                            r.body.push(n), t && D(n) && R(!0), t = !1;
                        }
                        return j(r, "Program");
                    }
                    function J() {
                        (wr === wt || wr === Et && "/=" == Cr) && g(!0);
                        var e = wr, r = q();
                        switch (e) {
                          case Mr:
                          case Nr:
                            U();
                            var n = e === Mr;
                            F(yt) || B() ? r.label = null : wr !== Fr ? X() : (r.label = lr(), M());
                            for (var a = 0; a < Vr.length; ++a) {
                                var o = Vr[a];
                                if (null == r.label || o.name === r.label.name) {
                                    if (null != o.kind && (n || "loop" === o.kind)) break;
                                    if (r.label && n) break;
                                }
                            }
                            return a === Vr.length && t(r.start, "Unsyntactic " + e.keyword), j(r, n ? "BreakStatement" : "ContinueStatement");

                          case Wr:
                            return U(), M(), j(r, "DebuggerStatement");

                          case Pr:
                            return U(), Vr.push(Zt), r.body = J(), Vr.pop(), z(tt), r.test = P(), M(), j(r, "DoWhileStatement");

                          case _r:
                            if (U(), Vr.push(Zt), z(mt), wr === yt) return $(r, null);
                            if (wr === rt) {
                                var i = q();
                                return U(), G(i, !0), j(i, "VariableDeclaration"), 1 === i.declarations.length && F(ut) ? _(r, i) : $(r, i);
                            }
                            var i = K(!1, !0);
                            return F(ut) ? (N(i), _(r, i)) : $(r, i);

                          case Gr:
                            return U(), cr(r, !0);

                          case Kr:
                            return U(), r.test = P(), r.consequent = J(), r.alternate = F(Hr) ? J() : null, 
                            j(r, "IfStatement");

                          case Qr:
                            return Rr || t(yr, "'return' outside of function"), U(), F(yt) || B() ? r.argument = null : (r.argument = K(), 
                            M()), j(r, "ReturnStatement");

                          case Yr:
                            U(), r.discriminant = P(), r.cases = [], z(pt), Vr.push(en);
                            for (var s, c; wr != ht; ) if (wr === zr || wr === Jr) {
                                var u = wr === zr;
                                s && j(s, "SwitchCase"), r.cases.push(s = q()), s.consequent = [], U(), u ? s.test = K() : (c && t(Ir, "Multiple default clauses"), 
                                c = !0, s.test = null), z(gt);
                            } else s || X(), s.consequent.push(J());
                            return s && j(s, "SwitchCase"), U(), Vr.pop(), j(r, "SwitchStatement");

                          case Zr:
                            return U(), Gt.test(dr.slice(Lr, yr)) && t(Lr, "Illegal newline after throw"), r.argument = K(), 
                            M(), j(r, "ThrowStatement");

                          case et:
                            if (U(), r.block = H(), r.handler = null, wr === Xr) {
                                var l = q();
                                U(), z(mt), l.param = lr(), Tr && Nt(l.param.name) && t(l.param.start, "Binding " + l.param.name + " in strict mode"), 
                                z(vt), l.guard = null, l.body = H(), r.handler = j(l, "CatchClause");
                            }
                            return r.guardedHandlers = qr, r.finalizer = F($r) ? H() : null, r.handler || r.finalizer || t(r.start, "Missing catch or finally clause"), 
                            j(r, "TryStatement");

                          case rt:
                            return U(), G(r), M(), j(r, "VariableDeclaration");

                          case tt:
                            return U(), r.test = P(), Vr.push(Zt), r.body = J(), Vr.pop(), j(r, "WhileStatement");

                          case nt:
                            return Tr && t(yr, "'with' in strict mode"), U(), r.object = P(), r.body = J(), 
                            j(r, "WithStatement");

                          case pt:
                            return H();

                          case yt:
                            return U(), j(r, "EmptyStatement");

                          default:
                            var f = Cr, d = K();
                            if (e === Fr && "Identifier" === d.type && F(gt)) {
                                for (var a = 0; a < Vr.length; ++a) Vr[a].name === f && t(d.start, "Label '" + f + "' is already declared");
                                var p = wr.isLoop ? "loop" : wr === Yr ? "switch" : null;
                                return Vr.push({
                                    name: f,
                                    kind: p
                                }), r.body = J(), Vr.pop(), r.label = d, j(r, "LabeledStatement");
                            }
                            return r.expression = d, M(), j(r, "ExpressionStatement");
                        }
                    }
                    function P() {
                        z(mt);
                        var e = K();
                        return z(vt), e;
                    }
                    function H(e) {
                        var r, t = q(), n = !0, a = !1;
                        for (t.body = [], z(pt); !F(ht); ) {
                            var o = J();
                            t.body.push(o), n && e && D(o) && (r = a, R(a = !0)), n = !1;
                        }
                        return a && !r && R(!1), j(t, "BlockStatement");
                    }
                    function $(e, r) {
                        return e.init = r, z(yt), e.test = wr === yt ? null : K(), z(yt), e.update = wr === vt ? null : K(), 
                        z(vt), e.body = J(), Vr.pop(), j(e, "ForStatement");
                    }
                    function _(e, r) {
                        return e.left = r, e.right = K(), z(vt), e.body = J(), Vr.pop(), j(e, "ForInStatement");
                    }
                    function G(e, r) {
                        for (e.declarations = [], e.kind = "var"; ;) {
                            var n = q();
                            if (n.id = lr(), Tr && Nt(n.id.name) && t(n.id.start, "Binding " + n.id.name + " in strict mode"), 
                            n.init = F(Ct) ? K(!0, r) : null, e.declarations.push(j(n, "VariableDeclarator")), 
                            !F(bt)) break;
                        }
                        return e;
                    }
                    function K(e, r) {
                        var t = Q(r);
                        if (!e && wr === bt) {
                            var n = O(t);
                            for (n.expressions = [ t ]; F(bt); ) n.expressions.push(Q(r));
                            return j(n, "SequenceExpression");
                        }
                        return t;
                    }
                    function Q(e) {
                        var r = Y(e);
                        if (wr.isAssign) {
                            var t = O(r);
                            return t.operator = Cr, t.left = r, U(), t.right = Q(e), N(r), j(t, "AssignmentExpression");
                        }
                        return r;
                    }
                    function Y(e) {
                        var r = Z(e);
                        if (F(kt)) {
                            var t = O(r);
                            return t.test = r, t.consequent = K(!0), z(gt), t.alternate = K(!0, e), j(t, "ConditionalExpression");
                        }
                        return r;
                    }
                    function Z(e) {
                        return er(rr(), -1, e);
                    }
                    function er(e, r, t) {
                        var n = wr.binop;
                        if (null != n && (!t || wr !== ut) && n > r) {
                            var a = O(e);
                            a.left = e, a.operator = Cr, U(), a.right = er(rr(), n, t);
                            var o = j(a, /&&|\|\|/.test(a.operator) ? "LogicalExpression" : "BinaryExpression");
                            return er(o, r, t);
                        }
                        return e;
                    }
                    function rr() {
                        if (wr.prefix) {
                            var e = q(), r = wr.isUpdate;
                            return e.operator = Cr, e.prefix = !0, Er = !0, U(), e.argument = rr(), r ? N(e.argument) : Tr && "delete" === e.operator && "Identifier" === e.argument.type && t(e.start, "Deleting local variable in strict mode"), 
                            j(e, r ? "UpdateExpression" : "UnaryExpression");
                        }
                        for (var n = tr(); wr.postfix && !B(); ) {
                            var e = O(n);
                            e.operator = Cr, e.prefix = !1, e.argument = n, N(n), U(), n = j(e, "UpdateExpression");
                        }
                        return n;
                    }
                    function tr() {
                        return nr(ar());
                    }
                    function nr(e, r) {
                        if (F(xt)) {
                            var t = O(e);
                            return t.object = e, t.property = lr(!0), t.computed = !1, nr(j(t, "MemberExpression"), r);
                        }
                        if (F(ft)) {
                            var t = O(e);
                            return t.object = e, t.property = K(), t.computed = !0, z(dt), nr(j(t, "MemberExpression"), r);
                        }
                        if (!r && F(mt)) {
                            var t = O(e);
                            return t.callee = e, t.arguments = ur(vt, !1), nr(j(t, "CallExpression"), r);
                        }
                        return e;
                    }
                    function ar() {
                        switch (wr) {
                          case ot:
                            var e = q();
                            return U(), j(e, "ThisExpression");

                          case Fr:
                            return lr();

                          case Or:
                          case Dr:
                          case jr:
                            var e = q();
                            return e.value = Cr, e.raw = dr.slice(yr, gr), U(), j(e, "Literal");

                          case it:
                          case st:
                          case ct:
                            var e = q();
                            return e.value = wr.atomValue, e.raw = wr.keyword, U(), j(e, "Literal");

                          case mt:
                            var r = xr, t = yr;
                            U();
                            var n = K();
                            return n.start = t, n.end = gr, fr.locations && (n.loc.start = r, n.loc.end = kr), 
                            fr.ranges && (n.range = [ t, gr ]), z(vt), n;

                          case ft:
                            var e = q();
                            return U(), e.elements = ur(dt, !0, !0), j(e, "ArrayExpression");

                          case pt:
                            return ir();

                          case Gr:
                            var e = q();
                            return U(), cr(e, !1);

                          case at:
                            return or();

                          default:
                            X();
                        }
                    }
                    function or() {
                        var e = q();
                        return U(), e.callee = nr(ar(), !0), e.arguments = F(mt) ? ur(vt, !1) : qr, j(e, "NewExpression");
                    }
                    function ir() {
                        var e = q(), r = !0, n = !1;
                        for (e.properties = [], U(); !F(ht); ) {
                            if (r) r = !1; else if (z(bt), fr.allowTrailingCommas && F(ht)) break;
                            var a, o = {
                                key: sr()
                            }, i = !1;
                            if (F(gt) ? (o.value = K(!0), a = o.kind = "init") : fr.ecmaVersion >= 5 && "Identifier" === o.key.type && ("get" === o.key.name || "set" === o.key.name) ? (i = n = !0, 
                            a = o.kind = o.key.name, o.key = sr(), wr !== mt && X(), o.value = cr(q(), !1)) : X(), 
                            "Identifier" === o.key.type && (Tr || n)) for (var s = 0; s < e.properties.length; ++s) {
                                var c = e.properties[s];
                                if (c.key.name === o.key.name) {
                                    var u = a == c.kind || i && "init" === c.kind || "init" === a && ("get" === c.kind || "set" === c.kind);
                                    u && !Tr && "init" === a && "init" === c.kind && (u = !1), u && t(o.key.start, "Redefinition of property");
                                }
                            }
                            e.properties.push(o);
                        }
                        return j(e, "ObjectExpression");
                    }
                    function sr() {
                        return wr === Or || wr === Dr ? ar() : lr(!0);
                    }
                    function cr(e, r) {
                        wr === Fr ? e.id = lr() : r ? X() : e.id = null, e.params = [];
                        var n = !0;
                        for (z(mt); !F(vt); ) n ? n = !1 : z(bt), e.params.push(lr());
                        var a = Rr, o = Vr;
                        if (Rr = !0, Vr = [], e.body = H(!0), Rr = a, Vr = o, Tr || e.body.body.length && D(e.body.body[0])) for (var i = e.id ? -1 : 0; i < e.params.length; ++i) {
                            var s = 0 > i ? e.id : e.params[i];
                            if ((Xt(s.name) || Nt(s.name)) && t(s.start, "Defining '" + s.name + "' in strict mode"), 
                            i >= 0) for (var c = 0; i > c; ++c) s.name === e.params[c].name && t(s.start, "Argument name clash in strict mode");
                        }
                        return j(e, r ? "FunctionDeclaration" : "FunctionExpression");
                    }
                    function ur(e, r, t) {
                        for (var n = [], a = !0; !F(e); ) {
                            if (a) a = !1; else if (z(bt), r && fr.allowTrailingCommas && F(e)) break;
                            t && wr === bt ? n.push(null) : n.push(K(!0));
                        }
                        return n;
                    }
                    function lr(e) {
                        var r = q();
                        return r.name = wr === Fr ? Cr : e && !fr.forbidReserved && wr.keyword || X(), Er = !1, 
                        U(), j(r, "Identifier");
                    }
                    e.version = "0.4.0";
                    var fr, dr, pr, hr;
                    e.parse = function(e, t) {
                        return dr = String(e), pr = dr.length, r(t), o(), W(fr.program);
                    };
                    var mr = e.defaultOptions = {
                        ecmaVersion: 5,
                        strictSemicolons: !1,
                        allowTrailingCommas: !0,
                        forbidReserved: !1,
                        locations: !1,
                        onComment: null,
                        ranges: !1,
                        program: null,
                        sourceFile: null
                    }, vr = e.getLineInfo = function(e, r) {
                        for (var t = 1, n = 0; ;) {
                            Kt.lastIndex = n;
                            var a = Kt.exec(e);
                            if (!(a && a.index < r)) break;
                            ++t, n = a.index + a[0].length;
                        }
                        return {
                            line: t,
                            column: r - n
                        };
                    };
                    e.tokenize = function(e, t) {
                        function n(e) {
                            return g(e), a.start = yr, a.end = gr, a.startLoc = xr, a.endLoc = kr, a.type = wr, 
                            a.value = Cr, a;
                        }
                        dr = String(e), pr = dr.length, r(t), o();
                        var a = {};
                        return n.jumpTo = function(e, r) {
                            if (br = e, fr.locations) {
                                Ar = 1, Sr = Kt.lastIndex = 0;
                                for (var t; (t = Kt.exec(dr)) && t.index < e; ) ++Ar, Sr = t.index + t[0].length;
                            }
                            Er = r, u();
                        }, n;
                    };
                    var br, yr, gr, xr, kr, wr, Cr, Er, Ar, Sr, Ir, Lr, Ur, Rr, Vr, Tr, qr = [], Or = {
                        type: "num"
                    }, jr = {
                        type: "regexp"
                    }, Dr = {
                        type: "string"
                    }, Fr = {
                        type: "name"
                    }, Br = {
                        type: "eof"
                    }, Mr = {
                        keyword: "break"
                    }, zr = {
                        keyword: "case",
                        beforeExpr: !0
                    }, Xr = {
                        keyword: "catch"
                    }, Nr = {
                        keyword: "continue"
                    }, Wr = {
                        keyword: "debugger"
                    }, Jr = {
                        keyword: "default"
                    }, Pr = {
                        keyword: "do",
                        isLoop: !0
                    }, Hr = {
                        keyword: "else",
                        beforeExpr: !0
                    }, $r = {
                        keyword: "finally"
                    }, _r = {
                        keyword: "for",
                        isLoop: !0
                    }, Gr = {
                        keyword: "function"
                    }, Kr = {
                        keyword: "if"
                    }, Qr = {
                        keyword: "return",
                        beforeExpr: !0
                    }, Yr = {
                        keyword: "switch"
                    }, Zr = {
                        keyword: "throw",
                        beforeExpr: !0
                    }, et = {
                        keyword: "try"
                    }, rt = {
                        keyword: "var"
                    }, tt = {
                        keyword: "while",
                        isLoop: !0
                    }, nt = {
                        keyword: "with"
                    }, at = {
                        keyword: "new",
                        beforeExpr: !0
                    }, ot = {
                        keyword: "this"
                    }, it = {
                        keyword: "null",
                        atomValue: null
                    }, st = {
                        keyword: "true",
                        atomValue: !0
                    }, ct = {
                        keyword: "false",
                        atomValue: !1
                    }, ut = {
                        keyword: "in",
                        binop: 7,
                        beforeExpr: !0
                    }, lt = {
                        "break": Mr,
                        "case": zr,
                        "catch": Xr,
                        "continue": Nr,
                        "debugger": Wr,
                        "default": Jr,
                        "do": Pr,
                        "else": Hr,
                        "finally": $r,
                        "for": _r,
                        "function": Gr,
                        "if": Kr,
                        "return": Qr,
                        "switch": Yr,
                        "throw": Zr,
                        "try": et,
                        "var": rt,
                        "while": tt,
                        "with": nt,
                        "null": it,
                        "true": st,
                        "false": ct,
                        "new": at,
                        "in": ut,
                        "instanceof": {
                            keyword: "instanceof",
                            binop: 7,
                            beforeExpr: !0
                        },
                        "this": ot,
                        "typeof": {
                            keyword: "typeof",
                            prefix: !0,
                            beforeExpr: !0
                        },
                        "void": {
                            keyword: "void",
                            prefix: !0,
                            beforeExpr: !0
                        },
                        "delete": {
                            keyword: "delete",
                            prefix: !0,
                            beforeExpr: !0
                        }
                    }, ft = {
                        type: "[",
                        beforeExpr: !0
                    }, dt = {
                        type: "]"
                    }, pt = {
                        type: "{",
                        beforeExpr: !0
                    }, ht = {
                        type: "}"
                    }, mt = {
                        type: "(",
                        beforeExpr: !0
                    }, vt = {
                        type: ")"
                    }, bt = {
                        type: ",",
                        beforeExpr: !0
                    }, yt = {
                        type: ";",
                        beforeExpr: !0
                    }, gt = {
                        type: ":",
                        beforeExpr: !0
                    }, xt = {
                        type: "."
                    }, kt = {
                        type: "?",
                        beforeExpr: !0
                    }, wt = {
                        binop: 10,
                        beforeExpr: !0
                    }, Ct = {
                        isAssign: !0,
                        beforeExpr: !0
                    }, Et = {
                        isAssign: !0,
                        beforeExpr: !0
                    }, At = {
                        binop: 9,
                        prefix: !0,
                        beforeExpr: !0
                    }, St = {
                        postfix: !0,
                        prefix: !0,
                        isUpdate: !0
                    }, It = {
                        prefix: !0,
                        beforeExpr: !0
                    }, Lt = {
                        binop: 1,
                        beforeExpr: !0
                    }, Ut = {
                        binop: 2,
                        beforeExpr: !0
                    }, Rt = {
                        binop: 3,
                        beforeExpr: !0
                    }, Vt = {
                        binop: 4,
                        beforeExpr: !0
                    }, Tt = {
                        binop: 5,
                        beforeExpr: !0
                    }, qt = {
                        binop: 6,
                        beforeExpr: !0
                    }, Ot = {
                        binop: 7,
                        beforeExpr: !0
                    }, jt = {
                        binop: 8,
                        beforeExpr: !0
                    }, Dt = {
                        binop: 10,
                        beforeExpr: !0
                    };
                    e.tokTypes = {
                        bracketL: ft,
                        bracketR: dt,
                        braceL: pt,
                        braceR: ht,
                        parenL: mt,
                        parenR: vt,
                        comma: bt,
                        semi: yt,
                        colon: gt,
                        dot: xt,
                        question: kt,
                        slash: wt,
                        eq: Ct,
                        name: Fr,
                        eof: Br,
                        num: Or,
                        regexp: jr,
                        string: Dr
                    };
                    for (var Ft in lt) e.tokTypes["_" + Ft] = lt[Ft];
                    var Bt, Mt = n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"), zt = n("class enum extends super const export import"), Xt = n("implements interface let package private protected public static yield"), Nt = n("eval arguments"), Wt = n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"), Jt = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Pt = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Ht = "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ؚؠ-ىٲ-ۓۧ-ۨۻ-ۼܰ-݊ࠀ-ࠔࠛ-ࠣࠥ-ࠧࠩ-࠭ࡀ-ࡗࣤ-ࣾऀ-ःऺ-़ा-ॏ॑-ॗॢ-ॣ०-९ঁ-ঃ়া-ৄেৈৗয়-ৠਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢ-ૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୟ-ୠ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఁ-ఃె-ైొ-్ౕౖౢ-ౣ౦-౯ಂಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢ-ೣ೦-೯ംഃെ-ൈൗൢ-ൣ൦-൯ංඃ්ා-ුූෘ-ෟෲෳิ-ฺเ-ๅ๐-๙ິ-ູ່-ໍ໐-໙༘༙༠-༩༹༵༷ཁ-ཇཱ-྄྆-྇ྍ-ྗྙ-ྼ࿆က-ဩ၀-၉ၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟ᜎ-ᜐᜠ-ᜰᝀ-ᝐᝲᝳក-ឲ៝០-៩᠋-᠍᠐-᠙ᤠ-ᤫᤰ-᤻ᥑ-ᥭᦰ-ᧀᧈ-ᧉ᧐-᧙ᨀ-ᨕᨠ-ᩓ᩠-᩿᩼-᪉᪐-᪙ᭆ-ᭋ᭐-᭙᭫-᭳᮰-᮹᯦-᯳ᰀ-ᰢ᱀-᱉ᱛ-ᱽ᳐-᳒ᴀ-ᶾḁ-ἕ‌‍‿⁀⁔⃐-⃥⃜⃡-⃰ⶁ-ⶖⷠ-ⷿ〡-〨゙゚Ꙁ-ꙭꙴ-꙽ꚟ꛰-꛱ꟸ-ꠀ꠆ꠋꠣ-ꠧꢀ-ꢁꢴ-꣄꣐-꣙ꣳ-ꣷ꤀-꤉ꤦ-꤭ꤰ-ꥅꦀ-ꦃ꦳-꧀ꨀ-ꨧꩀ-ꩁꩌ-ꩍ꩐-꩙ꩻꫠ-ꫩꫲ-ꫳꯀ-ꯡ꯬꯭꯰-꯹ﬠ-ﬨ︀-️︠-︦︳︴﹍-﹏０-９＿", $t = new RegExp("[" + Pt + "]"), _t = new RegExp("[" + Pt + Ht + "]"), Gt = /[\n\r\u2028\u2029]/, Kt = /\r\n|[\n\r\u2028\u2029]/g, Qt = e.isIdentifierStart = function(e) {
                        return 65 > e ? 36 === e : 91 > e ? !0 : 97 > e ? 95 === e : 123 > e ? !0 : e >= 170 && $t.test(String.fromCharCode(e));
                    }, Yt = e.isIdentifierChar = function(e) {
                        return 48 > e ? 36 === e : 58 > e ? !0 : 65 > e ? !1 : 91 > e ? !0 : 97 > e ? 95 === e : 123 > e ? !0 : e >= 170 && _t.test(String.fromCharCode(e));
                    }, Zt = {
                        kind: "loop"
                    }, en = {
                        kind: "switch"
                    };
                });
                var binaryOperators = {
                    "+": "__add",
                    "-": "__subtract",
                    "*": "__multiply",
                    "/": "__divide",
                    "%": "__modulo",
                    "==": "equals",
                    "!=": "equals"
                };
                var unaryOperators = {
                    "-": "__negate",
                    "+": null
                };
                var fields = Base.each([ "add", "subtract", "multiply", "divide", "modulo", "negate" ], function(name) {
                    this["__" + name] = "#" + name;
                }, {});
                Point.inject(fields);
                Size.inject(fields);
                Color.inject(fields);
                function __$__(left, operator, right) {
                    var handler = binaryOperators[operator];
                    if (left && left[handler]) {
                        var res = left[handler](right);
                        return operator === "!=" ? !res : res;
                    }
                    switch (operator) {
                      case "+":
                        return left + right;

                      case "-":
                        return left - right;

                      case "*":
                        return left * right;

                      case "/":
                        return left / right;

                      case "%":
                        return left % right;

                      case "==":
                        return left == right;

                      case "!=":
                        return left != right;
                    }
                }
                function $__(operator, value) {
                    var handler = unaryOperators[operator];
                    if (handler && value && value[handler]) return value[handler]();
                    switch (operator) {
                      case "+":
                        return +value;

                      case "-":
                        return -value;
                    }
                }
                function parse(code, options) {
                    return scope.acorn.parse(code, options);
                }
                function compile(code, url, options) {
                    if (!code) return "";
                    options = options || {};
                    url = url || "";
                    var insertions = [];
                    function getOffset(offset) {
                        for (var i = 0, l = insertions.length; i < l; i++) {
                            var insertion = insertions[i];
                            if (insertion[0] >= offset) break;
                            offset += insertion[1];
                        }
                        return offset;
                    }
                    function getCode(node) {
                        return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));
                    }
                    function getBetween(left, right) {
                        return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));
                    }
                    function replaceCode(node, str) {
                        var start = getOffset(node.range[0]), end = getOffset(node.range[1]), insert = 0;
                        for (var i = insertions.length - 1; i >= 0; i--) {
                            if (start > insertions[i][0]) {
                                insert = i + 1;
                                break;
                            }
                        }
                        insertions.splice(insert, 0, [ start, str.length - end + start ]);
                        code = code.substring(0, start) + str + code.substring(end);
                    }
                    function walkAST(node, parent) {
                        if (!node) return;
                        for (var key in node) {
                            if (key === "range" || key === "loc") continue;
                            var value = node[key];
                            if (Array.isArray(value)) {
                                for (var i = 0, l = value.length; i < l; i++) walkAST(value[i], node);
                            } else if (value && typeof value === "object") {
                                walkAST(value, node);
                            }
                        }
                        switch (node.type) {
                          case "UnaryExpression":
                            if (node.operator in unaryOperators && node.argument.type !== "Literal") {
                                var arg = getCode(node.argument);
                                replaceCode(node, '$__("' + node.operator + '", ' + arg + ")");
                            }
                            break;

                          case "BinaryExpression":
                            if (node.operator in binaryOperators && node.left.type !== "Literal") {
                                var left = getCode(node.left), right = getCode(node.right), between = getBetween(node.left, node.right), operator = node.operator;
                                replaceCode(node, "__$__(" + left + "," + between.replace(new RegExp("\\" + operator), '"' + operator + '"') + ", " + right + ")");
                            }
                            break;

                          case "UpdateExpression":
                          case "AssignmentExpression":
                            var parentType = parent && parent.type;
                            if (!(parentType === "ForStatement" || parentType === "BinaryExpression" && /^[=!<>]/.test(parent.operator) || parentType === "MemberExpression" && parent.computed)) {
                                if (node.type === "UpdateExpression") {
                                    var arg = getCode(node.argument), exp = "__$__(" + arg + ', "' + node.operator[0] + '", 1)', str = arg + " = " + exp;
                                    if (!node.prefix && (parentType === "AssignmentExpression" || parentType === "VariableDeclarator")) {
                                        if (getCode(parent.left || parent.id) === arg) str = exp;
                                        str = arg + "; " + str;
                                    }
                                    replaceCode(node, str);
                                } else {
                                    if (/^.=$/.test(node.operator) && node.left.type !== "Literal") {
                                        var left = getCode(node.left), right = getCode(node.right);
                                        replaceCode(node, left + " = __$__(" + left + ', "' + node.operator[0] + '", ' + right + ")");
                                    }
                                }
                            }
                            break;
                        }
                    }
                    var sourceMap = null, browser = paper.browser, version = browser.versionNumber, lineBreaks = /\r\n|\n|\r/gm;
                    if (browser.chrome && version >= 30 || browser.webkit && version >= 537.76 || browser.firefox && version >= 23) {
                        var offset = 0;
                        if (window.location.href.indexOf(url) === 0) {
                            var html = document.getElementsByTagName("html")[0].innerHTML;
                            offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;
                        }
                        var mappings = [ "AAAA" ];
                        mappings.length = (code.match(lineBreaks) || []).length + 1 + offset;
                        sourceMap = {
                            version: 3,
                            file: url,
                            names: [],
                            mappings: mappings.join(";AACA"),
                            sourceRoot: "",
                            sources: [ url ]
                        };
                        var source = options.source || !url && code;
                        if (source) sourceMap.sourcesContent = [ source ];
                    }
                    walkAST(parse(code, {
                        ranges: true
                    }));
                    if (sourceMap) {
                        code = new Array(offset + 1).join("\n") + code + "\n//# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + "\n//# sourceURL=" + (url || "paperscript");
                    }
                    return code;
                }
                function execute(code, scope, url, options) {
                    paper = scope;
                    var view = scope.getView(), tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) ? new Tool() : null, toolHandlers = tool ? tool._events : [], handlers = [ "onFrame", "onResize" ].concat(toolHandlers), params = [], args = [], func;
                    code = compile(code, url, options);
                    function expose(scope, hidden) {
                        for (var key in scope) {
                            if ((hidden || !/^_/.test(key)) && new RegExp("([\\b\\s\\W]|^)" + key.replace(/\$/g, "\\$") + "\\b").test(code)) {
                                params.push(key);
                                args.push(scope[key]);
                            }
                        }
                    }
                    expose({
                        __$__: __$__,
                        $__: $__,
                        paper: scope,
                        view: view,
                        tool: tool
                    }, true);
                    expose(scope);
                    handlers = Base.each(handlers, function(key) {
                        if (new RegExp("\\s+" + key + "\\b").test(code)) {
                            params.push(key);
                            this.push(key + ": " + key);
                        }
                    }, []).join(", ");
                    if (handlers) code += "\nreturn { " + handlers + " };";
                    var browser = paper.browser;
                    if (browser.chrome || browser.firefox) {
                        var script = document.createElement("script"), head = document.head || document.getElementsByTagName("head")[0];
                        if (browser.firefox) code = "\n" + code;
                        script.appendChild(document.createTextNode("paper._execute = function(" + params + ") {" + code + "\n}"));
                        head.appendChild(script);
                        func = paper._execute;
                        delete paper._execute;
                        head.removeChild(script);
                    } else {
                        func = Function(params, code);
                    }
                    var res = func.apply(scope, args) || {};
                    Base.each(toolHandlers, function(key) {
                        var value = res[key];
                        if (value) tool[key] = value;
                    });
                    if (view) {
                        if (res.onResize) view.setOnResize(res.onResize);
                        view.emit("resize", {
                            size: view.size,
                            delta: new Point()
                        });
                        if (res.onFrame) view.setOnFrame(res.onFrame);
                        view.update();
                    }
                }
                function loadScript(script) {
                    if (/^text\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, "ignore") !== "true") {
                        var canvasId = PaperScope.getAttribute(script, "canvas"), canvas = document.getElementById(canvasId), src = script.src, async = PaperScope.hasAttribute(script, "asyc"), scopeAttribute = "data-paper-scope";
                        if (!canvas) throw new Error('Unable to find canvas with id "' + canvasId + '"');
                        var scope = PaperScope.get(canvas.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas);
                        canvas.setAttribute(scopeAttribute, scope._id);
                        if (src) {
                            Http.request("get", src, function(code) {
                                execute(code, scope, src);
                            }, async);
                        } else {
                            execute(script.innerHTML, scope, script.baseURI);
                        }
                        script.setAttribute("data-paper-ignore", "true");
                        return scope;
                    }
                }
                function loadAll() {
                    Base.each(document.getElementsByTagName("script"), loadScript);
                }
                function load(script) {
                    return script ? loadScript(script) : loadAll();
                }
                if (document.readyState === "complete") {
                    setTimeout(loadAll);
                } else {
                    DomEvent.add(window, {
                        load: loadAll
                    });
                }
                return {
                    compile: compile,
                    execute: execute,
                    load: load,
                    parse: parse
                };
            }.call(this);
            paper = new (PaperScope.inject(Base.exports, {
                enumerable: true,
                Base: Base,
                Numerical: Numerical,
                Key: Key
            }))();
            if (typeof define === "function" && define.amd) {
                define("paper", paper);
            } else if (typeof module === "object" && module) {
                module.exports = paper;
            }
            return paper;
        }();
    }, {} ],
    158: [ function(require, module, exports) {
        module.exports = require("./lib/draggable");
    }, {
        "./lib/draggable": 159
    } ],
    159: [ function(require, module, exports) {
        "use strict";
        var React = require("react");
        var emptyFunction = function() {};
        var assign = require("object-assign");
        var classNames = require("classnames");
        function createUIEvent(draggable) {
            var state = draggable._pendingState || draggable.state;
            return {
                node: draggable.getDOMNode(),
                position: {
                    top: state.clientY,
                    left: state.clientX
                }
            };
        }
        function canDragY(draggable) {
            return draggable.props.axis === "both" || draggable.props.axis === "y";
        }
        function canDragX(draggable) {
            return draggable.props.axis === "both" || draggable.props.axis === "x";
        }
        function isFunction(func) {
            return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
        }
        function findInArray(array, callback) {
            for (var i = 0, length = array.length; i < length; i++) {
                if (callback.apply(callback, [ array[i], i, array ])) return array[i];
            }
        }
        function matchesSelector(el, selector) {
            var method = findInArray([ "matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector" ], function(method) {
                return isFunction(el[method]);
            });
            return el[method].call(el, selector);
        }
        var eventsFor = {
            touch: {
                start: "touchstart",
                move: "touchmove",
                end: "touchend"
            },
            mouse: {
                start: "mousedown",
                move: "mousemove",
                end: "mouseup"
            }
        };
        var dragEventFor = eventsFor["mouse"];
        function getControlPosition(e) {
            var position = e.touches && e.touches[0] || e;
            return {
                clientX: position.clientX,
                clientY: position.clientY
            };
        }
        function addEvent(el, event, handler) {
            if (!el) {
                return;
            }
            if (el.attachEvent) {
                el.attachEvent("on" + event, handler);
            } else if (el.addEventListener) {
                el.addEventListener(event, handler, true);
            } else {
                el["on" + event] = handler;
            }
        }
        function removeEvent(el, event, handler) {
            if (!el) {
                return;
            }
            if (el.detachEvent) {
                el.detachEvent("on" + event, handler);
            } else if (el.removeEventListener) {
                el.removeEventListener(event, handler, true);
            } else {
                el["on" + event] = null;
            }
        }
        function outerHeight(node) {
            var height = node.clientHeight;
            var computedStyle = window.getComputedStyle(node);
            height += int(computedStyle.borderTopWidth);
            height += int(computedStyle.borderBottomWidth);
            return height;
        }
        function outerWidth(node) {
            var width = node.clientWidth;
            var computedStyle = window.getComputedStyle(node);
            width += int(computedStyle.borderLeftWidth);
            width += int(computedStyle.borderRightWidth);
            return width;
        }
        function innerHeight(node) {
            var height = node.clientHeight;
            var computedStyle = window.getComputedStyle(node);
            height -= int(computedStyle.paddingTop);
            height -= int(computedStyle.paddingBottom);
            return height;
        }
        function innerWidth(node) {
            var width = node.clientWidth;
            var computedStyle = window.getComputedStyle(node);
            width -= int(computedStyle.paddingLeft);
            width -= int(computedStyle.paddingRight);
            return width;
        }
        function isNum(num) {
            return typeof num === "number" && !isNaN(num);
        }
        function int(a) {
            return parseInt(a, 10);
        }
        function getBoundPosition(draggable, clientX, clientY) {
            var bounds = JSON.parse(JSON.stringify(draggable.props.bounds));
            var node = draggable.getDOMNode();
            var parent = node.parentNode;
            if (bounds === "parent") {
                var nodeStyle = window.getComputedStyle(node);
                var parentStyle = window.getComputedStyle(parent);
                bounds = {
                    left: -node.offsetLeft + int(parentStyle.paddingLeft) + int(nodeStyle.borderLeftWidth) + int(nodeStyle.marginLeft),
                    top: -node.offsetTop + int(parentStyle.paddingTop) + int(nodeStyle.borderTopWidth) + int(nodeStyle.marginTop),
                    right: innerWidth(parent) - outerWidth(node) - node.offsetLeft,
                    bottom: innerHeight(parent) - outerHeight(node) - node.offsetTop
                };
            }
            if (isNum(bounds.right)) clientX = Math.min(clientX, bounds.right);
            if (isNum(bounds.bottom)) clientY = Math.min(clientY, bounds.bottom);
            if (isNum(bounds.left)) clientX = Math.max(clientX, bounds.left);
            if (isNum(bounds.top)) clientY = Math.max(clientY, bounds.top);
            return [ clientX, clientY ];
        }
        function snapToGrid(grid, pendingX, pendingY) {
            var x = Math.round(pendingX / grid[0]) * grid[0];
            var y = Math.round(pendingY / grid[1]) * grid[1];
            return [ x, y ];
        }
        var userSelectStyle = ";user-select: none;-webkit-user-select:none;-moz-user-select:none;" + "-o-user-select:none;-ms-user-select:none;";
        function addUserSelectStyles(draggable) {
            if (!draggable.props.enableUserSelectHack) return;
            var style = document.body.getAttribute("style") || "";
            document.body.setAttribute("style", style + userSelectStyle);
        }
        function removeUserSelectStyles(draggable) {
            if (!draggable.props.enableUserSelectHack) return;
            var style = document.body.getAttribute("style") || "";
            document.body.setAttribute("style", style.replace(userSelectStyle, ""));
        }
        function createCSSTransform(style) {
            var x = style.x + "px";
            var y = style.y + "px";
            return {
                transform: "translate(" + x + "," + y + ")",
                WebkitTransform: "translate(" + x + "," + y + ")",
                OTransform: "translate(" + x + "," + y + ")",
                msTransform: "translate(" + x + "," + y + ")",
                MozTransform: "translate(" + x + "," + y + ")"
            };
        }
        module.exports = React.createClass({
            displayName: "Draggable",
            propTypes: {
                axis: React.PropTypes.oneOf([ "both", "x", "y" ]),
                bounds: React.PropTypes.oneOfType([ React.PropTypes.shape({
                    left: React.PropTypes.Number,
                    right: React.PropTypes.Number,
                    top: React.PropTypes.Number,
                    bottom: React.PropTypes.Number
                }), React.PropTypes.oneOf([ "parent", false ]) ]),
                enableUserSelectHack: React.PropTypes.bool,
                handle: React.PropTypes.string,
                cancel: React.PropTypes.string,
                grid: React.PropTypes.arrayOf(React.PropTypes.number),
                start: React.PropTypes.shape({
                    x: React.PropTypes.number,
                    y: React.PropTypes.number
                }),
                moveOnStartChange: React.PropTypes.bool,
                zIndex: React.PropTypes.number,
                onStart: React.PropTypes.func,
                onDrag: React.PropTypes.func,
                onStop: React.PropTypes.func,
                onMouseDown: React.PropTypes.func
            },
            componentWillReceiveProps: function(newProps) {
                if (newProps.moveOnStartChange && newProps.start) {
                    this.setState(this.getInitialState(newProps));
                }
            },
            componentWillUnmount: function() {
                removeEvent(document, dragEventFor["move"], this.handleDrag);
                removeEvent(document, dragEventFor["end"], this.handleDragEnd);
                removeUserSelectStyles(this);
            },
            getDefaultProps: function() {
                return {
                    axis: "both",
                    bounds: false,
                    handle: null,
                    cancel: null,
                    grid: null,
                    moveOnStartChange: false,
                    start: {
                        x: 0,
                        y: 0
                    },
                    zIndex: NaN,
                    enableUserSelectHack: true,
                    onStart: emptyFunction,
                    onDrag: emptyFunction,
                    onStop: emptyFunction,
                    onMouseDown: emptyFunction
                };
            },
            getInitialState: function(props) {
                props = props || this.props;
                return {
                    dragging: false,
                    offsetX: 0,
                    offsetY: 0,
                    clientX: props.start.x,
                    clientY: props.start.y
                };
            },
            handleDragStart: function(e) {
                this.props.onMouseDown(e);
                if (this.props.handle && !matchesSelector(e.target, this.props.handle) || this.props.cancel && matchesSelector(e.target, this.props.cancel)) {
                    return;
                }
                var shouldStart = this.props.onStart(e, createUIEvent(this));
                if (shouldStart === false) return;
                var dragPoint = getControlPosition(e);
                addUserSelectStyles(this);
                this.setState({
                    dragging: true,
                    offsetX: dragPoint.clientX - this.state.clientX,
                    offsetY: dragPoint.clientY - this.state.clientY
                });
                addEvent(document, dragEventFor["move"], this.handleDrag);
                addEvent(document, dragEventFor["end"], this.handleDragEnd);
            },
            handleDragEnd: function(e) {
                if (!this.state.dragging) {
                    return;
                }
                removeUserSelectStyles(this);
                this.setState({
                    dragging: false
                });
                this.props.onStop(e, createUIEvent(this));
                removeEvent(document, dragEventFor["move"], this.handleDrag);
                removeEvent(document, dragEventFor["end"], this.handleDragEnd);
            },
            handleDrag: function(e) {
                var dragPoint = getControlPosition(e);
                var clientX = dragPoint.clientX - this.state.offsetX;
                var clientY = dragPoint.clientY - this.state.offsetY;
                if (Array.isArray(this.props.grid)) {
                    var coords = snapToGrid(this.props.grid, clientX, clientY);
                    clientX = coords[0], clientY = coords[1];
                }
                if (this.props.bounds) {
                    var pos = getBoundPosition(this, clientX, clientY);
                    clientX = pos[0], clientY = pos[1];
                }
                var shouldUpdate = this.props.onDrag(e, createUIEvent(this));
                if (shouldUpdate === false) return this.handleDragEnd();
                this.setState({
                    clientX: clientX,
                    clientY: clientY
                });
            },
            onMouseDown: function(ev) {
                if (dragEventFor == eventsFor["touch"]) {
                    return ev.preventDefault();
                }
                return this.handleDragStart.apply(this, arguments);
            },
            onTouchStart: function(ev) {
                dragEventFor = eventsFor["touch"];
                return this.handleDragStart.apply(this, arguments);
            },
            resetState: function() {
                this.setState({
                    offsetX: 0,
                    offsetY: 0,
                    clientX: 0,
                    clientY: 0
                });
            },
            render: function() {
                var childStyle = this.props.children.props.style || {};
                var transform = createCSSTransform({
                    x: canDragX(this) ? this.state.clientX : 0,
                    y: canDragY(this) ? this.state.clientY : 0
                });
                var touchHacks = {
                    touchAction: "none"
                };
                var style = assign({}, childStyle, transform, touchHacks);
                if (this.state.dragging && !isNaN(this.props.zIndex)) {
                    style.zIndex = this.props.zIndex;
                }
                var className = classNames(this.props.children.props.className || "", "react-draggable", {
                    "react-draggable-dragging": this.state.dragging,
                    "react-draggable-dragged": this.state.dragged
                });
                return React.cloneElement(React.Children.only(this.props.children), {
                    style: style,
                    className: className,
                    onMouseDown: this.onMouseDown,
                    onTouchStart: this.onTouchStart,
                    onMouseUp: this.handleDragEnd,
                    onTouchEnd: this.handleDragEnd
                });
            }
        });
    }, {
        classnames: 160,
        "object-assign": 161,
        react: 316
    } ],
    160: [ function(require, module, exports) {
        function classNames() {
            var classes = "";
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = arguments[i];
                if (!arg) {
                    continue;
                }
                if ("string" === typeof arg || "number" === typeof arg) {
                    classes += " " + arg;
                } else if (Object.prototype.toString.call(arg) === "[object Array]") {
                    classes += " " + classNames.apply(null, arg);
                } else if ("object" === typeof arg) {
                    for (var key in arg) {
                        if (!arg.hasOwnProperty(key) || !arg[key]) {
                            continue;
                        }
                        classes += " " + key;
                    }
                }
            }
            return classes.substr(1);
        }
        if (typeof module !== "undefined" && module.exports) {
            module.exports = classNames;
        }
        if (typeof define !== "undefined" && define.amd) {
            define("classnames", [], function() {
                return classNames;
            });
        }
    }, {} ],
    161: [ function(require, module, exports) {
        "use strict";
        function ToObject(val) {
            if (val == null) {
                throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
        }
        module.exports = Object.assign || function(target, source) {
            var from;
            var keys;
            var to = ToObject(target);
            for (var s = 1; s < arguments.length; s++) {
                from = arguments[s];
                keys = Object.keys(Object(from));
                for (var i = 0; i < keys.length; i++) {
                    to[keys[i]] = from[keys[i]];
                }
            }
            return to;
        };
    }, {} ],
    162: [ function(require, module, exports) {
        arguments[4][1][0].apply(exports, arguments);
    }, {
        "./focusNode": 280,
        dup: 1
    } ],
    163: [ function(require, module, exports) {
        arguments[4][2][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./EventPropagators": 180,
        "./ExecutionEnvironment": 181,
        "./FallbackCompositionState": 182,
        "./SyntheticCompositionEvent": 254,
        "./SyntheticInputEvent": 258,
        "./keyOf": 302,
        dup: 2
    } ],
    164: [ function(require, module, exports) {
        arguments[4][3][0].apply(exports, arguments);
    }, {
        dup: 3
    } ],
    165: [ function(require, module, exports) {
        arguments[4][4][0].apply(exports, arguments);
    }, {
        "./CSSProperty": 164,
        "./ExecutionEnvironment": 181,
        "./camelizeStyleName": 269,
        "./dangerousStyleValue": 274,
        "./hyphenateStyleName": 294,
        "./memoizeStringOnly": 304,
        "./warning": 315,
        _process: 156,
        dup: 4
    } ],
    166: [ function(require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./invariant": 296,
        _process: 156,
        dup: 5
    } ],
    167: [ function(require, module, exports) {
        arguments[4][6][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./EventPluginHub": 177,
        "./EventPropagators": 180,
        "./ExecutionEnvironment": 181,
        "./ReactUpdates": 248,
        "./SyntheticEvent": 256,
        "./isEventSupported": 297,
        "./isTextInputElement": 299,
        "./keyOf": 302,
        dup: 6
    } ],
    168: [ function(require, module, exports) {
        arguments[4][7][0].apply(exports, arguments);
    }, {
        dup: 7
    } ],
    169: [ function(require, module, exports) {
        arguments[4][8][0].apply(exports, arguments);
    }, {
        "./Danger": 172,
        "./ReactMultiChildUpdateTypes": 233,
        "./invariant": 296,
        "./setTextContent": 310,
        _process: 156,
        dup: 8
    } ],
    170: [ function(require, module, exports) {
        arguments[4][9][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 9
    } ],
    171: [ function(require, module, exports) {
        arguments[4][10][0].apply(exports, arguments);
    }, {
        "./DOMProperty": 170,
        "./quoteAttributeValueForBrowser": 308,
        "./warning": 315,
        _process: 156,
        dup: 10
    } ],
    172: [ function(require, module, exports) {
        arguments[4][11][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        "./createNodesFromMarkup": 273,
        "./emptyFunction": 275,
        "./getMarkupWrap": 288,
        "./invariant": 296,
        _process: 156,
        dup: 11
    } ],
    173: [ function(require, module, exports) {
        arguments[4][12][0].apply(exports, arguments);
    }, {
        "./keyOf": 302,
        dup: 12
    } ],
    174: [ function(require, module, exports) {
        arguments[4][13][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./EventPropagators": 180,
        "./ReactMount": 231,
        "./SyntheticMouseEvent": 260,
        "./keyOf": 302,
        dup: 13
    } ],
    175: [ function(require, module, exports) {
        arguments[4][14][0].apply(exports, arguments);
    }, {
        "./keyMirror": 301,
        dup: 14
    } ],
    176: [ function(require, module, exports) {
        arguments[4][15][0].apply(exports, arguments);
    }, {
        "./emptyFunction": 275,
        _process: 156,
        dup: 15
    } ],
    177: [ function(require, module, exports) {
        arguments[4][16][0].apply(exports, arguments);
    }, {
        "./EventPluginRegistry": 178,
        "./EventPluginUtils": 179,
        "./accumulateInto": 266,
        "./forEachAccumulated": 281,
        "./invariant": 296,
        _process: 156,
        dup: 16
    } ],
    178: [ function(require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 17
    } ],
    179: [ function(require, module, exports) {
        arguments[4][18][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./invariant": 296,
        _process: 156,
        dup: 18
    } ],
    180: [ function(require, module, exports) {
        arguments[4][19][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./EventPluginHub": 177,
        "./accumulateInto": 266,
        "./forEachAccumulated": 281,
        _process: 156,
        dup: 19
    } ],
    181: [ function(require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
    }, {
        dup: 20
    } ],
    182: [ function(require, module, exports) {
        arguments[4][21][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./getTextContentAccessor": 291,
        dup: 21
    } ],
    183: [ function(require, module, exports) {
        arguments[4][22][0].apply(exports, arguments);
    }, {
        "./DOMProperty": 170,
        "./ExecutionEnvironment": 181,
        dup: 22
    } ],
    184: [ function(require, module, exports) {
        arguments[4][23][0].apply(exports, arguments);
    }, {
        "./ReactPropTypes": 239,
        "./invariant": 296,
        _process: 156,
        dup: 23
    } ],
    185: [ function(require, module, exports) {
        arguments[4][24][0].apply(exports, arguments);
    }, {
        "./ReactBrowserEventEmitter": 191,
        "./accumulateInto": 266,
        "./forEachAccumulated": 281,
        "./invariant": 296,
        _process: 156,
        dup: 24
    } ],
    186: [ function(require, module, exports) {
        arguments[4][25][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./emptyFunction": 275,
        dup: 25
    } ],
    187: [ function(require, module, exports) {
        arguments[4][26][0].apply(exports, arguments);
    }, {
        dup: 26
    } ],
    188: [ function(require, module, exports) {
        arguments[4][27][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 27
    } ],
    189: [ function(require, module, exports) {
        arguments[4][28][0].apply(exports, arguments);
    }, {
        "./EventPluginUtils": 179,
        "./ExecutionEnvironment": 181,
        "./Object.assign": 187,
        "./ReactChildren": 193,
        "./ReactClass": 194,
        "./ReactComponent": 195,
        "./ReactContext": 199,
        "./ReactCurrentOwner": 200,
        "./ReactDOM": 201,
        "./ReactDOMTextComponent": 212,
        "./ReactDefaultInjection": 215,
        "./ReactElement": 218,
        "./ReactElementValidator": 219,
        "./ReactInstanceHandles": 227,
        "./ReactMount": 231,
        "./ReactPerf": 236,
        "./ReactPropTypes": 239,
        "./ReactReconciler": 242,
        "./ReactServerRendering": 245,
        "./findDOMNode": 278,
        "./onlyChild": 305,
        _process: 156,
        dup: 28
    } ],
    190: [ function(require, module, exports) {
        arguments[4][29][0].apply(exports, arguments);
    }, {
        "./findDOMNode": 278,
        dup: 29
    } ],
    191: [ function(require, module, exports) {
        arguments[4][30][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./EventPluginHub": 177,
        "./EventPluginRegistry": 178,
        "./Object.assign": 187,
        "./ReactEventEmitterMixin": 222,
        "./ViewportMetrics": 265,
        "./isEventSupported": 297,
        dup: 30
    } ],
    192: [ function(require, module, exports) {
        arguments[4][31][0].apply(exports, arguments);
    }, {
        "./ReactReconciler": 242,
        "./flattenChildren": 279,
        "./instantiateReactComponent": 295,
        "./shouldUpdateReactComponent": 312,
        dup: 31
    } ],
    193: [ function(require, module, exports) {
        arguments[4][32][0].apply(exports, arguments);
    }, {
        "./PooledClass": 188,
        "./ReactFragment": 224,
        "./traverseAllChildren": 314,
        "./warning": 315,
        _process: 156,
        dup: 32
    } ],
    194: [ function(require, module, exports) {
        arguments[4][33][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./ReactComponent": 195,
        "./ReactCurrentOwner": 200,
        "./ReactElement": 218,
        "./ReactErrorUtils": 221,
        "./ReactInstanceMap": 228,
        "./ReactLifeCycle": 229,
        "./ReactPropTypeLocationNames": 237,
        "./ReactPropTypeLocations": 238,
        "./ReactUpdateQueue": 247,
        "./invariant": 296,
        "./keyMirror": 301,
        "./keyOf": 302,
        "./warning": 315,
        _process: 156,
        dup: 33
    } ],
    195: [ function(require, module, exports) {
        arguments[4][34][0].apply(exports, arguments);
    }, {
        "./ReactUpdateQueue": 247,
        "./invariant": 296,
        "./warning": 315,
        _process: 156,
        dup: 34
    } ],
    196: [ function(require, module, exports) {
        arguments[4][35][0].apply(exports, arguments);
    }, {
        "./ReactDOMIDOperations": 205,
        "./ReactMount": 231,
        dup: 35
    } ],
    197: [ function(require, module, exports) {
        arguments[4][36][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 36
    } ],
    198: [ function(require, module, exports) {
        arguments[4][37][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./ReactComponentEnvironment": 197,
        "./ReactContext": 199,
        "./ReactCurrentOwner": 200,
        "./ReactElement": 218,
        "./ReactElementValidator": 219,
        "./ReactInstanceMap": 228,
        "./ReactLifeCycle": 229,
        "./ReactNativeComponent": 234,
        "./ReactPerf": 236,
        "./ReactPropTypeLocationNames": 237,
        "./ReactPropTypeLocations": 238,
        "./ReactReconciler": 242,
        "./ReactUpdates": 248,
        "./emptyObject": 276,
        "./invariant": 296,
        "./shouldUpdateReactComponent": 312,
        "./warning": 315,
        _process: 156,
        dup: 37
    } ],
    199: [ function(require, module, exports) {
        arguments[4][38][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./emptyObject": 276,
        "./warning": 315,
        _process: 156,
        dup: 38
    } ],
    200: [ function(require, module, exports) {
        arguments[4][39][0].apply(exports, arguments);
    }, {
        dup: 39
    } ],
    201: [ function(require, module, exports) {
        arguments[4][40][0].apply(exports, arguments);
    }, {
        "./ReactElement": 218,
        "./ReactElementValidator": 219,
        "./mapObject": 303,
        _process: 156,
        dup: 40
    } ],
    202: [ function(require, module, exports) {
        arguments[4][41][0].apply(exports, arguments);
    }, {
        "./AutoFocusMixin": 162,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        "./keyMirror": 301,
        dup: 41
    } ],
    203: [ function(require, module, exports) {
        arguments[4][42][0].apply(exports, arguments);
    }, {
        "./CSSPropertyOperations": 165,
        "./DOMProperty": 170,
        "./DOMPropertyOperations": 171,
        "./Object.assign": 187,
        "./ReactBrowserEventEmitter": 191,
        "./ReactComponentBrowserEnvironment": 196,
        "./ReactMount": 231,
        "./ReactMultiChild": 232,
        "./ReactPerf": 236,
        "./escapeTextContentForBrowser": 277,
        "./invariant": 296,
        "./isEventSupported": 297,
        "./keyOf": 302,
        "./warning": 315,
        _process: 156,
        dup: 42
    } ],
    204: [ function(require, module, exports) {
        arguments[4][43][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./LocalEventTrapMixin": 185,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        dup: 43
    } ],
    205: [ function(require, module, exports) {
        arguments[4][44][0].apply(exports, arguments);
    }, {
        "./CSSPropertyOperations": 165,
        "./DOMChildrenOperations": 169,
        "./DOMPropertyOperations": 171,
        "./ReactMount": 231,
        "./ReactPerf": 236,
        "./invariant": 296,
        "./setInnerHTML": 309,
        _process: 156,
        dup: 44
    } ],
    206: [ function(require, module, exports) {
        arguments[4][45][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./LocalEventTrapMixin": 185,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        dup: 45
    } ],
    207: [ function(require, module, exports) {
        arguments[4][46][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./LocalEventTrapMixin": 185,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        dup: 46
    } ],
    208: [ function(require, module, exports) {
        arguments[4][47][0].apply(exports, arguments);
    }, {
        "./AutoFocusMixin": 162,
        "./DOMPropertyOperations": 171,
        "./LinkedValueUtils": 184,
        "./Object.assign": 187,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        "./ReactMount": 231,
        "./ReactUpdates": 248,
        "./invariant": 296,
        _process: 156,
        dup: 47
    } ],
    209: [ function(require, module, exports) {
        arguments[4][48][0].apply(exports, arguments);
    }, {
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        "./warning": 315,
        _process: 156,
        dup: 48
    } ],
    210: [ function(require, module, exports) {
        arguments[4][49][0].apply(exports, arguments);
    }, {
        "./AutoFocusMixin": 162,
        "./LinkedValueUtils": 184,
        "./Object.assign": 187,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        "./ReactUpdates": 248,
        dup: 49
    } ],
    211: [ function(require, module, exports) {
        arguments[4][50][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        "./getNodeForCharacterOffset": 289,
        "./getTextContentAccessor": 291,
        dup: 50
    } ],
    212: [ function(require, module, exports) {
        arguments[4][51][0].apply(exports, arguments);
    }, {
        "./DOMPropertyOperations": 171,
        "./Object.assign": 187,
        "./ReactComponentBrowserEnvironment": 196,
        "./ReactDOMComponent": 203,
        "./escapeTextContentForBrowser": 277,
        dup: 51
    } ],
    213: [ function(require, module, exports) {
        arguments[4][52][0].apply(exports, arguments);
    }, {
        "./AutoFocusMixin": 162,
        "./DOMPropertyOperations": 171,
        "./LinkedValueUtils": 184,
        "./Object.assign": 187,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactElement": 218,
        "./ReactUpdates": 248,
        "./invariant": 296,
        "./warning": 315,
        _process: 156,
        dup: 52
    } ],
    214: [ function(require, module, exports) {
        arguments[4][53][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./ReactUpdates": 248,
        "./Transaction": 264,
        "./emptyFunction": 275,
        dup: 53
    } ],
    215: [ function(require, module, exports) {
        arguments[4][54][0].apply(exports, arguments);
    }, {
        "./BeforeInputEventPlugin": 163,
        "./ChangeEventPlugin": 167,
        "./ClientReactRootIndex": 168,
        "./DefaultEventPluginOrder": 173,
        "./EnterLeaveEventPlugin": 174,
        "./ExecutionEnvironment": 181,
        "./HTMLDOMPropertyConfig": 183,
        "./MobileSafariClickEventPlugin": 186,
        "./ReactBrowserComponentMixin": 190,
        "./ReactClass": 194,
        "./ReactComponentBrowserEnvironment": 196,
        "./ReactDOMButton": 202,
        "./ReactDOMComponent": 203,
        "./ReactDOMForm": 204,
        "./ReactDOMIDOperations": 205,
        "./ReactDOMIframe": 206,
        "./ReactDOMImg": 207,
        "./ReactDOMInput": 208,
        "./ReactDOMOption": 209,
        "./ReactDOMSelect": 210,
        "./ReactDOMTextComponent": 212,
        "./ReactDOMTextarea": 213,
        "./ReactDefaultBatchingStrategy": 214,
        "./ReactDefaultPerf": 216,
        "./ReactElement": 218,
        "./ReactEventListener": 223,
        "./ReactInjection": 225,
        "./ReactInstanceHandles": 227,
        "./ReactMount": 231,
        "./ReactReconcileTransaction": 241,
        "./SVGDOMPropertyConfig": 249,
        "./SelectEventPlugin": 250,
        "./ServerReactRootIndex": 251,
        "./SimpleEventPlugin": 252,
        "./createFullPageComponent": 272,
        _process: 156,
        dup: 54
    } ],
    216: [ function(require, module, exports) {
        arguments[4][55][0].apply(exports, arguments);
    }, {
        "./DOMProperty": 170,
        "./ReactDefaultPerfAnalysis": 217,
        "./ReactMount": 231,
        "./ReactPerf": 236,
        "./performanceNow": 307,
        dup: 55
    } ],
    217: [ function(require, module, exports) {
        arguments[4][56][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        dup: 56
    } ],
    218: [ function(require, module, exports) {
        arguments[4][57][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./ReactContext": 199,
        "./ReactCurrentOwner": 200,
        "./warning": 315,
        _process: 156,
        dup: 57
    } ],
    219: [ function(require, module, exports) {
        arguments[4][58][0].apply(exports, arguments);
    }, {
        "./ReactCurrentOwner": 200,
        "./ReactElement": 218,
        "./ReactFragment": 224,
        "./ReactNativeComponent": 234,
        "./ReactPropTypeLocationNames": 237,
        "./ReactPropTypeLocations": 238,
        "./getIteratorFn": 287,
        "./invariant": 296,
        "./warning": 315,
        _process: 156,
        dup: 58
    } ],
    220: [ function(require, module, exports) {
        arguments[4][59][0].apply(exports, arguments);
    }, {
        "./ReactElement": 218,
        "./ReactInstanceMap": 228,
        "./invariant": 296,
        _process: 156,
        dup: 59
    } ],
    221: [ function(require, module, exports) {
        arguments[4][60][0].apply(exports, arguments);
    }, {
        dup: 60
    } ],
    222: [ function(require, module, exports) {
        arguments[4][61][0].apply(exports, arguments);
    }, {
        "./EventPluginHub": 177,
        dup: 61
    } ],
    223: [ function(require, module, exports) {
        arguments[4][62][0].apply(exports, arguments);
    }, {
        "./EventListener": 176,
        "./ExecutionEnvironment": 181,
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./ReactInstanceHandles": 227,
        "./ReactMount": 231,
        "./ReactUpdates": 248,
        "./getEventTarget": 286,
        "./getUnboundedScrollPosition": 292,
        dup: 62
    } ],
    224: [ function(require, module, exports) {
        arguments[4][63][0].apply(exports, arguments);
    }, {
        "./ReactElement": 218,
        "./warning": 315,
        _process: 156,
        dup: 63
    } ],
    225: [ function(require, module, exports) {
        arguments[4][64][0].apply(exports, arguments);
    }, {
        "./DOMProperty": 170,
        "./EventPluginHub": 177,
        "./ReactBrowserEventEmitter": 191,
        "./ReactClass": 194,
        "./ReactComponentEnvironment": 197,
        "./ReactDOMComponent": 203,
        "./ReactEmptyComponent": 220,
        "./ReactNativeComponent": 234,
        "./ReactPerf": 236,
        "./ReactRootIndex": 244,
        "./ReactUpdates": 248,
        dup: 64
    } ],
    226: [ function(require, module, exports) {
        arguments[4][65][0].apply(exports, arguments);
    }, {
        "./ReactDOMSelection": 211,
        "./containsNode": 270,
        "./focusNode": 280,
        "./getActiveElement": 282,
        dup: 65
    } ],
    227: [ function(require, module, exports) {
        arguments[4][66][0].apply(exports, arguments);
    }, {
        "./ReactRootIndex": 244,
        "./invariant": 296,
        _process: 156,
        dup: 66
    } ],
    228: [ function(require, module, exports) {
        arguments[4][67][0].apply(exports, arguments);
    }, {
        dup: 67
    } ],
    229: [ function(require, module, exports) {
        arguments[4][68][0].apply(exports, arguments);
    }, {
        dup: 68
    } ],
    230: [ function(require, module, exports) {
        arguments[4][69][0].apply(exports, arguments);
    }, {
        "./adler32": 267,
        dup: 69
    } ],
    231: [ function(require, module, exports) {
        arguments[4][70][0].apply(exports, arguments);
    }, {
        "./DOMProperty": 170,
        "./ReactBrowserEventEmitter": 191,
        "./ReactCurrentOwner": 200,
        "./ReactElement": 218,
        "./ReactElementValidator": 219,
        "./ReactEmptyComponent": 220,
        "./ReactInstanceHandles": 227,
        "./ReactInstanceMap": 228,
        "./ReactMarkupChecksum": 230,
        "./ReactPerf": 236,
        "./ReactReconciler": 242,
        "./ReactUpdateQueue": 247,
        "./ReactUpdates": 248,
        "./containsNode": 270,
        "./emptyObject": 276,
        "./getReactRootElementInContainer": 290,
        "./instantiateReactComponent": 295,
        "./invariant": 296,
        "./setInnerHTML": 309,
        "./shouldUpdateReactComponent": 312,
        "./warning": 315,
        _process: 156,
        dup: 70
    } ],
    232: [ function(require, module, exports) {
        arguments[4][71][0].apply(exports, arguments);
    }, {
        "./ReactChildReconciler": 192,
        "./ReactComponentEnvironment": 197,
        "./ReactMultiChildUpdateTypes": 233,
        "./ReactReconciler": 242,
        dup: 71
    } ],
    233: [ function(require, module, exports) {
        arguments[4][72][0].apply(exports, arguments);
    }, {
        "./keyMirror": 301,
        dup: 72
    } ],
    234: [ function(require, module, exports) {
        arguments[4][73][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./invariant": 296,
        _process: 156,
        dup: 73
    } ],
    235: [ function(require, module, exports) {
        arguments[4][74][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 74
    } ],
    236: [ function(require, module, exports) {
        arguments[4][75][0].apply(exports, arguments);
    }, {
        _process: 156,
        dup: 75
    } ],
    237: [ function(require, module, exports) {
        arguments[4][76][0].apply(exports, arguments);
    }, {
        _process: 156,
        dup: 76
    } ],
    238: [ function(require, module, exports) {
        arguments[4][77][0].apply(exports, arguments);
    }, {
        "./keyMirror": 301,
        dup: 77
    } ],
    239: [ function(require, module, exports) {
        arguments[4][78][0].apply(exports, arguments);
    }, {
        "./ReactElement": 218,
        "./ReactFragment": 224,
        "./ReactPropTypeLocationNames": 237,
        "./emptyFunction": 275,
        dup: 78
    } ],
    240: [ function(require, module, exports) {
        arguments[4][79][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./ReactBrowserEventEmitter": 191,
        dup: 79
    } ],
    241: [ function(require, module, exports) {
        arguments[4][80][0].apply(exports, arguments);
    }, {
        "./CallbackQueue": 166,
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./ReactBrowserEventEmitter": 191,
        "./ReactInputSelection": 226,
        "./ReactPutListenerQueue": 240,
        "./Transaction": 264,
        dup: 80
    } ],
    242: [ function(require, module, exports) {
        arguments[4][81][0].apply(exports, arguments);
    }, {
        "./ReactElementValidator": 219,
        "./ReactRef": 243,
        _process: 156,
        dup: 81
    } ],
    243: [ function(require, module, exports) {
        arguments[4][82][0].apply(exports, arguments);
    }, {
        "./ReactOwner": 235,
        dup: 82
    } ],
    244: [ function(require, module, exports) {
        arguments[4][83][0].apply(exports, arguments);
    }, {
        dup: 83
    } ],
    245: [ function(require, module, exports) {
        arguments[4][84][0].apply(exports, arguments);
    }, {
        "./ReactElement": 218,
        "./ReactInstanceHandles": 227,
        "./ReactMarkupChecksum": 230,
        "./ReactServerRenderingTransaction": 246,
        "./emptyObject": 276,
        "./instantiateReactComponent": 295,
        "./invariant": 296,
        _process: 156,
        dup: 84
    } ],
    246: [ function(require, module, exports) {
        arguments[4][85][0].apply(exports, arguments);
    }, {
        "./CallbackQueue": 166,
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./ReactPutListenerQueue": 240,
        "./Transaction": 264,
        "./emptyFunction": 275,
        dup: 85
    } ],
    247: [ function(require, module, exports) {
        arguments[4][86][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./ReactCurrentOwner": 200,
        "./ReactElement": 218,
        "./ReactInstanceMap": 228,
        "./ReactLifeCycle": 229,
        "./ReactUpdates": 248,
        "./invariant": 296,
        "./warning": 315,
        _process: 156,
        dup: 86
    } ],
    248: [ function(require, module, exports) {
        arguments[4][87][0].apply(exports, arguments);
    }, {
        "./CallbackQueue": 166,
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./ReactCurrentOwner": 200,
        "./ReactPerf": 236,
        "./ReactReconciler": 242,
        "./Transaction": 264,
        "./invariant": 296,
        "./warning": 315,
        _process: 156,
        dup: 87
    } ],
    249: [ function(require, module, exports) {
        arguments[4][88][0].apply(exports, arguments);
    }, {
        "./DOMProperty": 170,
        dup: 88
    } ],
    250: [ function(require, module, exports) {
        arguments[4][89][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./EventPropagators": 180,
        "./ReactInputSelection": 226,
        "./SyntheticEvent": 256,
        "./getActiveElement": 282,
        "./isTextInputElement": 299,
        "./keyOf": 302,
        "./shallowEqual": 311,
        dup: 89
    } ],
    251: [ function(require, module, exports) {
        arguments[4][90][0].apply(exports, arguments);
    }, {
        dup: 90
    } ],
    252: [ function(require, module, exports) {
        arguments[4][91][0].apply(exports, arguments);
    }, {
        "./EventConstants": 175,
        "./EventPluginUtils": 179,
        "./EventPropagators": 180,
        "./SyntheticClipboardEvent": 253,
        "./SyntheticDragEvent": 255,
        "./SyntheticEvent": 256,
        "./SyntheticFocusEvent": 257,
        "./SyntheticKeyboardEvent": 259,
        "./SyntheticMouseEvent": 260,
        "./SyntheticTouchEvent": 261,
        "./SyntheticUIEvent": 262,
        "./SyntheticWheelEvent": 263,
        "./getEventCharCode": 283,
        "./invariant": 296,
        "./keyOf": 302,
        "./warning": 315,
        _process: 156,
        dup: 91
    } ],
    253: [ function(require, module, exports) {
        arguments[4][92][0].apply(exports, arguments);
    }, {
        "./SyntheticEvent": 256,
        dup: 92
    } ],
    254: [ function(require, module, exports) {
        arguments[4][93][0].apply(exports, arguments);
    }, {
        "./SyntheticEvent": 256,
        dup: 93
    } ],
    255: [ function(require, module, exports) {
        arguments[4][94][0].apply(exports, arguments);
    }, {
        "./SyntheticMouseEvent": 260,
        dup: 94
    } ],
    256: [ function(require, module, exports) {
        arguments[4][95][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./PooledClass": 188,
        "./emptyFunction": 275,
        "./getEventTarget": 286,
        dup: 95
    } ],
    257: [ function(require, module, exports) {
        arguments[4][96][0].apply(exports, arguments);
    }, {
        "./SyntheticUIEvent": 262,
        dup: 96
    } ],
    258: [ function(require, module, exports) {
        arguments[4][97][0].apply(exports, arguments);
    }, {
        "./SyntheticEvent": 256,
        dup: 97
    } ],
    259: [ function(require, module, exports) {
        arguments[4][98][0].apply(exports, arguments);
    }, {
        "./SyntheticUIEvent": 262,
        "./getEventCharCode": 283,
        "./getEventKey": 284,
        "./getEventModifierState": 285,
        dup: 98
    } ],
    260: [ function(require, module, exports) {
        arguments[4][99][0].apply(exports, arguments);
    }, {
        "./SyntheticUIEvent": 262,
        "./ViewportMetrics": 265,
        "./getEventModifierState": 285,
        dup: 99
    } ],
    261: [ function(require, module, exports) {
        arguments[4][100][0].apply(exports, arguments);
    }, {
        "./SyntheticUIEvent": 262,
        "./getEventModifierState": 285,
        dup: 100
    } ],
    262: [ function(require, module, exports) {
        arguments[4][101][0].apply(exports, arguments);
    }, {
        "./SyntheticEvent": 256,
        "./getEventTarget": 286,
        dup: 101
    } ],
    263: [ function(require, module, exports) {
        arguments[4][102][0].apply(exports, arguments);
    }, {
        "./SyntheticMouseEvent": 260,
        dup: 102
    } ],
    264: [ function(require, module, exports) {
        arguments[4][103][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 103
    } ],
    265: [ function(require, module, exports) {
        arguments[4][104][0].apply(exports, arguments);
    }, {
        dup: 104
    } ],
    266: [ function(require, module, exports) {
        arguments[4][105][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 105
    } ],
    267: [ function(require, module, exports) {
        arguments[4][106][0].apply(exports, arguments);
    }, {
        dup: 106
    } ],
    268: [ function(require, module, exports) {
        arguments[4][107][0].apply(exports, arguments);
    }, {
        dup: 107
    } ],
    269: [ function(require, module, exports) {
        arguments[4][108][0].apply(exports, arguments);
    }, {
        "./camelize": 268,
        dup: 108
    } ],
    270: [ function(require, module, exports) {
        arguments[4][109][0].apply(exports, arguments);
    }, {
        "./isTextNode": 300,
        dup: 109
    } ],
    271: [ function(require, module, exports) {
        arguments[4][110][0].apply(exports, arguments);
    }, {
        "./toArray": 313,
        dup: 110
    } ],
    272: [ function(require, module, exports) {
        arguments[4][111][0].apply(exports, arguments);
    }, {
        "./ReactClass": 194,
        "./ReactElement": 218,
        "./invariant": 296,
        _process: 156,
        dup: 111
    } ],
    273: [ function(require, module, exports) {
        arguments[4][112][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        "./createArrayFromMixed": 271,
        "./getMarkupWrap": 288,
        "./invariant": 296,
        _process: 156,
        dup: 112
    } ],
    274: [ function(require, module, exports) {
        arguments[4][113][0].apply(exports, arguments);
    }, {
        "./CSSProperty": 164,
        dup: 113
    } ],
    275: [ function(require, module, exports) {
        arguments[4][114][0].apply(exports, arguments);
    }, {
        dup: 114
    } ],
    276: [ function(require, module, exports) {
        arguments[4][115][0].apply(exports, arguments);
    }, {
        _process: 156,
        dup: 115
    } ],
    277: [ function(require, module, exports) {
        arguments[4][116][0].apply(exports, arguments);
    }, {
        dup: 116
    } ],
    278: [ function(require, module, exports) {
        arguments[4][117][0].apply(exports, arguments);
    }, {
        "./ReactCurrentOwner": 200,
        "./ReactInstanceMap": 228,
        "./ReactMount": 231,
        "./invariant": 296,
        "./isNode": 298,
        "./warning": 315,
        _process: 156,
        dup: 117
    } ],
    279: [ function(require, module, exports) {
        arguments[4][118][0].apply(exports, arguments);
    }, {
        "./traverseAllChildren": 314,
        "./warning": 315,
        _process: 156,
        dup: 118
    } ],
    280: [ function(require, module, exports) {
        arguments[4][119][0].apply(exports, arguments);
    }, {
        dup: 119
    } ],
    281: [ function(require, module, exports) {
        arguments[4][120][0].apply(exports, arguments);
    }, {
        dup: 120
    } ],
    282: [ function(require, module, exports) {
        arguments[4][121][0].apply(exports, arguments);
    }, {
        dup: 121
    } ],
    283: [ function(require, module, exports) {
        arguments[4][122][0].apply(exports, arguments);
    }, {
        dup: 122
    } ],
    284: [ function(require, module, exports) {
        arguments[4][123][0].apply(exports, arguments);
    }, {
        "./getEventCharCode": 283,
        dup: 123
    } ],
    285: [ function(require, module, exports) {
        arguments[4][124][0].apply(exports, arguments);
    }, {
        dup: 124
    } ],
    286: [ function(require, module, exports) {
        arguments[4][125][0].apply(exports, arguments);
    }, {
        dup: 125
    } ],
    287: [ function(require, module, exports) {
        arguments[4][126][0].apply(exports, arguments);
    }, {
        dup: 126
    } ],
    288: [ function(require, module, exports) {
        arguments[4][127][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        "./invariant": 296,
        _process: 156,
        dup: 127
    } ],
    289: [ function(require, module, exports) {
        arguments[4][128][0].apply(exports, arguments);
    }, {
        dup: 128
    } ],
    290: [ function(require, module, exports) {
        arguments[4][129][0].apply(exports, arguments);
    }, {
        dup: 129
    } ],
    291: [ function(require, module, exports) {
        arguments[4][130][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        dup: 130
    } ],
    292: [ function(require, module, exports) {
        arguments[4][131][0].apply(exports, arguments);
    }, {
        dup: 131
    } ],
    293: [ function(require, module, exports) {
        arguments[4][132][0].apply(exports, arguments);
    }, {
        dup: 132
    } ],
    294: [ function(require, module, exports) {
        arguments[4][133][0].apply(exports, arguments);
    }, {
        "./hyphenate": 293,
        dup: 133
    } ],
    295: [ function(require, module, exports) {
        arguments[4][134][0].apply(exports, arguments);
    }, {
        "./Object.assign": 187,
        "./ReactCompositeComponent": 198,
        "./ReactEmptyComponent": 220,
        "./ReactNativeComponent": 234,
        "./invariant": 296,
        "./warning": 315,
        _process: 156,
        dup: 134
    } ],
    296: [ function(require, module, exports) {
        arguments[4][135][0].apply(exports, arguments);
    }, {
        _process: 156,
        dup: 135
    } ],
    297: [ function(require, module, exports) {
        arguments[4][136][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        dup: 136
    } ],
    298: [ function(require, module, exports) {
        arguments[4][137][0].apply(exports, arguments);
    }, {
        dup: 137
    } ],
    299: [ function(require, module, exports) {
        arguments[4][138][0].apply(exports, arguments);
    }, {
        dup: 138
    } ],
    300: [ function(require, module, exports) {
        arguments[4][139][0].apply(exports, arguments);
    }, {
        "./isNode": 298,
        dup: 139
    } ],
    301: [ function(require, module, exports) {
        arguments[4][140][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 140
    } ],
    302: [ function(require, module, exports) {
        arguments[4][141][0].apply(exports, arguments);
    }, {
        dup: 141
    } ],
    303: [ function(require, module, exports) {
        arguments[4][142][0].apply(exports, arguments);
    }, {
        dup: 142
    } ],
    304: [ function(require, module, exports) {
        arguments[4][143][0].apply(exports, arguments);
    }, {
        dup: 143
    } ],
    305: [ function(require, module, exports) {
        arguments[4][144][0].apply(exports, arguments);
    }, {
        "./ReactElement": 218,
        "./invariant": 296,
        _process: 156,
        dup: 144
    } ],
    306: [ function(require, module, exports) {
        arguments[4][145][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        dup: 145
    } ],
    307: [ function(require, module, exports) {
        arguments[4][146][0].apply(exports, arguments);
    }, {
        "./performance": 306,
        dup: 146
    } ],
    308: [ function(require, module, exports) {
        arguments[4][147][0].apply(exports, arguments);
    }, {
        "./escapeTextContentForBrowser": 277,
        dup: 147
    } ],
    309: [ function(require, module, exports) {
        arguments[4][148][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        dup: 148
    } ],
    310: [ function(require, module, exports) {
        arguments[4][149][0].apply(exports, arguments);
    }, {
        "./ExecutionEnvironment": 181,
        "./escapeTextContentForBrowser": 277,
        "./setInnerHTML": 309,
        dup: 149
    } ],
    311: [ function(require, module, exports) {
        arguments[4][150][0].apply(exports, arguments);
    }, {
        dup: 150
    } ],
    312: [ function(require, module, exports) {
        arguments[4][151][0].apply(exports, arguments);
    }, {
        "./warning": 315,
        _process: 156,
        dup: 151
    } ],
    313: [ function(require, module, exports) {
        arguments[4][152][0].apply(exports, arguments);
    }, {
        "./invariant": 296,
        _process: 156,
        dup: 152
    } ],
    314: [ function(require, module, exports) {
        arguments[4][153][0].apply(exports, arguments);
    }, {
        "./ReactElement": 218,
        "./ReactFragment": 224,
        "./ReactInstanceHandles": 227,
        "./getIteratorFn": 287,
        "./invariant": 296,
        "./warning": 315,
        _process: 156,
        dup: 153
    } ],
    315: [ function(require, module, exports) {
        arguments[4][154][0].apply(exports, arguments);
    }, {
        "./emptyFunction": 275,
        _process: 156,
        dup: 154
    } ],
    316: [ function(require, module, exports) {
        arguments[4][155][0].apply(exports, arguments);
    }, {
        "./lib/React": 189,
        dup: 155
    } ],
    317: [ function(require, module, exports) {
        "use strict";
        var util = require("./global/util");
        var Events = require("./global/Events");
        var WorkSpaceController = require("./workspace/WorkspaceController");
        var CanvasController = require("./canvas/CanvasController");
        var DataController = require("./data/DataController");
        function App() {
            var app = this;
            app.data = new DataController(util.checkLocal("runeData"));
            app.workspace = new WorkSpaceController(app.data);
            app.canvas = new CanvasController(app.data);
            var events = new Events(app);
            events.init();
        }
        App.prototype = {
            constructor: App,
            setup: function() {},
            save: function() {
                this.tablet.save();
            }
        };
        var app = new App();
    }, {
        "./canvas/CanvasController": 318,
        "./data/DataController": 321,
        "./global/Events": 323,
        "./global/util": 325,
        "./workspace/WorkspaceController": 329
    } ],
    318: [ function(require, module, exports) {
        var paper = require("paper");
        var GridView = require("./GridView.js");
        var RuneView = require("./RuneView.js");
        function CanvasController(tabletModel) {
            var canvasController = this;
            canvasController.canvas = document.getElementById("rune-canvas");
            paper.setup(canvasController.canvas).install(window);
            canvasController.gridLayer = new paper.Layer(), canvasController.layers = [];
            canvasController.setupGrid(tabletModel.tablet.gridOptions);
            canvasController.runeViews = [];
            tabletModel.tablet.runes.forEach(function(val, idx) {
                canvasController.layers.push(new paper.Layer());
                canvasController.runeViews.push(new RuneView(val, canvasController.grid));
            });
            canvasController.currentRuneIndex = 0;
            canvasController.redraw();
            canvasController.showGrid = true;
        }
        CanvasController.prototype = {
            constructor: CanvasController,
            draw: function() {
                this.layers[this.currentRuneIndex].removeChildren();
                this.layers[this.currentRuneIndex].activate();
                this.runeViews[this.currentRuneIndex].draw();
                this.redraw();
            },
            setActiveRune: function() {},
            setupGrid: function(gridOptions) {
                this.grid = new GridView(gridOptions);
                this.drawGrid(gridOptions);
            },
            drawGrid: function(gridPoints) {
                this.gridLayer.removeChildren();
                this.gridLayer.activate();
                this.grid.draw();
                this.redraw();
            },
            toggleGrid: function(showGrid) {
                this.showGrid = !this.showGrid;
                this.gridLayer.visible = this.showGrid;
                this.redraw();
            },
            redraw: function() {
                paper.view.draw();
            }
        };
        module.exports = CanvasController;
    }, {
        "./GridView.js": 319,
        "./RuneView.js": 320,
        paper: 157
    } ],
    319: [ function(require, module, exports) {
        var paper = require("paper");
        var util = require("../global/util");
        function GridView(options) {
            this.res = options.res;
            this.units = options.units;
            this.padding = options.padding;
            this.points = [];
            this.gridColor = "orange";
            for (var row = 0; row < this.units; row++) {
                this.points[row] = [];
                for (var col = 0; col < this.units; col++) {
                    var point = [ row, col ];
                    this.points[row].push(point);
                }
                col = 0;
            }
        }
        GridView.prototype = {
            constructor: GridView,
            draw: function() {
                console.log("Drawing grid");
                var grid = this;
                var gridGrid = new paper.Raster();
                gridGrid.setImageData(gridGrid.createImageData(200));
                gridGrid.setPixel(10, 10, "black");
                for (var i = this.res / 2; i < 2e3; i += this.res) {
                    var p1 = new paper.Point(i, 0);
                    var p2 = new paper.Point(i, 2e3);
                    var rec = new paper.Path.Rectangle([ i, 0 ], 1, 2e3);
                    rec.fillColor = grid.gridColor;
                    for (var j = this.res / 2; j < 2e3; j += this.res) {
                        var p1 = new paper.Point(0, i);
                        var p2 = new paper.Point(2e3, i);
                        var rec = new paper.Path.Rectangle([ 0, i ], 2e3, 1);
                        rec.fillColor = grid.gridColor;
                    }
                }
                for (var i = 0, arr; arr = grid.points[i++]; ) {
                    for (var j = 0, point; point = arr[j++]; ) {
                        var paperPoint = new paper.Point(this.renderPoint(point));
                        grid.createGridPoint(paperPoint, point);
                    }
                }
            },
            renderPoint: function(point) {
                return [ point[0] * this.res + this.padding, point[1] * this.res + this.padding ];
            },
            createGridPoint: function(point, value) {
                var path = paper.Path.Circle(point, this.res / 2);
                path.value = value;
                path.active = false;
                var opaque = new paper.Color(255, 0, 0, .2);
                path.fillColor = opaque;
                path.onMouseEnter = function(e) {
                    this.fillColor = "orange";
                };
                path.onMouseLeave = function(e) {
                    this.fillColor = this.active ? "red" : opaque;
                };
                path.onMouseDown = function(e) {
                    this.fillColor = "red";
                    util.dispatchRuneEvent("addPoint", e.target.value);
                };
            }
        };
        module.exports = GridView;
    }, {
        "../global/util": 325,
        paper: 157
    } ],
    320: [ function(require, module, exports) {
        var paper = require("paper");
        var util = require("../global/util");
        function RuneView(runeModel, grid) {
            this.points = [];
            this.runeModel = runeModel;
            console.log(grid);
            this.grid = grid;
        }
        RuneView.prototype = {
            constructor: RuneView,
            draw: function() {
                console.log("Tablet view drawing");
                var rune = this;
                var runePath = new paper.Path();
                runePath.strokeColor = "black";
                rune.runePoints = [];
                rune.runeModel.points.forEach(function(point, idx) {
                    var runePoint = rune.createRunePoint(rune.grid.renderPoint(point), idx, rune.runeModel.selectedPoints.indexOf(idx) > -1, rune.runeModel.transforms[idx] || null);
                    rune.points.push(runePoint);
                    if (idx) {
                        runePath.lineTo(runePoint.point);
                    } else {
                        runePath.moveTo(runePoint.point);
                    }
                });
            },
            createRunePoint: function(point, value, selected, transform) {
                var paperPoint = new paper.Point(point);
                if (transform) {
                    console.log(transform);
                    paperPoint.add(function() {
                        var point = new paper.Point();
                        point.angle = transform[0];
                        point.length = transform[1];
                        return point;
                    }());
                }
                var path = new paper.Path.Rectangle(paperPoint.subtract([ 5, 5 ]), 10);
                path.strokeColor = "red";
                path.fillColor = "white";
                path.value = value;
                path.selected = selected || false;
                path.onMouseEnter = function(e) {};
                path.onMouseLeave = function(e) {};
                path.onMouseDown = function(e) {
                    this.selected = !this.selected;
                    util.dispatchRuneEvent("selectPoint", [ this.selected, e.target.value ]);
                };
                path.onKeyDown = function(e) {
                    console.log(e.key);
                    switch (e.key) {
                      case "delete":
                        console.log("de");
                        break;
                    }
                };
                return {
                    point: paperPoint,
                    path: path
                };
            }
        };
        module.exports = RuneView;
    }, {
        "../global/util": 325,
        paper: 157
    } ],
    321: [ function(require, module, exports) {
        var TabletData = require("./DataModel");
        var util = require("../global/util");
        function DataController(tabletModel) {
            this.tablet = tabletModel || new TabletData(null);
            this.activeRune = this.tablet.runes[0];
        }
        DataController.prototype = {
            constructor: DataController,
            save: function() {
                localStorage["runeData"] = JSON.stringify(app.data);
            },
            setActiveRune: function(i) {
                this.activeRune = this.tablet.runes[i];
            },
            addRune: function() {
                this.tablet.runes.push(new RuneData(null));
            },
            addPoint: function(gridRef) {
                var rune = this.activeRune;
                rune.points.splice(rune.currentIndex, 0, gridRef);
                rune.currentIndex++;
                util.dispatchRuneEvent("deselectAll");
                console.log(this.activeRune);
            },
            clearRune: function() {
                this.activeRune.points = [];
            },
            updateGrid: function() {},
            deleteSelected: function() {
                var rune = this.activeRune;
                rune.points = rune.points.filter(function(entry, idx) {
                    return rune.selectedPoints.indexOf(idx) == -1;
                });
            },
            selectPoint: function(data) {
                console.log(data);
                this.activeRune.selectedPoints.push(data);
                this.activeRune.currentIndex = data;
            }
        };
        module.exports = DataController;
    }, {
        "../global/util": 325,
        "./DataModel": 322
    } ],
    322: [ function(require, module, exports) {
        var constants = require("../global/const");
        function TabletData(gridOptions) {
            var units = 10;
            this.gridOptions = {
                units: units,
                res: constants.CANVAS_SIZE / units,
                padding: 20
            };
            if (gridOptions != null) {
                $.extend(this.gridOptions, gridOptions);
            }
            this.runes = [];
            this.runes.push(new RuneData());
            this.showGrid = true;
            this.renderedSVG = "";
        }
        function RuneData() {
            this.points = [];
            this.transforms = [];
            this.selectedPoints = [];
            this.currentIndex = 0;
        }
        module.exports = TabletData;
    }, {
        "../global/const": 324
    } ],
    323: [ function(require, module, exports) {
        var util = require("./util");
        function Events(app) {
            this.app = app;
            var events = this;
            this.eventHandlers = {
                addPoint: function(data) {
                    events.app.data.addPoint(data);
                    events.app.canvas.draw();
                },
                selectPoint: function(data) {
                    if (data[0]) {
                        events.app.data.selectPoint(data[1]);
                    } else {
                        events.app.data.activeRune.selectedPoints = _.without(app.data.activeRune.selectedPoints, data[1]);
                    }
                },
                clearGridPoints: function(e) {
                    events.app.data.clearRune();
                    events.app.canvas.draw();
                },
                toggleGrid: function(e) {
                    events.app.canvas.toggleGrid();
                },
                deselectAll: function(e) {
                    events.app.data.activeRune.selectedPoints = [];
                    events.app.canvas.draw();
                }
            };
        }
        Events.prototype = {
            constructor: Events,
            init: function() {
                var events = this;
                document.addEventListener("runeEvent", function(e) {
                    console.log("Event received: " + e.detail.event);
                    events.eventHandlers[e.detail.event](e.detail.data);
                });
                document.addEventListener("keydown", function(e) {
                    console.log(e.keyCode);
                    switch (e.keyCode) {
                      case 8:
                        e.preventDefault();
                        events.app.data.deleteSelected();
                        events.app.canvas.draw();
                        util.dispatchRuneEvent("deselectAll");
                        break;
                    }
                });
            }
        };
        module.exports = Events;
    }, {
        "./util": 325
    } ],
    324: [ function(require, module, exports) {
        var constants = {
            SILVER_RATIO: Math.sqrt(2),
            GOLDEN_RATIO: (1 + Math.sqrt(5)) / 2,
            CANVAS_SIZE: 360
        };
        module.exports = constants;
    }, {} ],
    325: [ function(require, module, exports) {
        var paper = require("paper");
        module.exports = {
            getIndices: function(points, gridPoints) {
                return points.map(function(point) {
                    return gridPoints.indexOf(point);
                });
            },
            object: function(o) {
                function F() {}
                F.prototype = o;
                return new F();
            },
            checkLocal: function(ref) {
                return localStorage[ref] && typeof localStorage[ref] === "string" ? JSON.parse(localStorage[ref]) : false;
            },
            dispatchRuneEvent: function(name, data) {
                var runeEvent = new CustomEvent("runeEvent", {
                    detail: {
                        event: name,
                        data: data
                    }
                });
                document.dispatchEvent(runeEvent);
            },
            trig: {
                getMid: function(p1, p2) {
                    return [ (p1.x + p2.x) / 2, (p1.y + p2.y) / 2 ];
                },
                getDistance: function(p1, p2) {
                    return this.getSize(p1.y - p2.y, p1.x - p2.x, null);
                },
                getSize: function(adj, opp, hyp) {
                    if (adj & hyp) {
                        return Math.sqrt(hyp * hyp - adj * adj);
                    } else if (adj & opp) {
                        return Math.sqrt(opp * opp + adj * adj);
                    } else if (opp & hyp) {
                        return Math.sqrt(hyp * hyp - opp * opp);
                    }
                },
                getAngle: function(p1, p2) {
                    var adj = p1.getDistance(new paper.Point(p2.x, p1.y));
                    var hyp = p1.getDistance(p2);
                    return Math.PI / 2 - Math.acos(adj / hyp);
                },
                radToDeg: function(radians) {
                    return radians * (180 / Math.PI);
                },
                degToRad: function(degrees) {
                    return degrees / (180 / Math.PI);
                }
            }
        };
        paper.Point.prototype.getMid = function(p2) {
            return new paper.Point((this.x + p2.x) / 2, (this.y + p2.y) / 2);
        };
    }, {
        paper: 157
    } ],
    326: [ function(require, module, exports) {
        "use strict";
        var React = require("react"), Draggable = require("react-draggable");
        var util = require("../global/util.js");
        var transformPanel = require("./TransformPanel");
        function PanelController(data) {
            var panelController = this;
            console.log(data);
            panelController.panels = [ {
                template: React.createElement("p", null),
                title: "Properties",
                data: {}
            }, {
                template: React.createElement("p", null),
                title: "Nudge",
                data: {}
            }, {
                title: "Transform",
                template: React.createElement("p", null, "Hello world"),
                data: {
                    res: 0,
                    points: data.activeRune.points
                }
            } ];
            panelController.loadPanels();
        }
        PanelController.prototype = {
            constructor: PanelController,
            loadPanels: function() {
                var panelController = this;
                var PanelComponent = React.createClass({
                    displayName: "PanelComponent",
                    handleStart: function() {},
                    handleDrag: function() {},
                    handleStop: function() {},
                    render: function() {
                        var offsetY = this.props.offset * 200;
                        return React.createElement(Draggable, {
                            start: {
                                x: 800,
                                y: offsetY
                            },
                            onStart: this.handleStart
                        }, React.createElement("div", {
                            className: "panel"
                        }, React.createElement("div", {
                            className: "handle"
                        }), React.createElement("div", {
                            className: "panel-content"
                        }, React.createElement("h4", null, this.props.options.title), this.props.options.template, this.props.options.data.points)));
                    }
                });
                var Panels = React.createClass({
                    displayName: "Panels",
                    render: function() {
                        return React.createElement("div", null, this.props.data.map(function(result, index) {
                            return React.createElement(PanelComponent, {
                                options: result,
                                offset: index
                            });
                        }));
                    }
                });
                React.render(React.createElement(Panels, {
                    data: panelController.panels
                }), document.getElementById("rune-panels"));
            },
            updateProperties: function(model) {}
        };
        module.exports = PanelController;
    }, {
        "../global/util.js": 325,
        "./TransformPanel": 327,
        react: 316,
        "react-draggable": 158
    } ],
    327: [ function(require, module, exports) {
        function TransformPanel() {
            console.log("Transform!");
            this.title = "Transform";
            var transform = this;
            this.transforms = [ {
                id: "weight",
                title: "Fix weight",
                action: function(e) {
                    e.preventDefault();
                    transform.weight(app.tablet.getActiveRune().letter.selectedPoints, app.tablet.getActiveRune().gridOptions.res * 2);
                }
            } ];
            this.transforms.forEach(function(transform) {
                console.log("What?");
                console.log(transform);
                $("#rune-panels").on("click", '[data-transform="' + transform.id + '"]', transform.action);
            });
        }
        TransformPanel.prototype = {
            constructor: TransformPanel,
            weight: function(originalPoints, res) {
                points = originalPoints.map(function(entry) {
                    return new paper.Point(app.workspace.runeView.letter.points[entry].point);
                });
                var testPath = new paper.Path();
                testPath.strokeColor = "red";
                var midPoint = points[0].getMid(points[2]);
                var circle = new paper.Path.Circle(midPoint, res / 2);
                circle.strokeColor = "black";
                var t1_hyp = points[2].getDistance(midPoint);
                var t1_adj = res / 2;
                var t1_phi = 90 - trigUtil.radToDeg(Math.acos(t1_adj / t1_hyp));
                var vec = new paper.Point();
                vec.angle = 90 - trigUtil.radToDeg(trigUtil.getAngle(points[0], points[2])) - t1_phi;
                var side = trigUtil.getSize(null, t1_adj, t1_hyp);
                vec.length = side;
                var tangentPoint = points[2].subtract(vec);
                testPath.moveTo(points[2]);
                testPath.lineTo(tangentPoint);
                var otherPoint = new paper.Point(points[0].x, points[2].y);
                var t2_adj = otherPoint.getDistance(points[2]);
                var t2_hyp = t2_adj / Math.cos(trigUtil.degToRad(vec.angle));
                vec.length = Math.abs(t2_hyp) - vec.length;
                var newPoint3 = tangentPoint.subtract(vec);
                testPath.lineTo(newPoint3);
                var finalMeasure = points[0].getDistance(newPoint3);
                console.log("Distance" + finalMeasure);
                app.tablet.getActiveRune().letter.transforms[originalPoints[3]] = [ -90, -finalMeasure ];
                app.tablet.getActiveRune().letter.transforms[originalPoints[1]] = [ 90, finalMeasure ];
            },
            randomise: function(points) {}
        };
        module.exports = TransformPanel;
    }, {} ],
    328: [ function(require, module, exports) {
        var React = require("React");
        var util = require("../global/util.js");
        function ActionBar() {
            this.actions = [ {
                id: "save",
                title: "Save tablet",
                action: function(e) {
                    e.preventDefault();
                    app.saveTablet();
                }
            }, {
                id: "clear",
                title: "Clear",
                action: function(e) {
                    e.preventDefault();
                    util.dispatchRuneEvent("clearGridPoints");
                }
            }, {
                id: "grid",
                title: "Toggle Grid",
                action: function(e) {
                    e.preventDefault();
                    util.dispatchRuneEvent("toggleGrid");
                }
            }, {
                id: "rune",
                title: "Add rune",
                action: function(e) {
                    e.preventDefault();
                    app.tablet.addRune();
                }
            }, {
                id: "svg",
                title: "Export as SVG",
                action: function(e) {
                    e.preventDefault();
                    var svgString = paper.project.exportSVG({
                        asString: true
                    });
                    var url = "data:image/svg+xml;utf8," + encodeURIComponent(svgString);
                    var link = document.createElement("a");
                    link.download = "rune_export.svg";
                    link.href = url;
                    link.click();
                }
            } ];
            this.render();
            this.addEvents();
        }
        ActionBar.prototype.addEvents = function(container) {
            for (var i = 0; i < this.actions.length; i++) {
                var action = this.actions[i];
                document.querySelectorAll('[data-action="' + action.id + '"]')[0].onclick = action.action;
            }
        };
        ActionBar.prototype.render = function() {
            console.log("this is working");
            var actions = this.actions;
            var ActionBarComponent = React.createClass({
                displayName: "ActionBarComponent",
                render: function() {
                    return React.createElement("ul", null, this.props.actions.map(function(action, i) {
                        return React.createElement("li", null, React.createElement("a", {
                            className: "action",
                            "data-action": action.id
                        }, action.title));
                    }));
                }
            });
            React.render(React.createElement(ActionBarComponent, {
                actions: actions
            }), document.getElementById("rune-actionbar"));
        };
        module.exports = ActionBar;
    }, {
        "../global/util.js": 325,
        React: 155
    } ],
    329: [ function(require, module, exports) {
        var ActionBar = require("./ActionBarController.jsx");
        var PanelController = require("./../panels/PanelController.jsx");
        var React = require("React");
        function WorkSpaceController(tabletModel) {
            this.addActionBar();
            this.panels = new PanelController(tabletModel);
        }
        WorkSpaceController.prototype = {
            constructor: WorkSpaceController,
            addLayers: function(data) {},
            addActionBar: function() {
                this.actionBar = new ActionBar();
            }
        };
        module.exports = WorkSpaceController;
    }, {
        "./../panels/PanelController.jsx": 326,
        "./ActionBarController.jsx": 328,
        React: 155
    } ]
}, {}, [ 317 ]);